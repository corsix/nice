// Autogenerated by nicify.lua -- do not edit by hand.
#include <nice/d3.h>
namespace C6
{
  namespace D3
  {
    void Multithread::leave()
    {
      getRawInterface()->Leave();
    }

    BOOL Multithread::getMultithreadProtected()
    {
      return getRawInterface()->GetMultithreadProtected();
    }

    BOOL Multithread::setMultithreadProtected(BOOL bMTProtect)
    {
      return getRawInterface()->SetMultithreadProtected(bMTProtect);
    }

    void Multithread::enter()
    {
      getRawInterface()->Enter();
    }

    void DeviceChild::getPrivateData(REFGUID guid, unsigned int* pDataSize, void* pData)
    {
      HRESULT hr = getRawInterface()->GetPrivateData(guid, pDataSize, pData);
      if(FAILED(hr)) throw COMException(hr, "ID3D10DeviceChild::GetPrivateData");
    }

    D3::Device DeviceChild::getDevice()
    {
      ID3D10Device* ppDevice = nullptr;
      getRawInterface()->GetDevice(&ppDevice);
      return D3::Device(ppDevice);
    }

    void DeviceChild::setPrivateData(REFGUID guid)
    {
      HRESULT hr = getRawInterface()->SetPrivateData(guid, 0, nullptr);
      if(FAILED(hr)) throw COMException(hr, "ID3D10DeviceChild::SetPrivateData");
    }

    void DeviceChild::setPrivateDataInterface(REFGUID guid)
    {
      HRESULT hr = getRawInterface()->SetPrivateDataInterface(guid, nullptr);
      if(FAILED(hr)) throw COMException(hr, "ID3D10DeviceChild::SetPrivateDataInterface");
    }

    void DeviceChild::setPrivateDataInterface(REFGUID guid, const IUnknown& pData)
    {
      HRESULT hr = getRawInterface()->SetPrivateDataInterface(guid, &pData);
      if(FAILED(hr)) throw COMException(hr, "ID3D10DeviceChild::SetPrivateDataInterface");
    }

    D3D10_RASTERIZER_DESC RasterizerState::getDesc()
    {
      D3D10_RASTERIZER_DESC pDesc = D3D10_RASTERIZER_DESC();
      getRawInterface()->GetDesc(&pDesc);
      return pDesc;
    }

    D3D10_BLEND_DESC BlendState::getDesc()
    {
      D3D10_BLEND_DESC pDesc = D3D10_BLEND_DESC();
      getRawInterface()->GetDesc(&pDesc);
      return pDesc;
    }

    D3D10_BLEND_DESC1 BlendState1::getDesc1()
    {
      D3D10_BLEND_DESC1 pDesc = D3D10_BLEND_DESC1();
      getRawInterface()->GetDesc1(&pDesc);
      return pDesc;
    }

    void Asynchronous::begin()
    {
      getRawInterface()->Begin();
    }

    void Asynchronous::getData(void* pData, unsigned int DataSize, unsigned int GetDataFlags)
    {
      HRESULT hr = getRawInterface()->GetData(pData, DataSize, GetDataFlags);
      if(FAILED(hr)) throw COMException(hr, "ID3D10Asynchronous::GetData");
    }

    unsigned int Asynchronous::getDataSize()
    {
      return getRawInterface()->GetDataSize();
    }

    void Asynchronous::end()
    {
      getRawInterface()->End();
    }

    D3D10_QUERY_DESC Query::getDesc()
    {
      D3D10_QUERY_DESC pDesc = D3D10_QUERY_DESC();
      getRawInterface()->GetDesc(&pDesc);
      return pDesc;
    }

    D3D10_COUNTER_DESC Counter::getDesc()
    {
      D3D10_COUNTER_DESC pDesc = D3D10_COUNTER_DESC();
      getRawInterface()->GetDesc(&pDesc);
      return pDesc;
    }

    unsigned int Resource::getEvictionPriority()
    {
      return getRawInterface()->GetEvictionPriority();
    }

    void Resource::setEvictionPriority(unsigned int EvictionPriority)
    {
      getRawInterface()->SetEvictionPriority(EvictionPriority);
    }

    D3D10_RESOURCE_DIMENSION Resource::getType()
    {
      D3D10_RESOURCE_DIMENSION rType = D3D10_RESOURCE_DIMENSION();
      getRawInterface()->GetType(&rType);
      return rType;
    }

    void Texture1D::unmap(unsigned int Subresource)
    {
      getRawInterface()->Unmap(Subresource);
    }

    D3D10_TEXTURE1D_DESC Texture1D::getDesc()
    {
      D3D10_TEXTURE1D_DESC pDesc = D3D10_TEXTURE1D_DESC();
      getRawInterface()->GetDesc(&pDesc);
      return pDesc;
    }

    void* Texture1D::map(unsigned int Subresource, D3D10_MAP MapType, unsigned int MapFlags)
    {
      void* ppData = nullptr;
      HRESULT hr = getRawInterface()->Map(Subresource, MapType, MapFlags, &ppData);
      if(FAILED(hr)) throw COMException(hr, "ID3D10Texture1D::Map");
      return ppData;
    }

    void Texture2D::unmap(unsigned int Subresource)
    {
      getRawInterface()->Unmap(Subresource);
    }

    D3D10_TEXTURE2D_DESC Texture2D::getDesc()
    {
      D3D10_TEXTURE2D_DESC pDesc = D3D10_TEXTURE2D_DESC();
      getRawInterface()->GetDesc(&pDesc);
      return pDesc;
    }

    D3D10_MAPPED_TEXTURE2D Texture2D::map(unsigned int Subresource, D3D10_MAP MapType, unsigned int MapFlags)
    {
      D3D10_MAPPED_TEXTURE2D pMappedTex2D = D3D10_MAPPED_TEXTURE2D();
      HRESULT hr = getRawInterface()->Map(Subresource, MapType, MapFlags, &pMappedTex2D);
      if(FAILED(hr)) throw COMException(hr, "ID3D10Texture2D::Map");
      return pMappedTex2D;
    }

    void Texture3D::unmap(unsigned int Subresource)
    {
      getRawInterface()->Unmap(Subresource);
    }

    D3D10_TEXTURE3D_DESC Texture3D::getDesc()
    {
      D3D10_TEXTURE3D_DESC pDesc = D3D10_TEXTURE3D_DESC();
      getRawInterface()->GetDesc(&pDesc);
      return pDesc;
    }

    D3D10_MAPPED_TEXTURE3D Texture3D::map(unsigned int Subresource, D3D10_MAP MapType, unsigned int MapFlags)
    {
      D3D10_MAPPED_TEXTURE3D pMappedTex3D = D3D10_MAPPED_TEXTURE3D();
      HRESULT hr = getRawInterface()->Map(Subresource, MapType, MapFlags, &pMappedTex3D);
      if(FAILED(hr)) throw COMException(hr, "ID3D10Texture3D::Map");
      return pMappedTex3D;
    }

    void Buffer::unmap()
    {
      getRawInterface()->Unmap();
    }

    D3D10_BUFFER_DESC Buffer::getDesc()
    {
      D3D10_BUFFER_DESC pDesc = D3D10_BUFFER_DESC();
      getRawInterface()->GetDesc(&pDesc);
      return pDesc;
    }

    void* Buffer::map(D3D10_MAP MapType, unsigned int MapFlags)
    {
      void* ppData = nullptr;
      HRESULT hr = getRawInterface()->Map(MapType, MapFlags, &ppData);
      if(FAILED(hr)) throw COMException(hr, "ID3D10Buffer::Map");
      return ppData;
    }

    D3D10_DEPTH_STENCIL_DESC DepthStencilState::getDesc()
    {
      D3D10_DEPTH_STENCIL_DESC pDesc = D3D10_DEPTH_STENCIL_DESC();
      getRawInterface()->GetDesc(&pDesc);
      return pDesc;
    }

    D3::Resource View::getResource()
    {
      ID3D10Resource* ppResource = nullptr;
      getRawInterface()->GetResource(&ppResource);
      return D3::Resource(ppResource);
    }

    D3D10_RENDER_TARGET_VIEW_DESC RenderTargetView::getDesc()
    {
      D3D10_RENDER_TARGET_VIEW_DESC pDesc = D3D10_RENDER_TARGET_VIEW_DESC();
      getRawInterface()->GetDesc(&pDesc);
      return pDesc;
    }

    D3D10_SHADER_RESOURCE_VIEW_DESC ShaderResourceView::getDesc()
    {
      D3D10_SHADER_RESOURCE_VIEW_DESC pDesc = D3D10_SHADER_RESOURCE_VIEW_DESC();
      getRawInterface()->GetDesc(&pDesc);
      return pDesc;
    }

    D3D10_SHADER_RESOURCE_VIEW_DESC1 ShaderResourceView1::getDesc1()
    {
      D3D10_SHADER_RESOURCE_VIEW_DESC1 pDesc = D3D10_SHADER_RESOURCE_VIEW_DESC1();
      getRawInterface()->GetDesc1(&pDesc);
      return pDesc;
    }

    D3D10_DEPTH_STENCIL_VIEW_DESC DepthStencilView::getDesc()
    {
      D3D10_DEPTH_STENCIL_VIEW_DESC pDesc = D3D10_DEPTH_STENCIL_VIEW_DESC();
      getRawInterface()->GetDesc(&pDesc);
      return pDesc;
    }

    D3D10_SAMPLER_DESC SamplerState::getDesc()
    {
      D3D10_SAMPLER_DESC pDesc = D3D10_SAMPLER_DESC();
      getRawInterface()->GetDesc(&pDesc);
      return pDesc;
    }

    std::vector<D3D10_VIEWPORT> Device::RSGetViewports(unsigned int* NumViewports)
    {
      std::vector<D3D10_VIEWPORT> pViewports(static_cast<size_t>(NumViewports ? *NumViewports : 0));
      getRawInterface()->RSGetViewports(NumViewports, pViewports.data());
      return pViewports;
    }

    void Device::GSSetShader()
    {
      getRawInterface()->GSSetShader(nullptr);
    }

    void Device::GSSetShader(D3::GeometryShader& pShader)
    {
      getRawInterface()->GSSetShader(pShader.getRawInterface());
    }

    D3::RasterizerState Device::createRasterizerState(const D3D10_RASTERIZER_DESC& pRasterizerDesc)
    {
      ID3D10RasterizerState* ppRasterizerState = nullptr;
      HRESULT hr = getRawInterface()->CreateRasterizerState(&pRasterizerDesc, &ppRasterizerState);
      if(FAILED(hr)) throw COMException(hr, "ID3D10Device::CreateRasterizerState");
      return D3::RasterizerState(ppRasterizerState);
    }

    void Device::RSSetViewports()
    {
      getRawInterface()->RSSetViewports(0, nullptr);
    }

    D3::PixelShader Device::PSGetShader()
    {
      ID3D10PixelShader* ppPixelShader = nullptr;
      getRawInterface()->PSGetShader(&ppPixelShader);
      return D3::PixelShader(ppPixelShader);
    }

    std::tuple<unsigned int, unsigned int> Device::getTextFilterSize()
    {
      unsigned int pWidth = unsigned int();
      unsigned int pHeight = unsigned int();
      getRawInterface()->GetTextFilterSize(&pWidth, &pHeight);
      return std::make_tuple(std::move(pWidth), std::move(pHeight));
    }

    void Device::VSSetShader()
    {
      getRawInterface()->VSSetShader(nullptr);
    }

    void Device::VSSetShader(D3::VertexShader& pVertexShader)
    {
      getRawInterface()->VSSetShader(pVertexShader.getRawInterface());
    }

    std::vector<ID3D10ShaderResourceView*> Device::VSGetShaderResources(unsigned int StartSlot, unsigned int NumViews)
    {
      std::vector<ID3D10ShaderResourceView*> ppShaderResourceViews(static_cast<size_t>(NumViews));
      getRawInterface()->VSGetShaderResources(StartSlot, NumViews, ppShaderResourceViews.data());
      return ppShaderResourceViews;
    }

    D3::VertexShader Device::VSGetShader()
    {
      ID3D10VertexShader* ppVertexShader = nullptr;
      getRawInterface()->VSGetShader(&ppVertexShader);
      return D3::VertexShader(ppVertexShader);
    }

    void Device::drawInstanced(unsigned int VertexCountPerInstance, unsigned int InstanceCount, unsigned int StartVertexLocation, unsigned int StartInstanceLocation)
    {
      getRawInterface()->DrawInstanced(VertexCountPerInstance, InstanceCount, StartVertexLocation, StartInstanceLocation);
    }

    void Device::drawIndexed(unsigned int IndexCount, unsigned int StartIndexLocation, int BaseVertexLocation)
    {
      getRawInterface()->DrawIndexed(IndexCount, StartIndexLocation, BaseVertexLocation);
    }

    void Device::copyResource(D3::Resource& pDstResource, D3::Resource& pSrcResource)
    {
      getRawInterface()->CopyResource(pDstResource.getRawInterface(), pSrcResource.getRawInterface());
    }

    std::tuple<std::vector<ID3D10Buffer*>, std::vector<unsigned int>> Device::SOGetTargets(unsigned int NumBuffers)
    {
      std::vector<ID3D10Buffer*> ppSOTargets(static_cast<size_t>(NumBuffers));
      std::vector<unsigned int> pOffsets(static_cast<size_t>(NumBuffers));
      getRawInterface()->SOGetTargets(NumBuffers, ppSOTargets.data(), pOffsets.data());
      return std::make_tuple(std::move(ppSOTargets), std::move(pOffsets));
    }

    std::vector<ID3D10ShaderResourceView*> Device::PSGetShaderResources(unsigned int StartSlot, unsigned int NumViews)
    {
      std::vector<ID3D10ShaderResourceView*> ppShaderResourceViews(static_cast<size_t>(NumViews));
      getRawInterface()->PSGetShaderResources(StartSlot, NumViews, ppShaderResourceViews.data());
      return ppShaderResourceViews;
    }

    D3::InputLayout Device::IAGetInputLayout()
    {
      ID3D10InputLayout* ppInputLayout = nullptr;
      getRawInterface()->IAGetInputLayout(&ppInputLayout);
      return D3::InputLayout(ppInputLayout);
    }

    void Device::setTextFilterSize(unsigned int Width, unsigned int Height)
    {
      getRawInterface()->SetTextFilterSize(Width, Height);
    }

    void Device::PSSetShader()
    {
      getRawInterface()->PSSetShader(nullptr);
    }

    void Device::PSSetShader(D3::PixelShader& pPixelShader)
    {
      getRawInterface()->PSSetShader(pPixelShader.getRawInterface());
    }

    void Device::updateSubresource(D3::Resource& pDstResource, unsigned int DstSubresource, const void* pSrcData, unsigned int SrcRowPitch, unsigned int SrcDepthPitch)
    {
      getRawInterface()->UpdateSubresource(pDstResource.getRawInterface(), DstSubresource, nullptr, pSrcData, SrcRowPitch, SrcDepthPitch);
    }

    void Device::updateSubresource(D3::Resource& pDstResource, unsigned int DstSubresource, const D3D10_BOX& pDstBox, const void* pSrcData, unsigned int SrcRowPitch, unsigned int SrcDepthPitch)
    {
      getRawInterface()->UpdateSubresource(pDstResource.getRawInterface(), DstSubresource, &pDstBox, pSrcData, SrcRowPitch, SrcDepthPitch);
    }

    unsigned int Device::checkMultisampleQualityLevels(DXGI_FORMAT Format, unsigned int SampleCount)
    {
      unsigned int pNumQualityLevels = unsigned int();
      HRESULT hr = getRawInterface()->CheckMultisampleQualityLevels(Format, SampleCount, &pNumQualityLevels);
      if(FAILED(hr)) throw COMException(hr, "ID3D10Device::CheckMultisampleQualityLevels");
      return pNumQualityLevels;
    }

    void Device::clearState()
    {
      getRawInterface()->ClearState();
    }

    void Device::OMSetDepthStencilState(unsigned int StencilRef)
    {
      getRawInterface()->OMSetDepthStencilState(nullptr, StencilRef);
    }

    void Device::OMSetDepthStencilState(D3::DepthStencilState& pDepthStencilState, unsigned int StencilRef)
    {
      getRawInterface()->OMSetDepthStencilState(pDepthStencilState.getRawInterface(), StencilRef);
    }

    std::vector<ID3D10Buffer*> Device::PSGetConstantBuffers(unsigned int StartSlot, unsigned int NumBuffers)
    {
      std::vector<ID3D10Buffer*> ppConstantBuffers(static_cast<size_t>(NumBuffers));
      getRawInterface()->PSGetConstantBuffers(StartSlot, NumBuffers, ppConstantBuffers.data());
      return ppConstantBuffers;
    }

    std::vector<ID3D10SamplerState*> Device::PSGetSamplers(unsigned int StartSlot, unsigned int NumSamplers)
    {
      std::vector<ID3D10SamplerState*> ppSamplers(static_cast<size_t>(NumSamplers));
      getRawInterface()->PSGetSamplers(StartSlot, NumSamplers, ppSamplers.data());
      return ppSamplers;
    }

    std::vector<ID3D10Buffer*> Device::GSGetConstantBuffers(unsigned int StartSlot, unsigned int NumBuffers)
    {
      std::vector<ID3D10Buffer*> ppConstantBuffers(static_cast<size_t>(NumBuffers));
      getRawInterface()->GSGetConstantBuffers(StartSlot, NumBuffers, ppConstantBuffers.data());
      return ppConstantBuffers;
    }

    void Device::drawAuto()
    {
      getRawInterface()->DrawAuto();
    }

    D3::BlendState Device::createBlendState(const D3D10_BLEND_DESC& pBlendStateDesc)
    {
      ID3D10BlendState* ppBlendState = nullptr;
      HRESULT hr = getRawInterface()->CreateBlendState(&pBlendStateDesc, &ppBlendState);
      if(FAILED(hr)) throw COMException(hr, "ID3D10Device::CreateBlendState");
      return D3::BlendState(ppBlendState);
    }

    void Device::OMSetBlendState(const float BlendFactor[4], unsigned int SampleMask)
    {
      getRawInterface()->OMSetBlendState(nullptr, BlendFactor, SampleMask);
    }

    void Device::OMSetBlendState(D3::BlendState& pBlendState, const float BlendFactor[4], unsigned int SampleMask)
    {
      getRawInterface()->OMSetBlendState(pBlendState.getRawInterface(), BlendFactor, SampleMask);
    }

    void Device::RSSetScissorRects()
    {
      getRawInterface()->RSSetScissorRects(0, nullptr);
    }

    std::vector<ID3D10SamplerState*> Device::GSGetSamplers(unsigned int StartSlot, unsigned int NumSamplers)
    {
      std::vector<ID3D10SamplerState*> ppSamplers(static_cast<size_t>(NumSamplers));
      getRawInterface()->GSGetSamplers(StartSlot, NumSamplers, ppSamplers.data());
      return ppSamplers;
    }

    void Device::SOSetTargets()
    {
      getRawInterface()->SOSetTargets(0, nullptr, nullptr);
    }

    std::tuple<D3::BlendState, unsigned int> Device::OMGetBlendState(float BlendFactor[4])
    {
      ID3D10BlendState* ppBlendState = nullptr;
      unsigned int pSampleMask = unsigned int();
      getRawInterface()->OMGetBlendState(&ppBlendState, BlendFactor, &pSampleMask);
      return std::make_tuple(std::move(D3::BlendState(ppBlendState)), std::move(pSampleMask));
    }

    void Device::getPrivateData(REFGUID guid, unsigned int* pDataSize, void* pData)
    {
      HRESULT hr = getRawInterface()->GetPrivateData(guid, pDataSize, pData);
      if(FAILED(hr)) throw COMException(hr, "ID3D10Device::GetPrivateData");
    }

    unsigned int Device::getCreationFlags()
    {
      return getRawInterface()->GetCreationFlags();
    }

    D3::ShaderResourceView Device::createShaderResourceView(D3::Resource& pResource)
    {
      ID3D10ShaderResourceView* ppSRView = nullptr;
      HRESULT hr = getRawInterface()->CreateShaderResourceView(pResource.getRawInterface(), nullptr, &ppSRView);
      if(FAILED(hr)) throw COMException(hr, "ID3D10Device::CreateShaderResourceView");
      return D3::ShaderResourceView(ppSRView);
    }

    D3::ShaderResourceView Device::createShaderResourceView(D3::Resource& pResource, const D3D10_SHADER_RESOURCE_VIEW_DESC& pDesc)
    {
      ID3D10ShaderResourceView* ppSRView = nullptr;
      HRESULT hr = getRawInterface()->CreateShaderResourceView(pResource.getRawInterface(), &pDesc, &ppSRView);
      if(FAILED(hr)) throw COMException(hr, "ID3D10Device::CreateShaderResourceView");
      return D3::ShaderResourceView(ppSRView);
    }

    void Device::IASetPrimitiveTopology(D3D10_PRIMITIVE_TOPOLOGY Topology)
    {
      getRawInterface()->IASetPrimitiveTopology(Topology);
    }

    std::vector<D3D10_RECT> Device::RSGetScissorRects(unsigned int* NumRects)
    {
      std::vector<D3D10_RECT> pRects(static_cast<size_t>(NumRects ? *NumRects : 0));
      getRawInterface()->RSGetScissorRects(NumRects, pRects.data());
      return pRects;
    }

    std::tuple<D3D10_COUNTER_TYPE, unsigned int> Device::checkCounter(const D3D10_COUNTER_DESC& pDesc, LPSTR szName, unsigned int* pNameLength, LPSTR szUnits, unsigned int* pUnitsLength, LPSTR szDescription, unsigned int* pDescriptionLength)
    {
      D3D10_COUNTER_TYPE pType = D3D10_COUNTER_TYPE();
      unsigned int pActiveCounters = unsigned int();
      HRESULT hr = getRawInterface()->CheckCounter(&pDesc, &pType, &pActiveCounters, szName, pNameLength, szUnits, pUnitsLength, szDescription, pDescriptionLength);
      if(FAILED(hr)) throw COMException(hr, "ID3D10Device::CheckCounter");
      return std::make_tuple(std::move(pType), std::move(pActiveCounters));
    }

    D3D10_COUNTER_INFO Device::checkCounterInfo()
    {
      D3D10_COUNTER_INFO pCounterInfo = D3D10_COUNTER_INFO();
      getRawInterface()->CheckCounterInfo(&pCounterInfo);
      return pCounterInfo;
    }

    unsigned int Device::checkFormatSupport(DXGI_FORMAT Format)
    {
      unsigned int pFormatSupport = unsigned int();
      HRESULT hr = getRawInterface()->CheckFormatSupport(Format, &pFormatSupport);
      if(FAILED(hr)) throw COMException(hr, "ID3D10Device::CheckFormatSupport");
      return pFormatSupport;
    }

    D3::Counter Device::createCounter(const D3D10_COUNTER_DESC& pCounterDesc)
    {
      ID3D10Counter* ppCounter = nullptr;
      HRESULT hr = getRawInterface()->CreateCounter(&pCounterDesc, &ppCounter);
      if(FAILED(hr)) throw COMException(hr, "ID3D10Device::CreateCounter");
      return D3::Counter(ppCounter);
    }

    D3::Query Device::createQuery(const D3D10_QUERY_DESC& pQueryDesc)
    {
      ID3D10Query* ppQuery = nullptr;
      HRESULT hr = getRawInterface()->CreateQuery(&pQueryDesc, &ppQuery);
      if(FAILED(hr)) throw COMException(hr, "ID3D10Device::CreateQuery");
      return D3::Query(ppQuery);
    }

    void Device::OMSetRenderTargets()
    {
      getRawInterface()->OMSetRenderTargets(0, nullptr, nullptr);
    }

    std::tuple<D3::Buffer, DXGI_FORMAT, unsigned int> Device::IAGetIndexBuffer()
    {
      ID3D10Buffer* pIndexBuffer = nullptr;
      DXGI_FORMAT Format = DXGI_FORMAT();
      unsigned int Offset = unsigned int();
      getRawInterface()->IAGetIndexBuffer(&pIndexBuffer, &Format, &Offset);
      return std::make_tuple(std::move(D3::Buffer(pIndexBuffer)), std::move(Format), std::move(Offset));
    }

    void Device::IASetInputLayout()
    {
      getRawInterface()->IASetInputLayout(nullptr);
    }

    void Device::IASetInputLayout(D3::InputLayout& pInputLayout)
    {
      getRawInterface()->IASetInputLayout(pInputLayout.getRawInterface());
    }

    void Device::setPrivateData(REFGUID guid)
    {
      HRESULT hr = getRawInterface()->SetPrivateData(guid, 0, nullptr);
      if(FAILED(hr)) throw COMException(hr, "ID3D10Device::SetPrivateData");
    }

    void Device::draw(unsigned int VertexCount, unsigned int StartVertexLocation)
    {
      getRawInterface()->Draw(VertexCount, StartVertexLocation);
    }

    void Device::flush()
    {
      getRawInterface()->Flush();
    }

    D3::DepthStencilState Device::createDepthStencilState(const D3D10_DEPTH_STENCIL_DESC& pDepthStencilDesc)
    {
      ID3D10DepthStencilState* ppDepthStencilState = nullptr;
      HRESULT hr = getRawInterface()->CreateDepthStencilState(&pDepthStencilDesc, &ppDepthStencilState);
      if(FAILED(hr)) throw COMException(hr, "ID3D10Device::CreateDepthStencilState");
      return D3::DepthStencilState(ppDepthStencilState);
    }

    D3D10_PRIMITIVE_TOPOLOGY Device::IAGetPrimitiveTopology()
    {
      D3D10_PRIMITIVE_TOPOLOGY pTopology = D3D10_PRIMITIVE_TOPOLOGY();
      getRawInterface()->IAGetPrimitiveTopology(&pTopology);
      return pTopology;
    }

    std::tuple<D3::DepthStencilState, unsigned int> Device::OMGetDepthStencilState()
    {
      ID3D10DepthStencilState* ppDepthStencilState = nullptr;
      unsigned int pStencilRef = unsigned int();
      getRawInterface()->OMGetDepthStencilState(&ppDepthStencilState, &pStencilRef);
      return std::make_tuple(std::move(D3::DepthStencilState(ppDepthStencilState)), std::move(pStencilRef));
    }

    void Device::setPrivateDataInterface(REFGUID guid)
    {
      HRESULT hr = getRawInterface()->SetPrivateDataInterface(guid, nullptr);
      if(FAILED(hr)) throw COMException(hr, "ID3D10Device::SetPrivateDataInterface");
    }

    void Device::setPrivateDataInterface(REFGUID guid, const IUnknown& pData)
    {
      HRESULT hr = getRawInterface()->SetPrivateDataInterface(guid, &pData);
      if(FAILED(hr)) throw COMException(hr, "ID3D10Device::SetPrivateDataInterface");
    }

    void Device::clearRenderTargetView(D3::RenderTargetView& pRenderTargetView, const float ColorRGBA[4])
    {
      getRawInterface()->ClearRenderTargetView(pRenderTargetView.getRawInterface(), ColorRGBA);
    }

    D3::RenderTargetView Device::createRenderTargetView(D3::Resource& pResource)
    {
      ID3D10RenderTargetView* ppRTView = nullptr;
      HRESULT hr = getRawInterface()->CreateRenderTargetView(pResource.getRawInterface(), nullptr, &ppRTView);
      if(FAILED(hr)) throw COMException(hr, "ID3D10Device::CreateRenderTargetView");
      return D3::RenderTargetView(ppRTView);
    }

    D3::RenderTargetView Device::createRenderTargetView(D3::Resource& pResource, const D3D10_RENDER_TARGET_VIEW_DESC& pDesc)
    {
      ID3D10RenderTargetView* ppRTView = nullptr;
      HRESULT hr = getRawInterface()->CreateRenderTargetView(pResource.getRawInterface(), &pDesc, &ppRTView);
      if(FAILED(hr)) throw COMException(hr, "ID3D10Device::CreateRenderTargetView");
      return D3::RenderTargetView(ppRTView);
    }

    D3::DepthStencilView Device::createDepthStencilView(D3::Resource& pResource)
    {
      ID3D10DepthStencilView* ppDepthStencilView = nullptr;
      HRESULT hr = getRawInterface()->CreateDepthStencilView(pResource.getRawInterface(), nullptr, &ppDepthStencilView);
      if(FAILED(hr)) throw COMException(hr, "ID3D10Device::CreateDepthStencilView");
      return D3::DepthStencilView(ppDepthStencilView);
    }

    D3::DepthStencilView Device::createDepthStencilView(D3::Resource& pResource, const D3D10_DEPTH_STENCIL_VIEW_DESC& pDesc)
    {
      ID3D10DepthStencilView* ppDepthStencilView = nullptr;
      HRESULT hr = getRawInterface()->CreateDepthStencilView(pResource.getRawInterface(), &pDesc, &ppDepthStencilView);
      if(FAILED(hr)) throw COMException(hr, "ID3D10Device::CreateDepthStencilView");
      return D3::DepthStencilView(ppDepthStencilView);
    }

    D3::RasterizerState Device::RSGetState()
    {
      ID3D10RasterizerState* ppRasterizerState = nullptr;
      getRawInterface()->RSGetState(&ppRasterizerState);
      return D3::RasterizerState(ppRasterizerState);
    }

    void Device::generateMips(D3::ShaderResourceView& pShaderResourceView)
    {
      getRawInterface()->GenerateMips(pShaderResourceView.getRawInterface());
    }

    D3::Texture2D Device::createTexture2D(const D3D10_TEXTURE2D_DESC& pDesc)
    {
      ID3D10Texture2D* ppTexture2D = nullptr;
      HRESULT hr = getRawInterface()->CreateTexture2D(&pDesc, nullptr, &ppTexture2D);
      if(FAILED(hr)) throw COMException(hr, "ID3D10Device::CreateTexture2D");
      return D3::Texture2D(ppTexture2D);
    }

    D3::Texture2D Device::createTexture2D(const D3D10_TEXTURE2D_DESC& pDesc, const D3D10_SUBRESOURCE_DATA& pInitialData)
    {
      ID3D10Texture2D* ppTexture2D = nullptr;
      HRESULT hr = getRawInterface()->CreateTexture2D(&pDesc, &pInitialData, &ppTexture2D);
      if(FAILED(hr)) throw COMException(hr, "ID3D10Device::CreateTexture2D");
      return D3::Texture2D(ppTexture2D);
    }

    D3::GeometryShader Device::GSGetShader()
    {
      ID3D10GeometryShader* ppGeometryShader = nullptr;
      getRawInterface()->GSGetShader(&ppGeometryShader);
      return D3::GeometryShader(ppGeometryShader);
    }

    D3::Buffer Device::createBuffer(const D3D10_BUFFER_DESC& pDesc)
    {
      ID3D10Buffer* ppBuffer = nullptr;
      HRESULT hr = getRawInterface()->CreateBuffer(&pDesc, nullptr, &ppBuffer);
      if(FAILED(hr)) throw COMException(hr, "ID3D10Device::CreateBuffer");
      return D3::Buffer(ppBuffer);
    }

    D3::Buffer Device::createBuffer(const D3D10_BUFFER_DESC& pDesc, const D3D10_SUBRESOURCE_DATA& pInitialData)
    {
      ID3D10Buffer* ppBuffer = nullptr;
      HRESULT hr = getRawInterface()->CreateBuffer(&pDesc, &pInitialData, &ppBuffer);
      if(FAILED(hr)) throw COMException(hr, "ID3D10Device::CreateBuffer");
      return D3::Buffer(ppBuffer);
    }

    std::vector<ID3D10ShaderResourceView*> Device::GSGetShaderResources(unsigned int StartSlot, unsigned int NumViews)
    {
      std::vector<ID3D10ShaderResourceView*> ppShaderResourceViews(static_cast<size_t>(NumViews));
      getRawInterface()->GSGetShaderResources(StartSlot, NumViews, ppShaderResourceViews.data());
      return ppShaderResourceViews;
    }

    D3::SamplerState Device::createSamplerState(const D3D10_SAMPLER_DESC& pSamplerDesc)
    {
      ID3D10SamplerState* ppSamplerState = nullptr;
      HRESULT hr = getRawInterface()->CreateSamplerState(&pSamplerDesc, &ppSamplerState);
      if(FAILED(hr)) throw COMException(hr, "ID3D10Device::CreateSamplerState");
      return D3::SamplerState(ppSamplerState);
    }

    void Device::copySubresourceRegion(D3::Resource& pDstResource, unsigned int DstSubresource, unsigned int DstX, unsigned int DstY, unsigned int DstZ, D3::Resource& pSrcResource, unsigned int SrcSubresource)
    {
      getRawInterface()->CopySubresourceRegion(pDstResource.getRawInterface(), DstSubresource, DstX, DstY, DstZ, pSrcResource.getRawInterface(), SrcSubresource, nullptr);
    }

    void Device::copySubresourceRegion(D3::Resource& pDstResource, unsigned int DstSubresource, unsigned int DstX, unsigned int DstY, unsigned int DstZ, D3::Resource& pSrcResource, unsigned int SrcSubresource, const D3D10_BOX& pSrcBox)
    {
      getRawInterface()->CopySubresourceRegion(pDstResource.getRawInterface(), DstSubresource, DstX, DstY, DstZ, pSrcResource.getRawInterface(), SrcSubresource, &pSrcBox);
    }

    D3::Texture1D Device::createTexture1D(const D3D10_TEXTURE1D_DESC& pDesc)
    {
      ID3D10Texture1D* ppTexture1D = nullptr;
      HRESULT hr = getRawInterface()->CreateTexture1D(&pDesc, nullptr, &ppTexture1D);
      if(FAILED(hr)) throw COMException(hr, "ID3D10Device::CreateTexture1D");
      return D3::Texture1D(ppTexture1D);
    }

    D3::Texture1D Device::createTexture1D(const D3D10_TEXTURE1D_DESC& pDesc, const D3D10_SUBRESOURCE_DATA& pInitialData)
    {
      ID3D10Texture1D* ppTexture1D = nullptr;
      HRESULT hr = getRawInterface()->CreateTexture1D(&pDesc, &pInitialData, &ppTexture1D);
      if(FAILED(hr)) throw COMException(hr, "ID3D10Device::CreateTexture1D");
      return D3::Texture1D(ppTexture1D);
    }

    void Device::setExceptionMode(unsigned int RaiseFlags)
    {
      HRESULT hr = getRawInterface()->SetExceptionMode(RaiseFlags);
      if(FAILED(hr)) throw COMException(hr, "ID3D10Device::SetExceptionMode");
    }

    std::vector<ID3D10SamplerState*> Device::VSGetSamplers(unsigned int StartSlot, unsigned int NumSamplers)
    {
      std::vector<ID3D10SamplerState*> ppSamplers(static_cast<size_t>(NumSamplers));
      getRawInterface()->VSGetSamplers(StartSlot, NumSamplers, ppSamplers.data());
      return ppSamplers;
    }

    void Device::RSSetState()
    {
      getRawInterface()->RSSetState(nullptr);
    }

    void Device::RSSetState(D3::RasterizerState& pRasterizerState)
    {
      getRawInterface()->RSSetState(pRasterizerState.getRawInterface());
    }

    D3::Texture3D Device::createTexture3D(const D3D10_TEXTURE3D_DESC& pDesc)
    {
      ID3D10Texture3D* ppTexture3D = nullptr;
      HRESULT hr = getRawInterface()->CreateTexture3D(&pDesc, nullptr, &ppTexture3D);
      if(FAILED(hr)) throw COMException(hr, "ID3D10Device::CreateTexture3D");
      return D3::Texture3D(ppTexture3D);
    }

    D3::Texture3D Device::createTexture3D(const D3D10_TEXTURE3D_DESC& pDesc, const D3D10_SUBRESOURCE_DATA& pInitialData)
    {
      ID3D10Texture3D* ppTexture3D = nullptr;
      HRESULT hr = getRawInterface()->CreateTexture3D(&pDesc, &pInitialData, &ppTexture3D);
      if(FAILED(hr)) throw COMException(hr, "ID3D10Device::CreateTexture3D");
      return D3::Texture3D(ppTexture3D);
    }

    void Device::drawIndexedInstanced(unsigned int IndexCountPerInstance, unsigned int InstanceCount, unsigned int StartIndexLocation, int BaseVertexLocation, unsigned int StartInstanceLocation)
    {
      getRawInterface()->DrawIndexedInstanced(IndexCountPerInstance, InstanceCount, StartIndexLocation, BaseVertexLocation, StartInstanceLocation);
    }

    void Device::resolveSubresource(D3::Resource& pDstResource, unsigned int DstSubresource, D3::Resource& pSrcResource, unsigned int SrcSubresource, DXGI_FORMAT Format)
    {
      getRawInterface()->ResolveSubresource(pDstResource.getRawInterface(), DstSubresource, pSrcResource.getRawInterface(), SrcSubresource, Format);
    }

    D3::Predicate Device::createPredicate(const D3D10_QUERY_DESC& pPredicateDesc)
    {
      ID3D10Predicate* ppPredicate = nullptr;
      HRESULT hr = getRawInterface()->CreatePredicate(&pPredicateDesc, &ppPredicate);
      if(FAILED(hr)) throw COMException(hr, "ID3D10Device::CreatePredicate");
      return D3::Predicate(ppPredicate);
    }

    std::tuple<D3::Predicate, bool> Device::getPredication()
    {
      ID3D10Predicate* ppPredicate = nullptr;
      BOOL pPredicateValue = BOOL();
      getRawInterface()->GetPredication(&ppPredicate, &pPredicateValue);
      return std::make_tuple(std::move(D3::Predicate(ppPredicate)), std::move(pPredicateValue != FALSE));
    }

    void Device::clearDepthStencilView(D3::DepthStencilView& pDepthStencilView, unsigned int ClearFlags, float Depth, UINT8 Stencil)
    {
      getRawInterface()->ClearDepthStencilView(pDepthStencilView.getRawInterface(), ClearFlags, Depth, Stencil);
    }

    std::tuple<std::vector<ID3D10Buffer*>, std::vector<unsigned int>, std::vector<unsigned int>> Device::IAGetVertexBuffers(unsigned int StartSlot, unsigned int NumBuffers)
    {
      std::vector<ID3D10Buffer*> ppVertexBuffers(static_cast<size_t>(NumBuffers));
      std::vector<unsigned int> pStrides(static_cast<size_t>(NumBuffers));
      std::vector<unsigned int> pOffsets(static_cast<size_t>(NumBuffers));
      getRawInterface()->IAGetVertexBuffers(StartSlot, NumBuffers, ppVertexBuffers.data(), pStrides.data(), pOffsets.data());
      return std::make_tuple(std::move(ppVertexBuffers), std::move(pStrides), std::move(pOffsets));
    }

    void Device::setPredication(BOOL PredicateValue)
    {
      getRawInterface()->SetPredication(nullptr, PredicateValue);
    }

    void Device::setPredication(D3::Predicate& pPredicate, BOOL PredicateValue)
    {
      getRawInterface()->SetPredication(pPredicate.getRawInterface(), PredicateValue);
    }

    unsigned int Device::getExceptionMode()
    {
      return getRawInterface()->GetExceptionMode();
    }

    void Device::getDeviceRemovedReason()
    {
      HRESULT hr = getRawInterface()->GetDeviceRemovedReason();
      if(FAILED(hr)) throw COMException(hr, "ID3D10Device::GetDeviceRemovedReason");
    }

    std::tuple<std::vector<ID3D10RenderTargetView*>, D3::DepthStencilView> Device::OMGetRenderTargets(unsigned int NumViews)
    {
      std::vector<ID3D10RenderTargetView*> ppRenderTargetViews(static_cast<size_t>(NumViews));
      ID3D10DepthStencilView* ppDepthStencilView = nullptr;
      getRawInterface()->OMGetRenderTargets(NumViews, ppRenderTargetViews.data(), &ppDepthStencilView);
      return std::make_tuple(std::move(ppRenderTargetViews), std::move(D3::DepthStencilView(ppDepthStencilView)));
    }

    void Device::IASetIndexBuffer(DXGI_FORMAT Format, unsigned int Offset)
    {
      getRawInterface()->IASetIndexBuffer(nullptr, Format, Offset);
    }

    void Device::IASetIndexBuffer(D3::Buffer& pIndexBuffer, DXGI_FORMAT Format, unsigned int Offset)
    {
      getRawInterface()->IASetIndexBuffer(pIndexBuffer.getRawInterface(), Format, Offset);
    }

    std::vector<ID3D10Buffer*> Device::VSGetConstantBuffers(unsigned int StartSlot, unsigned int NumBuffers)
    {
      std::vector<ID3D10Buffer*> ppConstantBuffers(static_cast<size_t>(NumBuffers));
      getRawInterface()->VSGetConstantBuffers(StartSlot, NumBuffers, ppConstantBuffers.data());
      return ppConstantBuffers;
    }

    D3::ShaderResourceView1 Device1::createShaderResourceView1(D3::Resource& pResource)
    {
      ID3D10ShaderResourceView1* ppSRView = nullptr;
      HRESULT hr = getRawInterface()->CreateShaderResourceView1(pResource.getRawInterface(), nullptr, &ppSRView);
      if(FAILED(hr)) throw COMException(hr, "ID3D10Device1::CreateShaderResourceView1");
      return D3::ShaderResourceView1(ppSRView);
    }

    D3::ShaderResourceView1 Device1::createShaderResourceView1(D3::Resource& pResource, const D3D10_SHADER_RESOURCE_VIEW_DESC1& pDesc)
    {
      ID3D10ShaderResourceView1* ppSRView = nullptr;
      HRESULT hr = getRawInterface()->CreateShaderResourceView1(pResource.getRawInterface(), &pDesc, &ppSRView);
      if(FAILED(hr)) throw COMException(hr, "ID3D10Device1::CreateShaderResourceView1");
      return D3::ShaderResourceView1(ppSRView);
    }

    D3D10_FEATURE_LEVEL1 Device1::getFeatureLevel()
    {
      return getRawInterface()->GetFeatureLevel();
    }

    D3::BlendState1 Device1::createBlendState1(const D3D10_BLEND_DESC1& pBlendStateDesc)
    {
      ID3D10BlendState1* ppBlendState = nullptr;
      HRESULT hr = getRawInterface()->CreateBlendState1(&pBlendStateDesc, &ppBlendState);
      if(FAILED(hr)) throw COMException(hr, "ID3D10Device1::CreateBlendState1");
      return D3::BlendState1(ppBlendState);
    }

  }
}
