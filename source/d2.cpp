// Autogenerated by nicify.lua -- do not edit by hand.
#include <nice/d2.h>
namespace C6
{
  namespace D2
  {
    D2::RoundedRectangleGeometry Factory::createRoundedRectangleGeometry(const D2D1_ROUNDED_RECT& roundedRectangle)
    {
      ID2D1RoundedRectangleGeometry* roundedRectangleGeometry = nullptr;
      HRESULT hr = getRawInterface()->CreateRoundedRectangleGeometry(&roundedRectangle, &roundedRectangleGeometry);
      if(FAILED(hr)) throw COMException(hr, "ID2D1Factory::CreateRoundedRectangleGeometry");
      return D2::RoundedRectangleGeometry(roundedRectangleGeometry);
    }

    D2::PathGeometry Factory::createPathGeometry()
    {
      ID2D1PathGeometry* pathGeometry = nullptr;
      HRESULT hr = getRawInterface()->CreatePathGeometry(&pathGeometry);
      if(FAILED(hr)) throw COMException(hr, "ID2D1Factory::CreatePathGeometry");
      return D2::PathGeometry(pathGeometry);
    }

    std::tuple<float, float> Factory::getDesktopDpi()
    {
      float dpiX = float();
      float dpiY = float();
      getRawInterface()->GetDesktopDpi(&dpiX, &dpiY);
      return std::make_tuple(std::move(dpiX), std::move(dpiY));
    }

    D2::StrokeStyle Factory::createStrokeStyle(const D2D1_STROKE_STYLE_PROPERTIES& strokeStyleProperties)
    {
      ID2D1StrokeStyle* strokeStyle = nullptr;
      HRESULT hr = getRawInterface()->CreateStrokeStyle(&strokeStyleProperties, nullptr, 0, &strokeStyle);
      if(FAILED(hr)) throw COMException(hr, "ID2D1Factory::CreateStrokeStyle");
      return D2::StrokeStyle(strokeStyle);
    }

    D2::DrawingStateBlock Factory::createDrawingStateBlock()
    {
      ID2D1DrawingStateBlock* drawingStateBlock = nullptr;
      HRESULT hr = getRawInterface()->CreateDrawingStateBlock(nullptr, nullptr, &drawingStateBlock);
      if(FAILED(hr)) throw COMException(hr, "ID2D1Factory::CreateDrawingStateBlock");
      return D2::DrawingStateBlock(drawingStateBlock);
    }

    D2::DrawingStateBlock Factory::createDrawingStateBlock(const D2D1_DRAWING_STATE_DESCRIPTION& drawingStateDescription)
    {
      ID2D1DrawingStateBlock* drawingStateBlock = nullptr;
      HRESULT hr = getRawInterface()->CreateDrawingStateBlock(&drawingStateDescription, nullptr, &drawingStateBlock);
      if(FAILED(hr)) throw COMException(hr, "ID2D1Factory::CreateDrawingStateBlock");
      return D2::DrawingStateBlock(drawingStateBlock);
    }

    D2::DrawingStateBlock Factory::createDrawingStateBlock(const D2D1_DRAWING_STATE_DESCRIPTION& drawingStateDescription, DW::RenderingParams& textRenderingParams)
    {
      ID2D1DrawingStateBlock* drawingStateBlock = nullptr;
      HRESULT hr = getRawInterface()->CreateDrawingStateBlock(&drawingStateDescription, textRenderingParams.getRawInterface(), &drawingStateBlock);
      if(FAILED(hr)) throw COMException(hr, "ID2D1Factory::CreateDrawingStateBlock");
      return D2::DrawingStateBlock(drawingStateBlock);
    }

    D2::RenderTarget Factory::createDxgiSurfaceRenderTarget(DXGI::Surface& dxgiSurface, const D2D1_RENDER_TARGET_PROPERTIES& renderTargetProperties)
    {
      ID2D1RenderTarget* renderTarget = nullptr;
      HRESULT hr = getRawInterface()->CreateDxgiSurfaceRenderTarget(dxgiSurface.getRawInterface(), &renderTargetProperties, &renderTarget);
      if(FAILED(hr)) throw COMException(hr, "ID2D1Factory::CreateDxgiSurfaceRenderTarget");
      return D2::RenderTarget(renderTarget);
    }

    D2::EllipseGeometry Factory::createEllipseGeometry(const D2D1_ELLIPSE& ellipse)
    {
      ID2D1EllipseGeometry* ellipseGeometry = nullptr;
      HRESULT hr = getRawInterface()->CreateEllipseGeometry(&ellipse, &ellipseGeometry);
      if(FAILED(hr)) throw COMException(hr, "ID2D1Factory::CreateEllipseGeometry");
      return D2::EllipseGeometry(ellipseGeometry);
    }

    D2::RectangleGeometry Factory::createRectangleGeometry(const D2D1_RECT_F& rectangle)
    {
      ID2D1RectangleGeometry* rectangleGeometry = nullptr;
      HRESULT hr = getRawInterface()->CreateRectangleGeometry(&rectangle, &rectangleGeometry);
      if(FAILED(hr)) throw COMException(hr, "ID2D1Factory::CreateRectangleGeometry");
      return D2::RectangleGeometry(rectangleGeometry);
    }

    void Factory::reloadSystemMetrics()
    {
      HRESULT hr = getRawInterface()->ReloadSystemMetrics();
      if(FAILED(hr)) throw COMException(hr, "ID2D1Factory::ReloadSystemMetrics");
    }

    D2::DCRenderTarget Factory::createDCRenderTarget(const D2D1_RENDER_TARGET_PROPERTIES& renderTargetProperties)
    {
      ID2D1DCRenderTarget* dcRenderTarget = nullptr;
      HRESULT hr = getRawInterface()->CreateDCRenderTarget(&renderTargetProperties, &dcRenderTarget);
      if(FAILED(hr)) throw COMException(hr, "ID2D1Factory::CreateDCRenderTarget");
      return D2::DCRenderTarget(dcRenderTarget);
    }

    D2::HwndRenderTarget Factory::createHwndRenderTarget(const D2D1_RENDER_TARGET_PROPERTIES& renderTargetProperties, const D2D1_HWND_RENDER_TARGET_PROPERTIES& hwndRenderTargetProperties)
    {
      ID2D1HwndRenderTarget* hwndRenderTarget = nullptr;
      HRESULT hr = getRawInterface()->CreateHwndRenderTarget(&renderTargetProperties, &hwndRenderTargetProperties, &hwndRenderTarget);
      if(FAILED(hr)) throw COMException(hr, "ID2D1Factory::CreateHwndRenderTarget");
      return D2::HwndRenderTarget(hwndRenderTarget);
    }

    D2::RenderTarget Factory::createWicBitmapRenderTarget(WIC::Bitmap& target, const D2D1_RENDER_TARGET_PROPERTIES& renderTargetProperties)
    {
      ID2D1RenderTarget* renderTarget = nullptr;
      HRESULT hr = getRawInterface()->CreateWicBitmapRenderTarget(target.getRawInterface(), &renderTargetProperties, &renderTarget);
      if(FAILED(hr)) throw COMException(hr, "ID2D1Factory::CreateWicBitmapRenderTarget");
      return D2::RenderTarget(renderTarget);
    }

    D2::TransformedGeometry Factory::createTransformedGeometry(D2::Geometry& sourceGeometry, const D2D1_MATRIX_3X2_F& transform)
    {
      ID2D1TransformedGeometry* transformedGeometry = nullptr;
      HRESULT hr = getRawInterface()->CreateTransformedGeometry(sourceGeometry.getRawInterface(), &transform, &transformedGeometry);
      if(FAILED(hr)) throw COMException(hr, "ID2D1Factory::CreateTransformedGeometry");
      return D2::TransformedGeometry(transformedGeometry);
    }

    void TessellationSink::close()
    {
      HRESULT hr = getRawInterface()->Close();
      if(FAILED(hr)) throw COMException(hr, "ID2D1TessellationSink::Close");
    }

    D2::Factory Resource::getFactory() const
    {
      ID2D1Factory* factory = nullptr;
      getRawInterface()->GetFactory(&factory);
      return D2::Factory(factory);
    }

    D2::LinearGradientBrush RenderTarget::createLinearGradientBrush(const D2D1_LINEAR_GRADIENT_BRUSH_PROPERTIES& linearGradientBrushProperties, D2::GradientStopCollection& gradientStopCollection)
    {
      ID2D1LinearGradientBrush* linearGradientBrush = nullptr;
      HRESULT hr = getRawInterface()->CreateLinearGradientBrush(&linearGradientBrushProperties, nullptr, gradientStopCollection.getRawInterface(), &linearGradientBrush);
      if(FAILED(hr)) throw COMException(hr, "ID2D1RenderTarget::CreateLinearGradientBrush");
      return D2::LinearGradientBrush(linearGradientBrush);
    }

    D2::LinearGradientBrush RenderTarget::createLinearGradientBrush(const D2D1_LINEAR_GRADIENT_BRUSH_PROPERTIES& linearGradientBrushProperties, const D2D1_BRUSH_PROPERTIES& brushProperties, D2::GradientStopCollection& gradientStopCollection)
    {
      ID2D1LinearGradientBrush* linearGradientBrush = nullptr;
      HRESULT hr = getRawInterface()->CreateLinearGradientBrush(&linearGradientBrushProperties, &brushProperties, gradientStopCollection.getRawInterface(), &linearGradientBrush);
      if(FAILED(hr)) throw COMException(hr, "ID2D1RenderTarget::CreateLinearGradientBrush");
      return D2::LinearGradientBrush(linearGradientBrush);
    }

    void RenderTarget::setTransform(const D2D1_MATRIX_3X2_F& transform)
    {
      getRawInterface()->SetTransform(&transform);
    }

    void RenderTarget::setTags(D2D1_TAG tag1, D2D1_TAG tag2)
    {
      getRawInterface()->SetTags(tag1, tag2);
    }

    void RenderTarget::drawTextLayout(D2D1_POINT_2F origin, DW::TextLayout& textLayout, D2::Brush& defaultForegroundBrush)
    {
      getRawInterface()->DrawTextLayout(origin, textLayout.getRawInterface(), defaultForegroundBrush.getRawInterface(), D2D1_DRAW_TEXT_OPTIONS_NONE);
    }

    void RenderTarget::drawTextLayout(D2D1_POINT_2F origin, DW::TextLayout& textLayout, D2::Brush& defaultForegroundBrush, D2D1_DRAW_TEXT_OPTIONS options)
    {
      getRawInterface()->DrawTextLayout(origin, textLayout.getRawInterface(), defaultForegroundBrush.getRawInterface(), options);
    }

    uint32_t RenderTarget::getMaximumBitmapSize() const
    {
      return getRawInterface()->GetMaximumBitmapSize();
    }

    D2::Mesh RenderTarget::createMesh()
    {
      ID2D1Mesh* mesh = nullptr;
      HRESULT hr = getRawInterface()->CreateMesh(&mesh);
      if(FAILED(hr)) throw COMException(hr, "ID2D1RenderTarget::CreateMesh");
      return D2::Mesh(mesh);
    }

    void RenderTarget::fillRoundedRectangle(const D2D1_ROUNDED_RECT& roundedRect, D2::Brush& brush)
    {
      getRawInterface()->FillRoundedRectangle(&roundedRect, brush.getRawInterface());
    }

    void RenderTarget::pushLayer(const D2D1_LAYER_PARAMETERS& layerParameters, D2::Layer& layer)
    {
      getRawInterface()->PushLayer(&layerParameters, layer.getRawInterface());
    }

    DW::RenderingParams RenderTarget::getTextRenderingParams() const
    {
      IDWriteRenderingParams* textRenderingParams = nullptr;
      getRawInterface()->GetTextRenderingParams(&textRenderingParams);
      return DW::RenderingParams(textRenderingParams);
    }

    void RenderTarget::drawGeometry(D2::Geometry& geometry, D2::Brush& brush)
    {
      getRawInterface()->DrawGeometry(geometry.getRawInterface(), brush.getRawInterface(), 1.0f, nullptr);
    }

    void RenderTarget::drawGeometry(D2::Geometry& geometry, D2::Brush& brush, float strokeWidth)
    {
      getRawInterface()->DrawGeometry(geometry.getRawInterface(), brush.getRawInterface(), strokeWidth, nullptr);
    }

    void RenderTarget::drawGeometry(D2::Geometry& geometry, D2::Brush& brush, float strokeWidth, D2::StrokeStyle& strokeStyle)
    {
      getRawInterface()->DrawGeometry(geometry.getRawInterface(), brush.getRawInterface(), strokeWidth, strokeStyle.getRawInterface());
    }

    std::tuple<D2D1_TAG, D2D1_TAG> RenderTarget::getTags() const
    {
      D2D1_TAG tag1 = D2D1_TAG();
      D2D1_TAG tag2 = D2D1_TAG();
      getRawInterface()->GetTags(&tag1, &tag2);
      return std::make_tuple(std::move(tag1), std::move(tag2));
    }

    std::tuple<float, float> RenderTarget::getDpi() const
    {
      float dpiX = float();
      float dpiY = float();
      getRawInterface()->GetDpi(&dpiX, &dpiY);
      return std::make_tuple(std::move(dpiX), std::move(dpiY));
    }

    void RenderTarget::drawLine(D2D1_POINT_2F point0, D2D1_POINT_2F point1, D2::Brush& brush)
    {
      getRawInterface()->DrawLine(point0, point1, brush.getRawInterface(), 1.0f, nullptr);
    }

    void RenderTarget::drawLine(D2D1_POINT_2F point0, D2D1_POINT_2F point1, D2::Brush& brush, float strokeWidth)
    {
      getRawInterface()->DrawLine(point0, point1, brush.getRawInterface(), strokeWidth, nullptr);
    }

    void RenderTarget::drawLine(D2D1_POINT_2F point0, D2D1_POINT_2F point1, D2::Brush& brush, float strokeWidth, D2::StrokeStyle& strokeStyle)
    {
      getRawInterface()->DrawLine(point0, point1, brush.getRawInterface(), strokeWidth, strokeStyle.getRawInterface());
    }

    std::tuple<D2D1_TAG, D2D1_TAG> RenderTarget::flush()
    {
      D2D1_TAG tag1 = D2D1_TAG();
      D2D1_TAG tag2 = D2D1_TAG();
      HRESULT hr = getRawInterface()->Flush(&tag1, &tag2);
      if(FAILED(hr)) throw COMException(hr, "ID2D1RenderTarget::Flush");
      return std::make_tuple(std::move(tag1), std::move(tag2));
    }

    D2::Layer RenderTarget::createLayer()
    {
      ID2D1Layer* layer = nullptr;
      HRESULT hr = getRawInterface()->CreateLayer(nullptr, &layer);
      if(FAILED(hr)) throw COMException(hr, "ID2D1RenderTarget::CreateLayer");
      return D2::Layer(layer);
    }

    D2::Layer RenderTarget::createLayer(const D2D1_SIZE_F& size)
    {
      ID2D1Layer* layer = nullptr;
      HRESULT hr = getRawInterface()->CreateLayer(&size, &layer);
      if(FAILED(hr)) throw COMException(hr, "ID2D1RenderTarget::CreateLayer");
      return D2::Layer(layer);
    }

    void RenderTarget::fillEllipse(const D2D1_ELLIPSE& ellipse, D2::Brush& brush)
    {
      getRawInterface()->FillEllipse(&ellipse, brush.getRawInterface());
    }

    void RenderTarget::drawRectangle(const D2D1_RECT_F& rect, D2::Brush& brush)
    {
      getRawInterface()->DrawRectangle(&rect, brush.getRawInterface(), 1.0f, nullptr);
    }

    void RenderTarget::drawRectangle(const D2D1_RECT_F& rect, D2::Brush& brush, float strokeWidth)
    {
      getRawInterface()->DrawRectangle(&rect, brush.getRawInterface(), strokeWidth, nullptr);
    }

    void RenderTarget::drawRectangle(const D2D1_RECT_F& rect, D2::Brush& brush, float strokeWidth, D2::StrokeStyle& strokeStyle)
    {
      getRawInterface()->DrawRectangle(&rect, brush.getRawInterface(), strokeWidth, strokeStyle.getRawInterface());
    }

    void RenderTarget::clear()
    {
      getRawInterface()->Clear(nullptr);
    }

    void RenderTarget::clear(const D2D1_COLOR_F& clearColor)
    {
      getRawInterface()->Clear(&clearColor);
    }

    D2::RadialGradientBrush RenderTarget::createRadialGradientBrush(const D2D1_RADIAL_GRADIENT_BRUSH_PROPERTIES& radialGradientBrushProperties, D2::GradientStopCollection& gradientStopCollection)
    {
      ID2D1RadialGradientBrush* radialGradientBrush = nullptr;
      HRESULT hr = getRawInterface()->CreateRadialGradientBrush(&radialGradientBrushProperties, nullptr, gradientStopCollection.getRawInterface(), &radialGradientBrush);
      if(FAILED(hr)) throw COMException(hr, "ID2D1RenderTarget::CreateRadialGradientBrush");
      return D2::RadialGradientBrush(radialGradientBrush);
    }

    D2::RadialGradientBrush RenderTarget::createRadialGradientBrush(const D2D1_RADIAL_GRADIENT_BRUSH_PROPERTIES& radialGradientBrushProperties, const D2D1_BRUSH_PROPERTIES& brushProperties, D2::GradientStopCollection& gradientStopCollection)
    {
      ID2D1RadialGradientBrush* radialGradientBrush = nullptr;
      HRESULT hr = getRawInterface()->CreateRadialGradientBrush(&radialGradientBrushProperties, &brushProperties, gradientStopCollection.getRawInterface(), &radialGradientBrush);
      if(FAILED(hr)) throw COMException(hr, "ID2D1RenderTarget::CreateRadialGradientBrush");
      return D2::RadialGradientBrush(radialGradientBrush);
    }

    void RenderTarget::fillRectangle(const D2D1_RECT_F& rect, D2::Brush& brush)
    {
      getRawInterface()->FillRectangle(&rect, brush.getRawInterface());
    }

    D2D1_SIZE_F RenderTarget::getSize() const
    {
      return getRawInterface()->GetSize();
    }

    D2::Bitmap RenderTarget::createBitmapFromWicBitmap(WIC::BitmapSource& wicBitmapSource)
    {
      ID2D1Bitmap* bitmap = nullptr;
      HRESULT hr = getRawInterface()->CreateBitmapFromWicBitmap(wicBitmapSource.getRawInterface(), nullptr, &bitmap);
      if(FAILED(hr)) throw COMException(hr, "ID2D1RenderTarget::CreateBitmapFromWicBitmap");
      return D2::Bitmap(bitmap);
    }

    D2::Bitmap RenderTarget::createBitmapFromWicBitmap(WIC::BitmapSource& wicBitmapSource, const D2D1_BITMAP_PROPERTIES& bitmapProperties)
    {
      ID2D1Bitmap* bitmap = nullptr;
      HRESULT hr = getRawInterface()->CreateBitmapFromWicBitmap(wicBitmapSource.getRawInterface(), &bitmapProperties, &bitmap);
      if(FAILED(hr)) throw COMException(hr, "ID2D1RenderTarget::CreateBitmapFromWicBitmap");
      return D2::Bitmap(bitmap);
    }

    void RenderTarget::drawGlyphRun(D2D1_POINT_2F baselineOrigin, const DWRITE_GLYPH_RUN& glyphRun, D2::Brush& foregroundBrush)
    {
      getRawInterface()->DrawGlyphRun(baselineOrigin, &glyphRun, foregroundBrush.getRawInterface(), DWRITE_MEASURING_MODE_NATURAL);
    }

    void RenderTarget::drawGlyphRun(D2D1_POINT_2F baselineOrigin, const DWRITE_GLYPH_RUN& glyphRun, D2::Brush& foregroundBrush, DWRITE_MEASURING_MODE measuringMode)
    {
      getRawInterface()->DrawGlyphRun(baselineOrigin, &glyphRun, foregroundBrush.getRawInterface(), measuringMode);
    }

    void RenderTarget::setDpi(float dpiX, float dpiY)
    {
      getRawInterface()->SetDpi(dpiX, dpiY);
    }

    D2D1_PIXEL_FORMAT RenderTarget::getPixelFormat() const
    {
      return getRawInterface()->GetPixelFormat();
    }

    std::tuple<D2D1_TAG, D2D1_TAG> RenderTarget::endDraw()
    {
      D2D1_TAG tag1 = D2D1_TAG();
      D2D1_TAG tag2 = D2D1_TAG();
      HRESULT hr = getRawInterface()->EndDraw(&tag1, &tag2);
      if(FAILED(hr)) throw COMException(hr, "ID2D1RenderTarget::EndDraw");
      return std::make_tuple(std::move(tag1), std::move(tag2));
    }

    void RenderTarget::setAntialiasMode(D2D1_ANTIALIAS_MODE antialiasMode)
    {
      getRawInterface()->SetAntialiasMode(antialiasMode);
    }

    D2::SolidColorBrush RenderTarget::createSolidColorBrush(const D2D1_COLOR_F& color)
    {
      ID2D1SolidColorBrush* solidColorBrush = nullptr;
      HRESULT hr = getRawInterface()->CreateSolidColorBrush(&color, nullptr, &solidColorBrush);
      if(FAILED(hr)) throw COMException(hr, "ID2D1RenderTarget::CreateSolidColorBrush");
      return D2::SolidColorBrush(solidColorBrush);
    }

    D2::SolidColorBrush RenderTarget::createSolidColorBrush(const D2D1_COLOR_F& color, const D2D1_BRUSH_PROPERTIES& brushProperties)
    {
      ID2D1SolidColorBrush* solidColorBrush = nullptr;
      HRESULT hr = getRawInterface()->CreateSolidColorBrush(&color, &brushProperties, &solidColorBrush);
      if(FAILED(hr)) throw COMException(hr, "ID2D1RenderTarget::CreateSolidColorBrush");
      return D2::SolidColorBrush(solidColorBrush);
    }

    void RenderTarget::beginDraw()
    {
      getRawInterface()->BeginDraw();
    }

    void RenderTarget::popAxisAlignedClip()
    {
      getRawInterface()->PopAxisAlignedClip();
    }

    void RenderTarget::drawBitmap(D2::Bitmap& bitmap)
    {
      getRawInterface()->DrawBitmap(bitmap.getRawInterface(), nullptr, 1.0f, D2D1_BITMAP_INTERPOLATION_MODE_LINEAR, nullptr);
    }

    void RenderTarget::drawBitmap(D2::Bitmap& bitmap, const D2D1_RECT_F& destinationRectangle)
    {
      getRawInterface()->DrawBitmap(bitmap.getRawInterface(), &destinationRectangle, 1.0f, D2D1_BITMAP_INTERPOLATION_MODE_LINEAR, nullptr);
    }

    void RenderTarget::drawBitmap(D2::Bitmap& bitmap, const D2D1_RECT_F& destinationRectangle, float opacity)
    {
      getRawInterface()->DrawBitmap(bitmap.getRawInterface(), &destinationRectangle, opacity, D2D1_BITMAP_INTERPOLATION_MODE_LINEAR, nullptr);
    }

    void RenderTarget::drawBitmap(D2::Bitmap& bitmap, const D2D1_RECT_F& destinationRectangle, float opacity, D2D1_BITMAP_INTERPOLATION_MODE interpolationMode)
    {
      getRawInterface()->DrawBitmap(bitmap.getRawInterface(), &destinationRectangle, opacity, interpolationMode, nullptr);
    }

    void RenderTarget::drawBitmap(D2::Bitmap& bitmap, const D2D1_RECT_F& destinationRectangle, float opacity, D2D1_BITMAP_INTERPOLATION_MODE interpolationMode, const D2D1_RECT_F& sourceRectangle)
    {
      getRawInterface()->DrawBitmap(bitmap.getRawInterface(), &destinationRectangle, opacity, interpolationMode, &sourceRectangle);
    }

    BOOL RenderTarget::isSupported(const D2D1_RENDER_TARGET_PROPERTIES& renderTargetProperties) const
    {
      return getRawInterface()->IsSupported(&renderTargetProperties);
    }

    void RenderTarget::pushAxisAlignedClip(const D2D1_RECT_F& clipRect, D2D1_ANTIALIAS_MODE antialiasMode)
    {
      getRawInterface()->PushAxisAlignedClip(&clipRect, antialiasMode);
    }

    void RenderTarget::fillMesh(D2::Mesh& mesh, D2::Brush& brush)
    {
      getRawInterface()->FillMesh(mesh.getRawInterface(), brush.getRawInterface());
    }

    void RenderTarget::restoreDrawingState(D2::DrawingStateBlock& drawingStateBlock)
    {
      getRawInterface()->RestoreDrawingState(drawingStateBlock.getRawInterface());
    }

    void RenderTarget::fillOpacityMask(D2::Bitmap& opacityMask, D2::Brush& brush, D2D1_OPACITY_MASK_CONTENT content)
    {
      getRawInterface()->FillOpacityMask(opacityMask.getRawInterface(), brush.getRawInterface(), content, nullptr, nullptr);
    }

    void RenderTarget::fillOpacityMask(D2::Bitmap& opacityMask, D2::Brush& brush, D2D1_OPACITY_MASK_CONTENT content, const D2D1_RECT_F& destinationRectangle)
    {
      getRawInterface()->FillOpacityMask(opacityMask.getRawInterface(), brush.getRawInterface(), content, &destinationRectangle, nullptr);
    }

    void RenderTarget::fillOpacityMask(D2::Bitmap& opacityMask, D2::Brush& brush, D2D1_OPACITY_MASK_CONTENT content, const D2D1_RECT_F& destinationRectangle, const D2D1_RECT_F& sourceRectangle)
    {
      getRawInterface()->FillOpacityMask(opacityMask.getRawInterface(), brush.getRawInterface(), content, &destinationRectangle, &sourceRectangle);
    }

    void RenderTarget::popLayer()
    {
      getRawInterface()->PopLayer();
    }

    void RenderTarget::setTextRenderingParams()
    {
      getRawInterface()->SetTextRenderingParams(nullptr);
    }

    void RenderTarget::setTextRenderingParams(DW::RenderingParams& textRenderingParams)
    {
      getRawInterface()->SetTextRenderingParams(textRenderingParams.getRawInterface());
    }

    D2D1_ANTIALIAS_MODE RenderTarget::getAntialiasMode() const
    {
      return getRawInterface()->GetAntialiasMode();
    }

    D2D1_TEXT_ANTIALIAS_MODE RenderTarget::getTextAntialiasMode() const
    {
      return getRawInterface()->GetTextAntialiasMode();
    }

    void RenderTarget::setTextAntialiasMode(D2D1_TEXT_ANTIALIAS_MODE textAntialiasMode)
    {
      getRawInterface()->SetTextAntialiasMode(textAntialiasMode);
    }

    D2::BitmapRenderTarget RenderTarget::createCompatibleRenderTarget(D2D1_COMPATIBLE_RENDER_TARGET_OPTIONS options)
    {
      ID2D1BitmapRenderTarget* bitmapRenderTarget = nullptr;
      HRESULT hr = getRawInterface()->CreateCompatibleRenderTarget(nullptr, nullptr, nullptr, options, &bitmapRenderTarget);
      if(FAILED(hr)) throw COMException(hr, "ID2D1RenderTarget::CreateCompatibleRenderTarget");
      return D2::BitmapRenderTarget(bitmapRenderTarget);
    }

    D2::BitmapRenderTarget RenderTarget::createCompatibleRenderTarget(const D2D1_SIZE_F& desiredSize, D2D1_COMPATIBLE_RENDER_TARGET_OPTIONS options)
    {
      ID2D1BitmapRenderTarget* bitmapRenderTarget = nullptr;
      HRESULT hr = getRawInterface()->CreateCompatibleRenderTarget(&desiredSize, nullptr, nullptr, options, &bitmapRenderTarget);
      if(FAILED(hr)) throw COMException(hr, "ID2D1RenderTarget::CreateCompatibleRenderTarget");
      return D2::BitmapRenderTarget(bitmapRenderTarget);
    }

    D2::BitmapRenderTarget RenderTarget::createCompatibleRenderTarget(const D2D1_SIZE_F& desiredSize, const D2D1_SIZE_U& desiredPixelSize, D2D1_COMPATIBLE_RENDER_TARGET_OPTIONS options)
    {
      ID2D1BitmapRenderTarget* bitmapRenderTarget = nullptr;
      HRESULT hr = getRawInterface()->CreateCompatibleRenderTarget(&desiredSize, &desiredPixelSize, nullptr, options, &bitmapRenderTarget);
      if(FAILED(hr)) throw COMException(hr, "ID2D1RenderTarget::CreateCompatibleRenderTarget");
      return D2::BitmapRenderTarget(bitmapRenderTarget);
    }

    D2::BitmapRenderTarget RenderTarget::createCompatibleRenderTarget(const D2D1_SIZE_F& desiredSize, const D2D1_SIZE_U& desiredPixelSize, const D2D1_PIXEL_FORMAT& desiredFormat, D2D1_COMPATIBLE_RENDER_TARGET_OPTIONS options)
    {
      ID2D1BitmapRenderTarget* bitmapRenderTarget = nullptr;
      HRESULT hr = getRawInterface()->CreateCompatibleRenderTarget(&desiredSize, &desiredPixelSize, &desiredFormat, options, &bitmapRenderTarget);
      if(FAILED(hr)) throw COMException(hr, "ID2D1RenderTarget::CreateCompatibleRenderTarget");
      return D2::BitmapRenderTarget(bitmapRenderTarget);
    }

    void RenderTarget::saveDrawingState(D2::DrawingStateBlock& drawingStateBlock) const
    {
      getRawInterface()->SaveDrawingState(drawingStateBlock.getRawInterface());
    }

    void RenderTarget::fillGeometry(D2::Geometry& geometry, D2::Brush& brush)
    {
      getRawInterface()->FillGeometry(geometry.getRawInterface(), brush.getRawInterface(), nullptr);
    }

    void RenderTarget::fillGeometry(D2::Geometry& geometry, D2::Brush& brush, D2::Brush& opacityBrush)
    {
      getRawInterface()->FillGeometry(geometry.getRawInterface(), brush.getRawInterface(), opacityBrush.getRawInterface());
    }

    D2::Bitmap RenderTarget::createBitmap(D2D1_SIZE_U size, uint32_t pitch, const D2D1_BITMAP_PROPERTIES& bitmapProperties)
    {
      ID2D1Bitmap* bitmap = nullptr;
      HRESULT hr = getRawInterface()->CreateBitmap(size, nullptr, pitch, &bitmapProperties, &bitmap);
      if(FAILED(hr)) throw COMException(hr, "ID2D1RenderTarget::CreateBitmap");
      return D2::Bitmap(bitmap);
    }

    D2::Bitmap RenderTarget::createBitmap(D2D1_SIZE_U size, const void* srcData, uint32_t pitch, const D2D1_BITMAP_PROPERTIES& bitmapProperties)
    {
      ID2D1Bitmap* bitmap = nullptr;
      HRESULT hr = getRawInterface()->CreateBitmap(size, srcData, pitch, &bitmapProperties, &bitmap);
      if(FAILED(hr)) throw COMException(hr, "ID2D1RenderTarget::CreateBitmap");
      return D2::Bitmap(bitmap);
    }

    void RenderTarget::drawRoundedRectangle(const D2D1_ROUNDED_RECT& roundedRect, D2::Brush& brush)
    {
      getRawInterface()->DrawRoundedRectangle(&roundedRect, brush.getRawInterface(), 1.0f, nullptr);
    }

    void RenderTarget::drawRoundedRectangle(const D2D1_ROUNDED_RECT& roundedRect, D2::Brush& brush, float strokeWidth)
    {
      getRawInterface()->DrawRoundedRectangle(&roundedRect, brush.getRawInterface(), strokeWidth, nullptr);
    }

    void RenderTarget::drawRoundedRectangle(const D2D1_ROUNDED_RECT& roundedRect, D2::Brush& brush, float strokeWidth, D2::StrokeStyle& strokeStyle)
    {
      getRawInterface()->DrawRoundedRectangle(&roundedRect, brush.getRawInterface(), strokeWidth, strokeStyle.getRawInterface());
    }

    D2D1_MATRIX_3X2_F RenderTarget::getTransform() const
    {
      D2D1_MATRIX_3X2_F transform = D2D1_MATRIX_3X2_F();
      getRawInterface()->GetTransform(&transform);
      return transform;
    }

    D2::BitmapBrush RenderTarget::createBitmapBrush(D2::Bitmap& bitmap)
    {
      ID2D1BitmapBrush* bitmapBrush = nullptr;
      HRESULT hr = getRawInterface()->CreateBitmapBrush(bitmap.getRawInterface(), nullptr, nullptr, &bitmapBrush);
      if(FAILED(hr)) throw COMException(hr, "ID2D1RenderTarget::CreateBitmapBrush");
      return D2::BitmapBrush(bitmapBrush);
    }

    D2::BitmapBrush RenderTarget::createBitmapBrush(D2::Bitmap& bitmap, const D2D1_BITMAP_BRUSH_PROPERTIES& bitmapBrushProperties)
    {
      ID2D1BitmapBrush* bitmapBrush = nullptr;
      HRESULT hr = getRawInterface()->CreateBitmapBrush(bitmap.getRawInterface(), &bitmapBrushProperties, nullptr, &bitmapBrush);
      if(FAILED(hr)) throw COMException(hr, "ID2D1RenderTarget::CreateBitmapBrush");
      return D2::BitmapBrush(bitmapBrush);
    }

    D2::BitmapBrush RenderTarget::createBitmapBrush(D2::Bitmap& bitmap, const D2D1_BITMAP_BRUSH_PROPERTIES& bitmapBrushProperties, const D2D1_BRUSH_PROPERTIES& brushProperties)
    {
      ID2D1BitmapBrush* bitmapBrush = nullptr;
      HRESULT hr = getRawInterface()->CreateBitmapBrush(bitmap.getRawInterface(), &bitmapBrushProperties, &brushProperties, &bitmapBrush);
      if(FAILED(hr)) throw COMException(hr, "ID2D1RenderTarget::CreateBitmapBrush");
      return D2::BitmapBrush(bitmapBrush);
    }

    void RenderTarget::drawEllipse(const D2D1_ELLIPSE& ellipse, D2::Brush& brush)
    {
      getRawInterface()->DrawEllipse(&ellipse, brush.getRawInterface(), 1.0f, nullptr);
    }

    void RenderTarget::drawEllipse(const D2D1_ELLIPSE& ellipse, D2::Brush& brush, float strokeWidth)
    {
      getRawInterface()->DrawEllipse(&ellipse, brush.getRawInterface(), strokeWidth, nullptr);
    }

    void RenderTarget::drawEllipse(const D2D1_ELLIPSE& ellipse, D2::Brush& brush, float strokeWidth, D2::StrokeStyle& strokeStyle)
    {
      getRawInterface()->DrawEllipse(&ellipse, brush.getRawInterface(), strokeWidth, strokeStyle.getRawInterface());
    }

    D2D1_SIZE_U RenderTarget::getPixelSize() const
    {
      return getRawInterface()->GetPixelSize();
    }

    void DCRenderTarget::bindDC(const HDC hDC, const RECT& pSubRect)
    {
      HRESULT hr = getRawInterface()->BindDC(hDC, &pSubRect);
      if(FAILED(hr)) throw COMException(hr, "ID2D1DCRenderTarget::BindDC");
    }

    HWND HwndRenderTarget::getHwnd() const
    {
      return getRawInterface()->GetHwnd();
    }

    void HwndRenderTarget::resize(const D2D1_SIZE_U& pixelSize)
    {
      HRESULT hr = getRawInterface()->Resize(&pixelSize);
      if(FAILED(hr)) throw COMException(hr, "ID2D1HwndRenderTarget::Resize");
    }

    D2D1_WINDOW_STATE HwndRenderTarget::checkWindowState()
    {
      return getRawInterface()->CheckWindowState();
    }

    D2::Bitmap BitmapRenderTarget::getBitmap()
    {
      ID2D1Bitmap* bitmap = nullptr;
      HRESULT hr = getRawInterface()->GetBitmap(&bitmap);
      if(FAILED(hr)) throw COMException(hr, "ID2D1BitmapRenderTarget::GetBitmap");
      return D2::Bitmap(bitmap);
    }

    D2D1_GAMMA GradientStopCollection::getColorInterpolationGamma() const
    {
      return getRawInterface()->GetColorInterpolationGamma();
    }

    D2D1_EXTEND_MODE GradientStopCollection::getExtendMode() const
    {
      return getRawInterface()->GetExtendMode();
    }

    uint32_t GradientStopCollection::getGradientStopCount() const
    {
      return getRawInterface()->GetGradientStopCount();
    }

    std::vector<D2D1_GRADIENT_STOP> GradientStopCollection::getGradientStops(unsigned int gradientStopsCount) const
    {
      std::vector<D2D1_GRADIENT_STOP> gradientStops(static_cast<size_t>(gradientStopsCount));
      getRawInterface()->GetGradientStops(gradientStops.data(), gradientStopsCount);
      return gradientStops;
    }

    D2D1_LINE_JOIN StrokeStyle::getLineJoin() const
    {
      return getRawInterface()->GetLineJoin();
    }

    float StrokeStyle::getDashOffset() const
    {
      return getRawInterface()->GetDashOffset();
    }

    D2D1_CAP_STYLE StrokeStyle::getDashCap() const
    {
      return getRawInterface()->GetDashCap();
    }

    uint32_t StrokeStyle::getDashesCount() const
    {
      return getRawInterface()->GetDashesCount();
    }

    float StrokeStyle::getMiterLimit() const
    {
      return getRawInterface()->GetMiterLimit();
    }

    D2D1_DASH_STYLE StrokeStyle::getDashStyle() const
    {
      return getRawInterface()->GetDashStyle();
    }

    std::vector<float> StrokeStyle::getDashes(unsigned int dashesCount) const
    {
      std::vector<float> dashes(static_cast<size_t>(dashesCount));
      getRawInterface()->GetDashes(dashes.data(), dashesCount);
      return dashes;
    }

    D2D1_CAP_STYLE StrokeStyle::getEndCap() const
    {
      return getRawInterface()->GetEndCap();
    }

    D2D1_CAP_STYLE StrokeStyle::getStartCap() const
    {
      return getRawInterface()->GetStartCap();
    }

    D2D1_MATRIX_3X2_F Brush::getTransform() const
    {
      D2D1_MATRIX_3X2_F transform = D2D1_MATRIX_3X2_F();
      getRawInterface()->GetTransform(&transform);
      return transform;
    }

    float Brush::getOpacity() const
    {
      return getRawInterface()->GetOpacity();
    }

    void Brush::setTransform(const D2D1_MATRIX_3X2_F& transform)
    {
      getRawInterface()->SetTransform(&transform);
    }

    void Brush::setOpacity(float opacity)
    {
      getRawInterface()->SetOpacity(opacity);
    }

    void RadialGradientBrush::setRadiusX(float radiusX)
    {
      getRawInterface()->SetRadiusX(radiusX);
    }

    D2D1_POINT_2F RadialGradientBrush::getGradientOriginOffset() const
    {
      return getRawInterface()->GetGradientOriginOffset();
    }

    float RadialGradientBrush::getRadiusY() const
    {
      return getRawInterface()->GetRadiusY();
    }

    D2::GradientStopCollection RadialGradientBrush::getGradientStopCollection() const
    {
      ID2D1GradientStopCollection* gradientStopCollection = nullptr;
      getRawInterface()->GetGradientStopCollection(&gradientStopCollection);
      return D2::GradientStopCollection(gradientStopCollection);
    }

    void RadialGradientBrush::setRadiusY(float radiusY)
    {
      getRawInterface()->SetRadiusY(radiusY);
    }

    void RadialGradientBrush::setCenter(D2D1_POINT_2F center)
    {
      getRawInterface()->SetCenter(center);
    }

    float RadialGradientBrush::getRadiusX() const
    {
      return getRawInterface()->GetRadiusX();
    }

    D2D1_POINT_2F RadialGradientBrush::getCenter() const
    {
      return getRawInterface()->GetCenter();
    }

    void RadialGradientBrush::setGradientOriginOffset(D2D1_POINT_2F gradientOriginOffset)
    {
      getRawInterface()->SetGradientOriginOffset(gradientOriginOffset);
    }

    D2D1_COLOR_F SolidColorBrush::getColor() const
    {
      return getRawInterface()->GetColor();
    }

    void SolidColorBrush::setColor(const D2D1_COLOR_F& color)
    {
      getRawInterface()->SetColor(&color);
    }

    D2D1_EXTEND_MODE BitmapBrush::getExtendModeY() const
    {
      return getRawInterface()->GetExtendModeY();
    }

    D2D1_BITMAP_INTERPOLATION_MODE BitmapBrush::getInterpolationMode() const
    {
      return getRawInterface()->GetInterpolationMode();
    }

    D2::Bitmap BitmapBrush::getBitmap() const
    {
      ID2D1Bitmap* bitmap = nullptr;
      getRawInterface()->GetBitmap(&bitmap);
      return D2::Bitmap(bitmap);
    }

    D2D1_EXTEND_MODE BitmapBrush::getExtendModeX() const
    {
      return getRawInterface()->GetExtendModeX();
    }

    void BitmapBrush::setBitmap(D2::Bitmap& bitmap)
    {
      getRawInterface()->SetBitmap(bitmap.getRawInterface());
    }

    void BitmapBrush::setInterpolationMode(D2D1_BITMAP_INTERPOLATION_MODE interpolationMode)
    {
      getRawInterface()->SetInterpolationMode(interpolationMode);
    }

    void BitmapBrush::setExtendModeY(D2D1_EXTEND_MODE extendModeY)
    {
      getRawInterface()->SetExtendModeY(extendModeY);
    }

    void BitmapBrush::setExtendModeX(D2D1_EXTEND_MODE extendModeX)
    {
      getRawInterface()->SetExtendModeX(extendModeX);
    }

    D2D1_POINT_2F LinearGradientBrush::getStartPoint() const
    {
      return getRawInterface()->GetStartPoint();
    }

    D2D1_POINT_2F LinearGradientBrush::getEndPoint() const
    {
      return getRawInterface()->GetEndPoint();
    }

    void LinearGradientBrush::setStartPoint(D2D1_POINT_2F startPoint)
    {
      getRawInterface()->SetStartPoint(startPoint);
    }

    D2::GradientStopCollection LinearGradientBrush::getGradientStopCollection() const
    {
      ID2D1GradientStopCollection* gradientStopCollection = nullptr;
      getRawInterface()->GetGradientStopCollection(&gradientStopCollection);
      return D2::GradientStopCollection(gradientStopCollection);
    }

    void LinearGradientBrush::setEndPoint(D2D1_POINT_2F endPoint)
    {
      getRawInterface()->SetEndPoint(endPoint);
    }

    DW::RenderingParams DrawingStateBlock::getTextRenderingParams() const
    {
      IDWriteRenderingParams* textRenderingParams = nullptr;
      getRawInterface()->GetTextRenderingParams(&textRenderingParams);
      return DW::RenderingParams(textRenderingParams);
    }

    void DrawingStateBlock::setDescription(const D2D1_DRAWING_STATE_DESCRIPTION& stateDescription)
    {
      getRawInterface()->SetDescription(&stateDescription);
    }

    void DrawingStateBlock::setTextRenderingParams()
    {
      getRawInterface()->SetTextRenderingParams(nullptr);
    }

    void DrawingStateBlock::setTextRenderingParams(DW::RenderingParams& textRenderingParams)
    {
      getRawInterface()->SetTextRenderingParams(textRenderingParams.getRawInterface());
    }

    D2D1_DRAWING_STATE_DESCRIPTION DrawingStateBlock::getDescription() const
    {
      D2D1_DRAWING_STATE_DESCRIPTION stateDescription = D2D1_DRAWING_STATE_DESCRIPTION();
      getRawInterface()->GetDescription(&stateDescription);
      return stateDescription;
    }

    D2::TessellationSink Mesh::open()
    {
      ID2D1TessellationSink* tessellationSink = nullptr;
      HRESULT hr = getRawInterface()->Open(&tessellationSink);
      if(FAILED(hr)) throw COMException(hr, "ID2D1Mesh::Open");
      return D2::TessellationSink(tessellationSink);
    }

    D2D1_SIZE_F Layer::getSize() const
    {
      return getRawInterface()->GetSize();
    }

    D2D1_SIZE_F Bitmap::getSize() const
    {
      return getRawInterface()->GetSize();
    }

    std::tuple<float, float> Bitmap::getDpi() const
    {
      float dpiX = float();
      float dpiY = float();
      getRawInterface()->GetDpi(&dpiX, &dpiY);
      return std::make_tuple(std::move(dpiX), std::move(dpiY));
    }

    void Bitmap::copyFromBitmap(D2::Bitmap& bitmap)
    {
      HRESULT hr = getRawInterface()->CopyFromBitmap(nullptr, bitmap.getRawInterface(), nullptr);
      if(FAILED(hr)) throw COMException(hr, "ID2D1Bitmap::CopyFromBitmap");
    }

    void Bitmap::copyFromBitmap(const D2D1_POINT_2U& destPoint, D2::Bitmap& bitmap)
    {
      HRESULT hr = getRawInterface()->CopyFromBitmap(&destPoint, bitmap.getRawInterface(), nullptr);
      if(FAILED(hr)) throw COMException(hr, "ID2D1Bitmap::CopyFromBitmap");
    }

    void Bitmap::copyFromBitmap(const D2D1_POINT_2U& destPoint, D2::Bitmap& bitmap, const D2D1_RECT_U& srcRect)
    {
      HRESULT hr = getRawInterface()->CopyFromBitmap(&destPoint, bitmap.getRawInterface(), &srcRect);
      if(FAILED(hr)) throw COMException(hr, "ID2D1Bitmap::CopyFromBitmap");
    }

    void Bitmap::copyFromMemory(const void* srcData, uint32_t pitch)
    {
      HRESULT hr = getRawInterface()->CopyFromMemory(nullptr, srcData, pitch);
      if(FAILED(hr)) throw COMException(hr, "ID2D1Bitmap::CopyFromMemory");
    }

    void Bitmap::copyFromMemory(const D2D1_RECT_U& dstRect, const void* srcData, uint32_t pitch)
    {
      HRESULT hr = getRawInterface()->CopyFromMemory(&dstRect, srcData, pitch);
      if(FAILED(hr)) throw COMException(hr, "ID2D1Bitmap::CopyFromMemory");
    }

    D2D1_PIXEL_FORMAT Bitmap::getPixelFormat() const
    {
      return getRawInterface()->GetPixelFormat();
    }

    void Bitmap::copyFromRenderTarget(D2::RenderTarget& renderTarget)
    {
      HRESULT hr = getRawInterface()->CopyFromRenderTarget(nullptr, renderTarget.getRawInterface(), nullptr);
      if(FAILED(hr)) throw COMException(hr, "ID2D1Bitmap::CopyFromRenderTarget");
    }

    void Bitmap::copyFromRenderTarget(const D2D1_POINT_2U& destPoint, D2::RenderTarget& renderTarget)
    {
      HRESULT hr = getRawInterface()->CopyFromRenderTarget(&destPoint, renderTarget.getRawInterface(), nullptr);
      if(FAILED(hr)) throw COMException(hr, "ID2D1Bitmap::CopyFromRenderTarget");
    }

    void Bitmap::copyFromRenderTarget(const D2D1_POINT_2U& destPoint, D2::RenderTarget& renderTarget, const D2D1_RECT_U& srcRect)
    {
      HRESULT hr = getRawInterface()->CopyFromRenderTarget(&destPoint, renderTarget.getRawInterface(), &srcRect);
      if(FAILED(hr)) throw COMException(hr, "ID2D1Bitmap::CopyFromRenderTarget");
    }

    D2D1_SIZE_U Bitmap::getPixelSize() const
    {
      return getRawInterface()->GetPixelSize();
    }

    D2D1_RECT_F Geometry::getBounds() const
    {
      D2D1_RECT_F bounds = D2D1_RECT_F();
      HRESULT hr = getRawInterface()->GetBounds(nullptr, &bounds);
      if(FAILED(hr)) throw COMException(hr, "ID2D1Geometry::GetBounds");
      return bounds;
    }

    D2D1_RECT_F Geometry::getBounds(const D2D1_MATRIX_3X2_F& worldTransform) const
    {
      D2D1_RECT_F bounds = D2D1_RECT_F();
      HRESULT hr = getRawInterface()->GetBounds(&worldTransform, &bounds);
      if(FAILED(hr)) throw COMException(hr, "ID2D1Geometry::GetBounds");
      return bounds;
    }

    void Geometry::simplify(D2D1_GEOMETRY_SIMPLIFICATION_OPTION simplificationOption, float flatteningTolerance, D2::SimplifiedGeometrySink& geometrySink) const
    {
      HRESULT hr = getRawInterface()->Simplify(simplificationOption, nullptr, flatteningTolerance, geometrySink.getRawInterface());
      if(FAILED(hr)) throw COMException(hr, "ID2D1Geometry::Simplify");
    }

    void Geometry::simplify(D2D1_GEOMETRY_SIMPLIFICATION_OPTION simplificationOption, const D2D1_MATRIX_3X2_F& worldTransform, float flatteningTolerance, D2::SimplifiedGeometrySink& geometrySink) const
    {
      HRESULT hr = getRawInterface()->Simplify(simplificationOption, &worldTransform, flatteningTolerance, geometrySink.getRawInterface());
      if(FAILED(hr)) throw COMException(hr, "ID2D1Geometry::Simplify");
    }

    D2D1_GEOMETRY_RELATION Geometry::compareWithGeometry(D2::Geometry& inputGeometry, float flatteningTolerance) const
    {
      D2D1_GEOMETRY_RELATION relation = D2D1_GEOMETRY_RELATION();
      HRESULT hr = getRawInterface()->CompareWithGeometry(inputGeometry.getRawInterface(), nullptr, flatteningTolerance, &relation);
      if(FAILED(hr)) throw COMException(hr, "ID2D1Geometry::CompareWithGeometry");
      return relation;
    }

    D2D1_GEOMETRY_RELATION Geometry::compareWithGeometry(D2::Geometry& inputGeometry, const D2D1_MATRIX_3X2_F& inputGeometryTransform, float flatteningTolerance) const
    {
      D2D1_GEOMETRY_RELATION relation = D2D1_GEOMETRY_RELATION();
      HRESULT hr = getRawInterface()->CompareWithGeometry(inputGeometry.getRawInterface(), &inputGeometryTransform, flatteningTolerance, &relation);
      if(FAILED(hr)) throw COMException(hr, "ID2D1Geometry::CompareWithGeometry");
      return relation;
    }

    void Geometry::widen(float strokeWidth, float flatteningTolerance, D2::SimplifiedGeometrySink& geometrySink) const
    {
      HRESULT hr = getRawInterface()->Widen(strokeWidth, nullptr, nullptr, flatteningTolerance, geometrySink.getRawInterface());
      if(FAILED(hr)) throw COMException(hr, "ID2D1Geometry::Widen");
    }

    void Geometry::widen(float strokeWidth, D2::StrokeStyle& strokeStyle, float flatteningTolerance, D2::SimplifiedGeometrySink& geometrySink) const
    {
      HRESULT hr = getRawInterface()->Widen(strokeWidth, strokeStyle.getRawInterface(), nullptr, flatteningTolerance, geometrySink.getRawInterface());
      if(FAILED(hr)) throw COMException(hr, "ID2D1Geometry::Widen");
    }

    void Geometry::widen(float strokeWidth, D2::StrokeStyle& strokeStyle, const D2D1_MATRIX_3X2_F& worldTransform, float flatteningTolerance, D2::SimplifiedGeometrySink& geometrySink) const
    {
      HRESULT hr = getRawInterface()->Widen(strokeWidth, strokeStyle.getRawInterface(), &worldTransform, flatteningTolerance, geometrySink.getRawInterface());
      if(FAILED(hr)) throw COMException(hr, "ID2D1Geometry::Widen");
    }

    void Geometry::outline(float flatteningTolerance, D2::SimplifiedGeometrySink& geometrySink) const
    {
      HRESULT hr = getRawInterface()->Outline(nullptr, flatteningTolerance, geometrySink.getRawInterface());
      if(FAILED(hr)) throw COMException(hr, "ID2D1Geometry::Outline");
    }

    void Geometry::outline(const D2D1_MATRIX_3X2_F& worldTransform, float flatteningTolerance, D2::SimplifiedGeometrySink& geometrySink) const
    {
      HRESULT hr = getRawInterface()->Outline(&worldTransform, flatteningTolerance, geometrySink.getRawInterface());
      if(FAILED(hr)) throw COMException(hr, "ID2D1Geometry::Outline");
    }

    bool Geometry::fillContainsPoint(D2D1_POINT_2F point, float flatteningTolerance) const
    {
      BOOL contains = BOOL();
      HRESULT hr = getRawInterface()->FillContainsPoint(point, nullptr, flatteningTolerance, &contains);
      if(FAILED(hr)) throw COMException(hr, "ID2D1Geometry::FillContainsPoint");
      return contains != FALSE;
    }

    bool Geometry::fillContainsPoint(D2D1_POINT_2F point, const D2D1_MATRIX_3X2_F& worldTransform, float flatteningTolerance) const
    {
      BOOL contains = BOOL();
      HRESULT hr = getRawInterface()->FillContainsPoint(point, &worldTransform, flatteningTolerance, &contains);
      if(FAILED(hr)) throw COMException(hr, "ID2D1Geometry::FillContainsPoint");
      return contains != FALSE;
    }

    void Geometry::tessellate(float flatteningTolerance, D2::TessellationSink& tessellationSink) const
    {
      HRESULT hr = getRawInterface()->Tessellate(nullptr, flatteningTolerance, tessellationSink.getRawInterface());
      if(FAILED(hr)) throw COMException(hr, "ID2D1Geometry::Tessellate");
    }

    void Geometry::tessellate(const D2D1_MATRIX_3X2_F& worldTransform, float flatteningTolerance, D2::TessellationSink& tessellationSink) const
    {
      HRESULT hr = getRawInterface()->Tessellate(&worldTransform, flatteningTolerance, tessellationSink.getRawInterface());
      if(FAILED(hr)) throw COMException(hr, "ID2D1Geometry::Tessellate");
    }

    bool Geometry::strokeContainsPoint(D2D1_POINT_2F point, float strokeWidth, float flatteningTolerance) const
    {
      BOOL contains = BOOL();
      HRESULT hr = getRawInterface()->StrokeContainsPoint(point, strokeWidth, nullptr, nullptr, flatteningTolerance, &contains);
      if(FAILED(hr)) throw COMException(hr, "ID2D1Geometry::StrokeContainsPoint");
      return contains != FALSE;
    }

    bool Geometry::strokeContainsPoint(D2D1_POINT_2F point, float strokeWidth, D2::StrokeStyle& strokeStyle, float flatteningTolerance) const
    {
      BOOL contains = BOOL();
      HRESULT hr = getRawInterface()->StrokeContainsPoint(point, strokeWidth, strokeStyle.getRawInterface(), nullptr, flatteningTolerance, &contains);
      if(FAILED(hr)) throw COMException(hr, "ID2D1Geometry::StrokeContainsPoint");
      return contains != FALSE;
    }

    bool Geometry::strokeContainsPoint(D2D1_POINT_2F point, float strokeWidth, D2::StrokeStyle& strokeStyle, const D2D1_MATRIX_3X2_F& worldTransform, float flatteningTolerance) const
    {
      BOOL contains = BOOL();
      HRESULT hr = getRawInterface()->StrokeContainsPoint(point, strokeWidth, strokeStyle.getRawInterface(), &worldTransform, flatteningTolerance, &contains);
      if(FAILED(hr)) throw COMException(hr, "ID2D1Geometry::StrokeContainsPoint");
      return contains != FALSE;
    }

    float Geometry::computeLength(float flatteningTolerance) const
    {
      float length = float();
      HRESULT hr = getRawInterface()->ComputeLength(nullptr, flatteningTolerance, &length);
      if(FAILED(hr)) throw COMException(hr, "ID2D1Geometry::ComputeLength");
      return length;
    }

    float Geometry::computeLength(const D2D1_MATRIX_3X2_F& worldTransform, float flatteningTolerance) const
    {
      float length = float();
      HRESULT hr = getRawInterface()->ComputeLength(&worldTransform, flatteningTolerance, &length);
      if(FAILED(hr)) throw COMException(hr, "ID2D1Geometry::ComputeLength");
      return length;
    }

    float Geometry::computeArea(float flatteningTolerance) const
    {
      float area = float();
      HRESULT hr = getRawInterface()->ComputeArea(nullptr, flatteningTolerance, &area);
      if(FAILED(hr)) throw COMException(hr, "ID2D1Geometry::ComputeArea");
      return area;
    }

    float Geometry::computeArea(const D2D1_MATRIX_3X2_F& worldTransform, float flatteningTolerance) const
    {
      float area = float();
      HRESULT hr = getRawInterface()->ComputeArea(&worldTransform, flatteningTolerance, &area);
      if(FAILED(hr)) throw COMException(hr, "ID2D1Geometry::ComputeArea");
      return area;
    }

    std::tuple<D2D1_POINT_2F, D2D1_POINT_2F> Geometry::computePointAtLength(float length, float flatteningTolerance) const
    {
      D2D1_POINT_2F point = D2D1_POINT_2F();
      D2D1_POINT_2F unitTangentVector = D2D1_POINT_2F();
      HRESULT hr = getRawInterface()->ComputePointAtLength(length, nullptr, flatteningTolerance, &point, &unitTangentVector);
      if(FAILED(hr)) throw COMException(hr, "ID2D1Geometry::ComputePointAtLength");
      return std::make_tuple(std::move(point), std::move(unitTangentVector));
    }

    std::tuple<D2D1_POINT_2F, D2D1_POINT_2F> Geometry::computePointAtLength(float length, const D2D1_MATRIX_3X2_F& worldTransform, float flatteningTolerance) const
    {
      D2D1_POINT_2F point = D2D1_POINT_2F();
      D2D1_POINT_2F unitTangentVector = D2D1_POINT_2F();
      HRESULT hr = getRawInterface()->ComputePointAtLength(length, &worldTransform, flatteningTolerance, &point, &unitTangentVector);
      if(FAILED(hr)) throw COMException(hr, "ID2D1Geometry::ComputePointAtLength");
      return std::make_tuple(std::move(point), std::move(unitTangentVector));
    }

    D2D1_RECT_F Geometry::getWidenedBounds(float strokeWidth, float flatteningTolerance) const
    {
      D2D1_RECT_F bounds = D2D1_RECT_F();
      HRESULT hr = getRawInterface()->GetWidenedBounds(strokeWidth, nullptr, nullptr, flatteningTolerance, &bounds);
      if(FAILED(hr)) throw COMException(hr, "ID2D1Geometry::GetWidenedBounds");
      return bounds;
    }

    D2D1_RECT_F Geometry::getWidenedBounds(float strokeWidth, D2::StrokeStyle& strokeStyle, float flatteningTolerance) const
    {
      D2D1_RECT_F bounds = D2D1_RECT_F();
      HRESULT hr = getRawInterface()->GetWidenedBounds(strokeWidth, strokeStyle.getRawInterface(), nullptr, flatteningTolerance, &bounds);
      if(FAILED(hr)) throw COMException(hr, "ID2D1Geometry::GetWidenedBounds");
      return bounds;
    }

    D2D1_RECT_F Geometry::getWidenedBounds(float strokeWidth, D2::StrokeStyle& strokeStyle, const D2D1_MATRIX_3X2_F& worldTransform, float flatteningTolerance) const
    {
      D2D1_RECT_F bounds = D2D1_RECT_F();
      HRESULT hr = getRawInterface()->GetWidenedBounds(strokeWidth, strokeStyle.getRawInterface(), &worldTransform, flatteningTolerance, &bounds);
      if(FAILED(hr)) throw COMException(hr, "ID2D1Geometry::GetWidenedBounds");
      return bounds;
    }

    void Geometry::combineWithGeometry(D2::Geometry& inputGeometry, D2D1_COMBINE_MODE combineMode, float flatteningTolerance, D2::SimplifiedGeometrySink& geometrySink) const
    {
      HRESULT hr = getRawInterface()->CombineWithGeometry(inputGeometry.getRawInterface(), combineMode, nullptr, flatteningTolerance, geometrySink.getRawInterface());
      if(FAILED(hr)) throw COMException(hr, "ID2D1Geometry::CombineWithGeometry");
    }

    void Geometry::combineWithGeometry(D2::Geometry& inputGeometry, D2D1_COMBINE_MODE combineMode, const D2D1_MATRIX_3X2_F& inputGeometryTransform, float flatteningTolerance, D2::SimplifiedGeometrySink& geometrySink) const
    {
      HRESULT hr = getRawInterface()->CombineWithGeometry(inputGeometry.getRawInterface(), combineMode, &inputGeometryTransform, flatteningTolerance, geometrySink.getRawInterface());
      if(FAILED(hr)) throw COMException(hr, "ID2D1Geometry::CombineWithGeometry");
    }

    std::vector<ID2D1Geometry*> GeometryGroup::getSourceGeometries(unsigned int geometriesCount) const
    {
      std::vector<ID2D1Geometry*> geometries(static_cast<size_t>(geometriesCount));
      getRawInterface()->GetSourceGeometries(geometries.data(), geometriesCount);
      return geometries;
    }

    uint32_t GeometryGroup::getSourceGeometryCount() const
    {
      return getRawInterface()->GetSourceGeometryCount();
    }

    D2D1_FILL_MODE GeometryGroup::getFillMode() const
    {
      return getRawInterface()->GetFillMode();
    }

    D2D1_ELLIPSE EllipseGeometry::getEllipse() const
    {
      D2D1_ELLIPSE ellipse = D2D1_ELLIPSE();
      getRawInterface()->GetEllipse(&ellipse);
      return ellipse;
    }

    D2D1_ROUNDED_RECT RoundedRectangleGeometry::getRoundedRect() const
    {
      D2D1_ROUNDED_RECT roundedRect = D2D1_ROUNDED_RECT();
      getRawInterface()->GetRoundedRect(&roundedRect);
      return roundedRect;
    }

    D2::Geometry TransformedGeometry::getSourceGeometry() const
    {
      ID2D1Geometry* sourceGeometry = nullptr;
      getRawInterface()->GetSourceGeometry(&sourceGeometry);
      return D2::Geometry(sourceGeometry);
    }

    D2D1_MATRIX_3X2_F TransformedGeometry::getTransform() const
    {
      D2D1_MATRIX_3X2_F transform = D2D1_MATRIX_3X2_F();
      getRawInterface()->GetTransform(&transform);
      return transform;
    }

    uint32_t PathGeometry::getSegmentCount() const
    {
      uint32_t count = uint32_t();
      HRESULT hr = getRawInterface()->GetSegmentCount(&count);
      if(FAILED(hr)) throw COMException(hr, "ID2D1PathGeometry::GetSegmentCount");
      return count;
    }

    void PathGeometry::stream(D2::GeometrySink& geometrySink) const
    {
      HRESULT hr = getRawInterface()->Stream(geometrySink.getRawInterface());
      if(FAILED(hr)) throw COMException(hr, "ID2D1PathGeometry::Stream");
    }

    D2::GeometrySink PathGeometry::open()
    {
      ID2D1GeometrySink* geometrySink = nullptr;
      HRESULT hr = getRawInterface()->Open(&geometrySink);
      if(FAILED(hr)) throw COMException(hr, "ID2D1PathGeometry::Open");
      return D2::GeometrySink(geometrySink);
    }

    uint32_t PathGeometry::getFigureCount() const
    {
      uint32_t count = uint32_t();
      HRESULT hr = getRawInterface()->GetFigureCount(&count);
      if(FAILED(hr)) throw COMException(hr, "ID2D1PathGeometry::GetFigureCount");
      return count;
    }

    D2D1_RECT_F RectangleGeometry::getRect() const
    {
      D2D1_RECT_F rect = D2D1_RECT_F();
      getRawInterface()->GetRect(&rect);
      return rect;
    }

    void SimplifiedGeometrySink::setSegmentFlags(D2D1_PATH_SEGMENT vertexFlags)
    {
      getRawInterface()->SetSegmentFlags(vertexFlags);
    }

    void SimplifiedGeometrySink::close()
    {
      HRESULT hr = getRawInterface()->Close();
      if(FAILED(hr)) throw COMException(hr, "ID2D1SimplifiedGeometrySink::Close");
    }

    void SimplifiedGeometrySink::setFillMode(D2D1_FILL_MODE fillMode)
    {
      getRawInterface()->SetFillMode(fillMode);
    }

    void SimplifiedGeometrySink::endFigure(D2D1_FIGURE_END figureEnd)
    {
      getRawInterface()->EndFigure(figureEnd);
    }

    void SimplifiedGeometrySink::beginFigure(D2D1_POINT_2F startPoint, D2D1_FIGURE_BEGIN figureBegin)
    {
      getRawInterface()->BeginFigure(startPoint, figureBegin);
    }

    void GeometrySink::addLine(D2D1_POINT_2F point)
    {
      getRawInterface()->AddLine(point);
    }

    void GeometrySink::addBezier(const D2D1_BEZIER_SEGMENT& bezier)
    {
      getRawInterface()->AddBezier(&bezier);
    }

    void GeometrySink::addArc(const D2D1_ARC_SEGMENT& arc)
    {
      getRawInterface()->AddArc(&arc);
    }

    void GeometrySink::addQuadraticBezier(const D2D1_QUADRATIC_BEZIER_SEGMENT& bezier)
    {
      getRawInterface()->AddQuadraticBezier(&bezier);
    }

    HDC GdiInteropRenderTarget::getDC(D2D1_DC_INITIALIZE_MODE mode)
    {
      HDC hdc = HDC();
      HRESULT hr = getRawInterface()->GetDC(mode, &hdc);
      if(FAILED(hr)) throw COMException(hr, "ID2D1GdiInteropRenderTarget::GetDC");
      return hdc;
    }

    void GdiInteropRenderTarget::releaseDC()
    {
      HRESULT hr = getRawInterface()->ReleaseDC(nullptr);
      if(FAILED(hr)) throw COMException(hr, "ID2D1GdiInteropRenderTarget::ReleaseDC");
    }

    void GdiInteropRenderTarget::releaseDC(const RECT& update)
    {
      HRESULT hr = getRawInterface()->ReleaseDC(&update);
      if(FAILED(hr)) throw COMException(hr, "ID2D1GdiInteropRenderTarget::ReleaseDC");
    }

  }
}
