#pragma once
// Autogenerated by nicify.lua -- do not edit by hand.
#include <limits>
#include <dwrite.h>
#include "com.h"
namespace C6
{
  namespace DW
  {
    class LocalizedStrings;
    class TextRenderer;
    class GlyphRunAnalysis;
    class TextAnalyzer;
    class LocalFontFileLoader;
    class BitmapRenderTarget;
    class InlineObject;
    class FontFileEnumerator;
    class FontFileStream;
    class Factory;
    class FontCollection;
    class TextFormat;
    class FontFileLoader;
    class FontList;
    class FontFamily;
    class Typography;
    class GdiInterop;
    class TextAnalysisSink;
    class NumberSubstitution;
    class FontCollectionLoader;
    class FontFile;
    class RenderingParams;
    class TextAnalysisSource;
    class FontFace;
    class PixelSnapping;
    class Font;
    class TextLayout;

    class LocalizedStrings : public COMObject
    {
    public:
      // Constructors
      LocalizedStrings() {}
      LocalizedStrings(nullptr_t) {}
      explicit LocalizedStrings(::IDWriteLocalizedStrings* raw) : COMObject(raw) {}
      LocalizedStrings(const LocalizedStrings& copy_from) : COMObject(copy_from) {}
      LocalizedStrings(LocalizedStrings&& move_from) : COMObject(std::move(move_from)) {}

      // Operators
      inline LocalizedStrings& operator= (const LocalizedStrings& copy_from) {COMObject::operator=(copy_from); return *this;}
      inline LocalizedStrings& operator= (LocalizedStrings&& move_from) {COMObject::operator=(std::move(move_from)); return *this;}
      _OPERATOR_BOOL() const {return getRawInterface() ? _CONVERTIBLE_TO_TRUE : 0;}

      // Utilities
      inline ::IDWriteLocalizedStrings* getRawInterface() {return static_cast<::IDWriteLocalizedStrings*>(COMObject::getRawInterface());}
      inline const ::IDWriteLocalizedStrings* getRawInterface() const {return static_cast<const ::IDWriteLocalizedStrings*>(COMObject::getRawInterface());}
      inline void swap(LocalizedStrings& other) {COMObject::swap(other);}
      typedef ::IDWriteLocalizedStrings dumb_t;

      // Methods
      uint32_t getLocaleNameLength(uint32_t index);
      std::vector<wchar_t> getString(uint32_t index, uint32_t size);
      uint32_t getCount();
      uint32_t getStringLength(uint32_t index);
      std::tuple<uint32_t, bool> findLocaleName(const wchar_t* localeName);
      std::vector<wchar_t> getLocaleName(uint32_t index, uint32_t size);
    };

    class GlyphRunAnalysis : public COMObject
    {
    public:
      // Constructors
      GlyphRunAnalysis() {}
      GlyphRunAnalysis(nullptr_t) {}
      explicit GlyphRunAnalysis(::IDWriteGlyphRunAnalysis* raw) : COMObject(raw) {}
      GlyphRunAnalysis(const GlyphRunAnalysis& copy_from) : COMObject(copy_from) {}
      GlyphRunAnalysis(GlyphRunAnalysis&& move_from) : COMObject(std::move(move_from)) {}

      // Operators
      inline GlyphRunAnalysis& operator= (const GlyphRunAnalysis& copy_from) {COMObject::operator=(copy_from); return *this;}
      inline GlyphRunAnalysis& operator= (GlyphRunAnalysis&& move_from) {COMObject::operator=(std::move(move_from)); return *this;}
      _OPERATOR_BOOL() const {return getRawInterface() ? _CONVERTIBLE_TO_TRUE : 0;}

      // Utilities
      inline ::IDWriteGlyphRunAnalysis* getRawInterface() {return static_cast<::IDWriteGlyphRunAnalysis*>(COMObject::getRawInterface());}
      inline const ::IDWriteGlyphRunAnalysis* getRawInterface() const {return static_cast<const ::IDWriteGlyphRunAnalysis*>(COMObject::getRawInterface());}
      inline void swap(GlyphRunAnalysis& other) {COMObject::swap(other);}
      typedef ::IDWriteGlyphRunAnalysis dumb_t;

      // Methods
      RECT getAlphaTextureBounds(DWRITE_TEXTURE_TYPE textureType);
      void createAlphaTexture(DWRITE_TEXTURE_TYPE textureType, const RECT& textureBounds, BYTE* alphaValues, uint32_t bufferSize);
      std::tuple<float, float, float> getAlphaBlendParams(DW::RenderingParams& renderingParams);
    };

    class TextAnalyzer : public COMObject
    {
    public:
      // Constructors
      TextAnalyzer() {}
      TextAnalyzer(nullptr_t) {}
      explicit TextAnalyzer(::IDWriteTextAnalyzer* raw) : COMObject(raw) {}
      TextAnalyzer(const TextAnalyzer& copy_from) : COMObject(copy_from) {}
      TextAnalyzer(TextAnalyzer&& move_from) : COMObject(std::move(move_from)) {}

      // Operators
      inline TextAnalyzer& operator= (const TextAnalyzer& copy_from) {COMObject::operator=(copy_from); return *this;}
      inline TextAnalyzer& operator= (TextAnalyzer&& move_from) {COMObject::operator=(std::move(move_from)); return *this;}
      _OPERATOR_BOOL() const {return getRawInterface() ? _CONVERTIBLE_TO_TRUE : 0;}

      // Utilities
      inline ::IDWriteTextAnalyzer* getRawInterface() {return static_cast<::IDWriteTextAnalyzer*>(COMObject::getRawInterface());}
      inline const ::IDWriteTextAnalyzer* getRawInterface() const {return static_cast<const ::IDWriteTextAnalyzer*>(COMObject::getRawInterface());}
      inline void swap(TextAnalyzer& other) {COMObject::swap(other);}
      typedef ::IDWriteTextAnalyzer dumb_t;

      // Methods
      void analyzeScript(DW::TextAnalysisSource& analysisSource, uint32_t textPosition, uint32_t textLength, DW::TextAnalysisSink& analysisSink);

      template <typename const_wchar_t_Container>
      std::tuple<std::vector<UINT16>, std::vector<DWRITE_SHAPING_TEXT_PROPERTIES>, std::vector<UINT16>, std::vector<DWRITE_SHAPING_GLYPH_PROPERTIES>, uint32_t> getGlyphs(const_wchar_t_Container&& textString, DW::FontFace& fontFace, BOOL isSideways, BOOL isRightToLeft, const DWRITE_SCRIPT_ANALYSIS& scriptAnalysis, uint32_t maxGlyphCount)
      {
        std::vector<UINT16> clusterMap(static_cast<size_t>(textLength));
        std::vector<DWRITE_SHAPING_TEXT_PROPERTIES> textProps(static_cast<size_t>(textLength));
        std::vector<UINT16> glyphIndices(static_cast<size_t>(maxGlyphCount));
        std::vector<DWRITE_SHAPING_GLYPH_PROPERTIES> glyphProps(static_cast<size_t>(maxGlyphCount));
        uint32_t actualGlyphCount = uint32_t();
        HRESULT hr = getRawInterface()->GetGlyphs(C6::internal::ecount<const_wchar_t_Container>::data(textString), static_cast<uint32_t>(C6::internal::ecount<const_wchar_t_Container>::size(textString)), fontFace.getRawInterface(), isSideways, isRightToLeft, &scriptAnalysis, nullptr, nullptr, nullptr, nullptr, 0, maxGlyphCount, clusterMap.data(), textProps.data(), glyphIndices.data(), glyphProps.data(), &actualGlyphCount);
        if(FAILED(hr)) throw COMException(hr, "IDWriteTextAnalyzer::GetGlyphs");
        return std::make_tuple(std::move(clusterMap), std::move(textProps), std::move(glyphIndices), std::move(glyphProps), std::move(actualGlyphCount));
      }


      template <typename const_wchar_t_Container>
      std::tuple<std::vector<UINT16>, std::vector<DWRITE_SHAPING_TEXT_PROPERTIES>, std::vector<UINT16>, std::vector<DWRITE_SHAPING_GLYPH_PROPERTIES>, uint32_t> getGlyphs(const_wchar_t_Container&& textString, DW::FontFace& fontFace, BOOL isSideways, BOOL isRightToLeft, const DWRITE_SCRIPT_ANALYSIS& scriptAnalysis, const wchar_t* localeName, uint32_t maxGlyphCount)
      {
        std::vector<UINT16> clusterMap(static_cast<size_t>(textLength));
        std::vector<DWRITE_SHAPING_TEXT_PROPERTIES> textProps(static_cast<size_t>(textLength));
        std::vector<UINT16> glyphIndices(static_cast<size_t>(maxGlyphCount));
        std::vector<DWRITE_SHAPING_GLYPH_PROPERTIES> glyphProps(static_cast<size_t>(maxGlyphCount));
        uint32_t actualGlyphCount = uint32_t();
        HRESULT hr = getRawInterface()->GetGlyphs(C6::internal::ecount<const_wchar_t_Container>::data(textString), static_cast<uint32_t>(C6::internal::ecount<const_wchar_t_Container>::size(textString)), fontFace.getRawInterface(), isSideways, isRightToLeft, &scriptAnalysis, localeName, nullptr, nullptr, nullptr, 0, maxGlyphCount, clusterMap.data(), textProps.data(), glyphIndices.data(), glyphProps.data(), &actualGlyphCount);
        if(FAILED(hr)) throw COMException(hr, "IDWriteTextAnalyzer::GetGlyphs");
        return std::make_tuple(std::move(clusterMap), std::move(textProps), std::move(glyphIndices), std::move(glyphProps), std::move(actualGlyphCount));
      }


      template <typename const_wchar_t_Container>
      std::tuple<std::vector<UINT16>, std::vector<DWRITE_SHAPING_TEXT_PROPERTIES>, std::vector<UINT16>, std::vector<DWRITE_SHAPING_GLYPH_PROPERTIES>, uint32_t> getGlyphs(const_wchar_t_Container&& textString, DW::FontFace& fontFace, BOOL isSideways, BOOL isRightToLeft, const DWRITE_SCRIPT_ANALYSIS& scriptAnalysis, const wchar_t* localeName, DW::NumberSubstitution& numberSubstitution, uint32_t maxGlyphCount)
      {
        std::vector<UINT16> clusterMap(static_cast<size_t>(textLength));
        std::vector<DWRITE_SHAPING_TEXT_PROPERTIES> textProps(static_cast<size_t>(textLength));
        std::vector<UINT16> glyphIndices(static_cast<size_t>(maxGlyphCount));
        std::vector<DWRITE_SHAPING_GLYPH_PROPERTIES> glyphProps(static_cast<size_t>(maxGlyphCount));
        uint32_t actualGlyphCount = uint32_t();
        HRESULT hr = getRawInterface()->GetGlyphs(C6::internal::ecount<const_wchar_t_Container>::data(textString), static_cast<uint32_t>(C6::internal::ecount<const_wchar_t_Container>::size(textString)), fontFace.getRawInterface(), isSideways, isRightToLeft, &scriptAnalysis, localeName, numberSubstitution.getRawInterface(), nullptr, nullptr, 0, maxGlyphCount, clusterMap.data(), textProps.data(), glyphIndices.data(), glyphProps.data(), &actualGlyphCount);
        if(FAILED(hr)) throw COMException(hr, "IDWriteTextAnalyzer::GetGlyphs");
        return std::make_tuple(std::move(clusterMap), std::move(textProps), std::move(glyphIndices), std::move(glyphProps), std::move(actualGlyphCount));
      }


      template <typename const_wchar_t_Container, typename const_DWRITE_TYPOGRAPHIC_FEATURES__Container>
      std::tuple<std::vector<UINT16>, std::vector<DWRITE_SHAPING_TEXT_PROPERTIES>, std::vector<UINT16>, std::vector<DWRITE_SHAPING_GLYPH_PROPERTIES>, uint32_t> getGlyphs(const_wchar_t_Container&& textString, DW::FontFace& fontFace, BOOL isSideways, BOOL isRightToLeft, const DWRITE_SCRIPT_ANALYSIS& scriptAnalysis, const wchar_t* localeName, DW::NumberSubstitution& numberSubstitution, const_DWRITE_TYPOGRAPHIC_FEATURES__Container&& features, uint32_t maxGlyphCount)
      {
        std::vector<UINT16> clusterMap(static_cast<size_t>(textLength));
        std::vector<DWRITE_SHAPING_TEXT_PROPERTIES> textProps(static_cast<size_t>(textLength));
        std::vector<UINT16> glyphIndices(static_cast<size_t>(maxGlyphCount));
        std::vector<DWRITE_SHAPING_GLYPH_PROPERTIES> glyphProps(static_cast<size_t>(maxGlyphCount));
        uint32_t actualGlyphCount = uint32_t();
        HRESULT hr = getRawInterface()->GetGlyphs(C6::internal::ecount<const_wchar_t_Container>::data(textString), static_cast<uint32_t>(C6::internal::ecount<const_wchar_t_Container>::size(textString)), fontFace.getRawInterface(), isSideways, isRightToLeft, &scriptAnalysis, localeName, numberSubstitution.getRawInterface(), C6::internal::ecount<const_DWRITE_TYPOGRAPHIC_FEATURES__Container>::data(features), nullptr, static_cast<uint32_t>(C6::internal::ecount<const_DWRITE_TYPOGRAPHIC_FEATURES__Container>::size(features)), maxGlyphCount, clusterMap.data(), textProps.data(), glyphIndices.data(), glyphProps.data(), &actualGlyphCount);
        if(FAILED(hr)) throw COMException(hr, "IDWriteTextAnalyzer::GetGlyphs");
        return std::make_tuple(std::move(clusterMap), std::move(textProps), std::move(glyphIndices), std::move(glyphProps), std::move(actualGlyphCount));
      }


      template <typename const_wchar_t_Container, typename const_DWRITE_TYPOGRAPHIC_FEATURES__Container, typename const_uint32_t_Container>
      std::tuple<std::vector<UINT16>, std::vector<DWRITE_SHAPING_TEXT_PROPERTIES>, std::vector<UINT16>, std::vector<DWRITE_SHAPING_GLYPH_PROPERTIES>, uint32_t> getGlyphs(const_wchar_t_Container&& textString, DW::FontFace& fontFace, BOOL isSideways, BOOL isRightToLeft, const DWRITE_SCRIPT_ANALYSIS& scriptAnalysis, const wchar_t* localeName, DW::NumberSubstitution& numberSubstitution, const_DWRITE_TYPOGRAPHIC_FEATURES__Container&& features, const_uint32_t_Container&& featureRangeLengths, uint32_t maxGlyphCount)
      {
        std::vector<UINT16> clusterMap(static_cast<size_t>(textLength));
        std::vector<DWRITE_SHAPING_TEXT_PROPERTIES> textProps(static_cast<size_t>(textLength));
        std::vector<UINT16> glyphIndices(static_cast<size_t>(maxGlyphCount));
        std::vector<DWRITE_SHAPING_GLYPH_PROPERTIES> glyphProps(static_cast<size_t>(maxGlyphCount));
        uint32_t actualGlyphCount = uint32_t();
        HRESULT hr = getRawInterface()->GetGlyphs(C6::internal::ecount<const_wchar_t_Container>::data(textString), static_cast<uint32_t>(C6::internal::ecount<const_wchar_t_Container>::size(textString)), fontFace.getRawInterface(), isSideways, isRightToLeft, &scriptAnalysis, localeName, numberSubstitution.getRawInterface(), C6::internal::ecount<const_DWRITE_TYPOGRAPHIC_FEATURES__Container>::data(features), C6::internal::ecount<const_uint32_t_Container>::data(featureRangeLengths), (std::min)(static_cast<uint32_t>(C6::internal::ecount<const_DWRITE_TYPOGRAPHIC_FEATURES__Container>::size(features)), static_cast<uint32_t>(C6::internal::ecount<const_uint32_t_Container>::size(featureRangeLengths))), maxGlyphCount, clusterMap.data(), textProps.data(), glyphIndices.data(), glyphProps.data(), &actualGlyphCount);
        if(FAILED(hr)) throw COMException(hr, "IDWriteTextAnalyzer::GetGlyphs");
        return std::make_tuple(std::move(clusterMap), std::move(textProps), std::move(glyphIndices), std::move(glyphProps), std::move(actualGlyphCount));
      }

      void analyzeNumberSubstitution(DW::TextAnalysisSource& analysisSource, uint32_t textPosition, uint32_t textLength, DW::TextAnalysisSink& analysisSink);
      void analyzeBidi(DW::TextAnalysisSource& analysisSource, uint32_t textPosition, uint32_t textLength, DW::TextAnalysisSink& analysisSink);
      void analyzeLineBreakpoints(DW::TextAnalysisSource& analysisSource, uint32_t textPosition, uint32_t textLength, DW::TextAnalysisSink& analysisSink);

      template <typename const_wchar_t_Container, typename const_UINT16_Container, typename DWRITE_SHAPING_TEXT_PROPERTIES_Container, typename const_UINT16_Container2, typename const_DWRITE_SHAPING_GLYPH_PROPERTIES_Container>
      std::tuple<std::vector<float>, std::vector<DWRITE_GLYPH_OFFSET>> getGdiCompatibleGlyphPlacements(const_wchar_t_Container&& textString, const_UINT16_Container&& clusterMap, DWRITE_SHAPING_TEXT_PROPERTIES_Container&& textProps, const_UINT16_Container2&& glyphIndices, const_DWRITE_SHAPING_GLYPH_PROPERTIES_Container&& glyphProps, DW::FontFace& fontFace, float fontEmSize, float pixelsPerDip, BOOL useGdiNatural, BOOL isSideways, BOOL isRightToLeft, const DWRITE_SCRIPT_ANALYSIS& scriptAnalysis)
      {
        std::vector<float> glyphAdvances(static_cast<size_t>(glyphCount));
        std::vector<DWRITE_GLYPH_OFFSET> glyphOffsets(static_cast<size_t>(glyphCount));
        HRESULT hr = getRawInterface()->GetGdiCompatibleGlyphPlacements(C6::internal::ecount<const_wchar_t_Container>::data(textString), C6::internal::ecount<const_UINT16_Container>::data(clusterMap), C6::internal::ecount<DWRITE_SHAPING_TEXT_PROPERTIES_Container>::data(textProps), (std::min)((std::min)(static_cast<uint32_t>(C6::internal::ecount<const_wchar_t_Container>::size(textString)), static_cast<uint32_t>(C6::internal::ecount<const_UINT16_Container>::size(clusterMap))), static_cast<uint32_t>(C6::internal::ecount<DWRITE_SHAPING_TEXT_PROPERTIES_Container>::size(textProps))), C6::internal::ecount<const_UINT16_Container2>::data(glyphIndices), C6::internal::ecount<const_DWRITE_SHAPING_GLYPH_PROPERTIES_Container>::data(glyphProps), (std::min)(static_cast<uint32_t>(C6::internal::ecount<const_UINT16_Container2>::size(glyphIndices)), static_cast<uint32_t>(C6::internal::ecount<const_DWRITE_SHAPING_GLYPH_PROPERTIES_Container>::size(glyphProps))), fontFace.getRawInterface(), fontEmSize, pixelsPerDip, nullptr, useGdiNatural, isSideways, isRightToLeft, &scriptAnalysis, nullptr, nullptr, nullptr, 0, glyphAdvances.data(), glyphOffsets.data());
        if(FAILED(hr)) throw COMException(hr, "IDWriteTextAnalyzer::GetGdiCompatibleGlyphPlacements");
        return std::make_tuple(std::move(glyphAdvances), std::move(glyphOffsets));
      }


      template <typename const_wchar_t_Container, typename const_UINT16_Container, typename DWRITE_SHAPING_TEXT_PROPERTIES_Container, typename const_UINT16_Container2, typename const_DWRITE_SHAPING_GLYPH_PROPERTIES_Container>
      std::tuple<std::vector<float>, std::vector<DWRITE_GLYPH_OFFSET>> getGdiCompatibleGlyphPlacements(const_wchar_t_Container&& textString, const_UINT16_Container&& clusterMap, DWRITE_SHAPING_TEXT_PROPERTIES_Container&& textProps, const_UINT16_Container2&& glyphIndices, const_DWRITE_SHAPING_GLYPH_PROPERTIES_Container&& glyphProps, DW::FontFace& fontFace, float fontEmSize, float pixelsPerDip, const DWRITE_MATRIX& transform, BOOL useGdiNatural, BOOL isSideways, BOOL isRightToLeft, const DWRITE_SCRIPT_ANALYSIS& scriptAnalysis)
      {
        std::vector<float> glyphAdvances(static_cast<size_t>(glyphCount));
        std::vector<DWRITE_GLYPH_OFFSET> glyphOffsets(static_cast<size_t>(glyphCount));
        HRESULT hr = getRawInterface()->GetGdiCompatibleGlyphPlacements(C6::internal::ecount<const_wchar_t_Container>::data(textString), C6::internal::ecount<const_UINT16_Container>::data(clusterMap), C6::internal::ecount<DWRITE_SHAPING_TEXT_PROPERTIES_Container>::data(textProps), (std::min)((std::min)(static_cast<uint32_t>(C6::internal::ecount<const_wchar_t_Container>::size(textString)), static_cast<uint32_t>(C6::internal::ecount<const_UINT16_Container>::size(clusterMap))), static_cast<uint32_t>(C6::internal::ecount<DWRITE_SHAPING_TEXT_PROPERTIES_Container>::size(textProps))), C6::internal::ecount<const_UINT16_Container2>::data(glyphIndices), C6::internal::ecount<const_DWRITE_SHAPING_GLYPH_PROPERTIES_Container>::data(glyphProps), (std::min)(static_cast<uint32_t>(C6::internal::ecount<const_UINT16_Container2>::size(glyphIndices)), static_cast<uint32_t>(C6::internal::ecount<const_DWRITE_SHAPING_GLYPH_PROPERTIES_Container>::size(glyphProps))), fontFace.getRawInterface(), fontEmSize, pixelsPerDip, &transform, useGdiNatural, isSideways, isRightToLeft, &scriptAnalysis, nullptr, nullptr, nullptr, 0, glyphAdvances.data(), glyphOffsets.data());
        if(FAILED(hr)) throw COMException(hr, "IDWriteTextAnalyzer::GetGdiCompatibleGlyphPlacements");
        return std::make_tuple(std::move(glyphAdvances), std::move(glyphOffsets));
      }


      template <typename const_wchar_t_Container, typename const_UINT16_Container, typename DWRITE_SHAPING_TEXT_PROPERTIES_Container, typename const_UINT16_Container2, typename const_DWRITE_SHAPING_GLYPH_PROPERTIES_Container>
      std::tuple<std::vector<float>, std::vector<DWRITE_GLYPH_OFFSET>> getGdiCompatibleGlyphPlacements(const_wchar_t_Container&& textString, const_UINT16_Container&& clusterMap, DWRITE_SHAPING_TEXT_PROPERTIES_Container&& textProps, const_UINT16_Container2&& glyphIndices, const_DWRITE_SHAPING_GLYPH_PROPERTIES_Container&& glyphProps, DW::FontFace& fontFace, float fontEmSize, float pixelsPerDip, const DWRITE_MATRIX& transform, BOOL useGdiNatural, BOOL isSideways, BOOL isRightToLeft, const DWRITE_SCRIPT_ANALYSIS& scriptAnalysis, const wchar_t* localeName)
      {
        std::vector<float> glyphAdvances(static_cast<size_t>(glyphCount));
        std::vector<DWRITE_GLYPH_OFFSET> glyphOffsets(static_cast<size_t>(glyphCount));
        HRESULT hr = getRawInterface()->GetGdiCompatibleGlyphPlacements(C6::internal::ecount<const_wchar_t_Container>::data(textString), C6::internal::ecount<const_UINT16_Container>::data(clusterMap), C6::internal::ecount<DWRITE_SHAPING_TEXT_PROPERTIES_Container>::data(textProps), (std::min)((std::min)(static_cast<uint32_t>(C6::internal::ecount<const_wchar_t_Container>::size(textString)), static_cast<uint32_t>(C6::internal::ecount<const_UINT16_Container>::size(clusterMap))), static_cast<uint32_t>(C6::internal::ecount<DWRITE_SHAPING_TEXT_PROPERTIES_Container>::size(textProps))), C6::internal::ecount<const_UINT16_Container2>::data(glyphIndices), C6::internal::ecount<const_DWRITE_SHAPING_GLYPH_PROPERTIES_Container>::data(glyphProps), (std::min)(static_cast<uint32_t>(C6::internal::ecount<const_UINT16_Container2>::size(glyphIndices)), static_cast<uint32_t>(C6::internal::ecount<const_DWRITE_SHAPING_GLYPH_PROPERTIES_Container>::size(glyphProps))), fontFace.getRawInterface(), fontEmSize, pixelsPerDip, &transform, useGdiNatural, isSideways, isRightToLeft, &scriptAnalysis, localeName, nullptr, nullptr, 0, glyphAdvances.data(), glyphOffsets.data());
        if(FAILED(hr)) throw COMException(hr, "IDWriteTextAnalyzer::GetGdiCompatibleGlyphPlacements");
        return std::make_tuple(std::move(glyphAdvances), std::move(glyphOffsets));
      }


      template <typename const_wchar_t_Container, typename const_UINT16_Container, typename DWRITE_SHAPING_TEXT_PROPERTIES_Container, typename const_UINT16_Container2, typename const_DWRITE_SHAPING_GLYPH_PROPERTIES_Container, typename const_DWRITE_TYPOGRAPHIC_FEATURES__Container>
      std::tuple<std::vector<float>, std::vector<DWRITE_GLYPH_OFFSET>> getGdiCompatibleGlyphPlacements(const_wchar_t_Container&& textString, const_UINT16_Container&& clusterMap, DWRITE_SHAPING_TEXT_PROPERTIES_Container&& textProps, const_UINT16_Container2&& glyphIndices, const_DWRITE_SHAPING_GLYPH_PROPERTIES_Container&& glyphProps, DW::FontFace& fontFace, float fontEmSize, float pixelsPerDip, const DWRITE_MATRIX& transform, BOOL useGdiNatural, BOOL isSideways, BOOL isRightToLeft, const DWRITE_SCRIPT_ANALYSIS& scriptAnalysis, const wchar_t* localeName, const_DWRITE_TYPOGRAPHIC_FEATURES__Container&& features)
      {
        std::vector<float> glyphAdvances(static_cast<size_t>(glyphCount));
        std::vector<DWRITE_GLYPH_OFFSET> glyphOffsets(static_cast<size_t>(glyphCount));
        HRESULT hr = getRawInterface()->GetGdiCompatibleGlyphPlacements(C6::internal::ecount<const_wchar_t_Container>::data(textString), C6::internal::ecount<const_UINT16_Container>::data(clusterMap), C6::internal::ecount<DWRITE_SHAPING_TEXT_PROPERTIES_Container>::data(textProps), (std::min)((std::min)(static_cast<uint32_t>(C6::internal::ecount<const_wchar_t_Container>::size(textString)), static_cast<uint32_t>(C6::internal::ecount<const_UINT16_Container>::size(clusterMap))), static_cast<uint32_t>(C6::internal::ecount<DWRITE_SHAPING_TEXT_PROPERTIES_Container>::size(textProps))), C6::internal::ecount<const_UINT16_Container2>::data(glyphIndices), C6::internal::ecount<const_DWRITE_SHAPING_GLYPH_PROPERTIES_Container>::data(glyphProps), (std::min)(static_cast<uint32_t>(C6::internal::ecount<const_UINT16_Container2>::size(glyphIndices)), static_cast<uint32_t>(C6::internal::ecount<const_DWRITE_SHAPING_GLYPH_PROPERTIES_Container>::size(glyphProps))), fontFace.getRawInterface(), fontEmSize, pixelsPerDip, &transform, useGdiNatural, isSideways, isRightToLeft, &scriptAnalysis, localeName, C6::internal::ecount<const_DWRITE_TYPOGRAPHIC_FEATURES__Container>::data(features), nullptr, static_cast<uint32_t>(C6::internal::ecount<const_DWRITE_TYPOGRAPHIC_FEATURES__Container>::size(features)), glyphAdvances.data(), glyphOffsets.data());
        if(FAILED(hr)) throw COMException(hr, "IDWriteTextAnalyzer::GetGdiCompatibleGlyphPlacements");
        return std::make_tuple(std::move(glyphAdvances), std::move(glyphOffsets));
      }


      template <typename const_wchar_t_Container, typename const_UINT16_Container, typename DWRITE_SHAPING_TEXT_PROPERTIES_Container, typename const_UINT16_Container2, typename const_DWRITE_SHAPING_GLYPH_PROPERTIES_Container, typename const_DWRITE_TYPOGRAPHIC_FEATURES__Container, typename const_uint32_t_Container>
      std::tuple<std::vector<float>, std::vector<DWRITE_GLYPH_OFFSET>> getGdiCompatibleGlyphPlacements(const_wchar_t_Container&& textString, const_UINT16_Container&& clusterMap, DWRITE_SHAPING_TEXT_PROPERTIES_Container&& textProps, const_UINT16_Container2&& glyphIndices, const_DWRITE_SHAPING_GLYPH_PROPERTIES_Container&& glyphProps, DW::FontFace& fontFace, float fontEmSize, float pixelsPerDip, const DWRITE_MATRIX& transform, BOOL useGdiNatural, BOOL isSideways, BOOL isRightToLeft, const DWRITE_SCRIPT_ANALYSIS& scriptAnalysis, const wchar_t* localeName, const_DWRITE_TYPOGRAPHIC_FEATURES__Container&& features, const_uint32_t_Container&& featureRangeLengths)
      {
        std::vector<float> glyphAdvances(static_cast<size_t>(glyphCount));
        std::vector<DWRITE_GLYPH_OFFSET> glyphOffsets(static_cast<size_t>(glyphCount));
        HRESULT hr = getRawInterface()->GetGdiCompatibleGlyphPlacements(C6::internal::ecount<const_wchar_t_Container>::data(textString), C6::internal::ecount<const_UINT16_Container>::data(clusterMap), C6::internal::ecount<DWRITE_SHAPING_TEXT_PROPERTIES_Container>::data(textProps), (std::min)((std::min)(static_cast<uint32_t>(C6::internal::ecount<const_wchar_t_Container>::size(textString)), static_cast<uint32_t>(C6::internal::ecount<const_UINT16_Container>::size(clusterMap))), static_cast<uint32_t>(C6::internal::ecount<DWRITE_SHAPING_TEXT_PROPERTIES_Container>::size(textProps))), C6::internal::ecount<const_UINT16_Container2>::data(glyphIndices), C6::internal::ecount<const_DWRITE_SHAPING_GLYPH_PROPERTIES_Container>::data(glyphProps), (std::min)(static_cast<uint32_t>(C6::internal::ecount<const_UINT16_Container2>::size(glyphIndices)), static_cast<uint32_t>(C6::internal::ecount<const_DWRITE_SHAPING_GLYPH_PROPERTIES_Container>::size(glyphProps))), fontFace.getRawInterface(), fontEmSize, pixelsPerDip, &transform, useGdiNatural, isSideways, isRightToLeft, &scriptAnalysis, localeName, C6::internal::ecount<const_DWRITE_TYPOGRAPHIC_FEATURES__Container>::data(features), C6::internal::ecount<const_uint32_t_Container>::data(featureRangeLengths), (std::min)(static_cast<uint32_t>(C6::internal::ecount<const_DWRITE_TYPOGRAPHIC_FEATURES__Container>::size(features)), static_cast<uint32_t>(C6::internal::ecount<const_uint32_t_Container>::size(featureRangeLengths))), glyphAdvances.data(), glyphOffsets.data());
        if(FAILED(hr)) throw COMException(hr, "IDWriteTextAnalyzer::GetGdiCompatibleGlyphPlacements");
        return std::make_tuple(std::move(glyphAdvances), std::move(glyphOffsets));
      }


      template <typename const_wchar_t_Container, typename const_UINT16_Container, typename DWRITE_SHAPING_TEXT_PROPERTIES_Container, typename const_UINT16_Container2, typename const_DWRITE_SHAPING_GLYPH_PROPERTIES_Container>
      std::tuple<std::vector<float>, std::vector<DWRITE_GLYPH_OFFSET>> getGlyphPlacements(const_wchar_t_Container&& textString, const_UINT16_Container&& clusterMap, DWRITE_SHAPING_TEXT_PROPERTIES_Container&& textProps, const_UINT16_Container2&& glyphIndices, const_DWRITE_SHAPING_GLYPH_PROPERTIES_Container&& glyphProps, DW::FontFace& fontFace, float fontEmSize, BOOL isSideways, BOOL isRightToLeft, const DWRITE_SCRIPT_ANALYSIS& scriptAnalysis)
      {
        std::vector<float> glyphAdvances(static_cast<size_t>(glyphCount));
        std::vector<DWRITE_GLYPH_OFFSET> glyphOffsets(static_cast<size_t>(glyphCount));
        HRESULT hr = getRawInterface()->GetGlyphPlacements(C6::internal::ecount<const_wchar_t_Container>::data(textString), C6::internal::ecount<const_UINT16_Container>::data(clusterMap), C6::internal::ecount<DWRITE_SHAPING_TEXT_PROPERTIES_Container>::data(textProps), (std::min)((std::min)(static_cast<uint32_t>(C6::internal::ecount<const_wchar_t_Container>::size(textString)), static_cast<uint32_t>(C6::internal::ecount<const_UINT16_Container>::size(clusterMap))), static_cast<uint32_t>(C6::internal::ecount<DWRITE_SHAPING_TEXT_PROPERTIES_Container>::size(textProps))), C6::internal::ecount<const_UINT16_Container2>::data(glyphIndices), C6::internal::ecount<const_DWRITE_SHAPING_GLYPH_PROPERTIES_Container>::data(glyphProps), (std::min)(static_cast<uint32_t>(C6::internal::ecount<const_UINT16_Container2>::size(glyphIndices)), static_cast<uint32_t>(C6::internal::ecount<const_DWRITE_SHAPING_GLYPH_PROPERTIES_Container>::size(glyphProps))), fontFace.getRawInterface(), fontEmSize, isSideways, isRightToLeft, &scriptAnalysis, nullptr, nullptr, nullptr, 0, glyphAdvances.data(), glyphOffsets.data());
        if(FAILED(hr)) throw COMException(hr, "IDWriteTextAnalyzer::GetGlyphPlacements");
        return std::make_tuple(std::move(glyphAdvances), std::move(glyphOffsets));
      }


      template <typename const_wchar_t_Container, typename const_UINT16_Container, typename DWRITE_SHAPING_TEXT_PROPERTIES_Container, typename const_UINT16_Container2, typename const_DWRITE_SHAPING_GLYPH_PROPERTIES_Container>
      std::tuple<std::vector<float>, std::vector<DWRITE_GLYPH_OFFSET>> getGlyphPlacements(const_wchar_t_Container&& textString, const_UINT16_Container&& clusterMap, DWRITE_SHAPING_TEXT_PROPERTIES_Container&& textProps, const_UINT16_Container2&& glyphIndices, const_DWRITE_SHAPING_GLYPH_PROPERTIES_Container&& glyphProps, DW::FontFace& fontFace, float fontEmSize, BOOL isSideways, BOOL isRightToLeft, const DWRITE_SCRIPT_ANALYSIS& scriptAnalysis, const wchar_t* localeName)
      {
        std::vector<float> glyphAdvances(static_cast<size_t>(glyphCount));
        std::vector<DWRITE_GLYPH_OFFSET> glyphOffsets(static_cast<size_t>(glyphCount));
        HRESULT hr = getRawInterface()->GetGlyphPlacements(C6::internal::ecount<const_wchar_t_Container>::data(textString), C6::internal::ecount<const_UINT16_Container>::data(clusterMap), C6::internal::ecount<DWRITE_SHAPING_TEXT_PROPERTIES_Container>::data(textProps), (std::min)((std::min)(static_cast<uint32_t>(C6::internal::ecount<const_wchar_t_Container>::size(textString)), static_cast<uint32_t>(C6::internal::ecount<const_UINT16_Container>::size(clusterMap))), static_cast<uint32_t>(C6::internal::ecount<DWRITE_SHAPING_TEXT_PROPERTIES_Container>::size(textProps))), C6::internal::ecount<const_UINT16_Container2>::data(glyphIndices), C6::internal::ecount<const_DWRITE_SHAPING_GLYPH_PROPERTIES_Container>::data(glyphProps), (std::min)(static_cast<uint32_t>(C6::internal::ecount<const_UINT16_Container2>::size(glyphIndices)), static_cast<uint32_t>(C6::internal::ecount<const_DWRITE_SHAPING_GLYPH_PROPERTIES_Container>::size(glyphProps))), fontFace.getRawInterface(), fontEmSize, isSideways, isRightToLeft, &scriptAnalysis, localeName, nullptr, nullptr, 0, glyphAdvances.data(), glyphOffsets.data());
        if(FAILED(hr)) throw COMException(hr, "IDWriteTextAnalyzer::GetGlyphPlacements");
        return std::make_tuple(std::move(glyphAdvances), std::move(glyphOffsets));
      }


      template <typename const_wchar_t_Container, typename const_UINT16_Container, typename DWRITE_SHAPING_TEXT_PROPERTIES_Container, typename const_UINT16_Container2, typename const_DWRITE_SHAPING_GLYPH_PROPERTIES_Container, typename const_DWRITE_TYPOGRAPHIC_FEATURES__Container>
      std::tuple<std::vector<float>, std::vector<DWRITE_GLYPH_OFFSET>> getGlyphPlacements(const_wchar_t_Container&& textString, const_UINT16_Container&& clusterMap, DWRITE_SHAPING_TEXT_PROPERTIES_Container&& textProps, const_UINT16_Container2&& glyphIndices, const_DWRITE_SHAPING_GLYPH_PROPERTIES_Container&& glyphProps, DW::FontFace& fontFace, float fontEmSize, BOOL isSideways, BOOL isRightToLeft, const DWRITE_SCRIPT_ANALYSIS& scriptAnalysis, const wchar_t* localeName, const_DWRITE_TYPOGRAPHIC_FEATURES__Container&& features)
      {
        std::vector<float> glyphAdvances(static_cast<size_t>(glyphCount));
        std::vector<DWRITE_GLYPH_OFFSET> glyphOffsets(static_cast<size_t>(glyphCount));
        HRESULT hr = getRawInterface()->GetGlyphPlacements(C6::internal::ecount<const_wchar_t_Container>::data(textString), C6::internal::ecount<const_UINT16_Container>::data(clusterMap), C6::internal::ecount<DWRITE_SHAPING_TEXT_PROPERTIES_Container>::data(textProps), (std::min)((std::min)(static_cast<uint32_t>(C6::internal::ecount<const_wchar_t_Container>::size(textString)), static_cast<uint32_t>(C6::internal::ecount<const_UINT16_Container>::size(clusterMap))), static_cast<uint32_t>(C6::internal::ecount<DWRITE_SHAPING_TEXT_PROPERTIES_Container>::size(textProps))), C6::internal::ecount<const_UINT16_Container2>::data(glyphIndices), C6::internal::ecount<const_DWRITE_SHAPING_GLYPH_PROPERTIES_Container>::data(glyphProps), (std::min)(static_cast<uint32_t>(C6::internal::ecount<const_UINT16_Container2>::size(glyphIndices)), static_cast<uint32_t>(C6::internal::ecount<const_DWRITE_SHAPING_GLYPH_PROPERTIES_Container>::size(glyphProps))), fontFace.getRawInterface(), fontEmSize, isSideways, isRightToLeft, &scriptAnalysis, localeName, C6::internal::ecount<const_DWRITE_TYPOGRAPHIC_FEATURES__Container>::data(features), nullptr, static_cast<uint32_t>(C6::internal::ecount<const_DWRITE_TYPOGRAPHIC_FEATURES__Container>::size(features)), glyphAdvances.data(), glyphOffsets.data());
        if(FAILED(hr)) throw COMException(hr, "IDWriteTextAnalyzer::GetGlyphPlacements");
        return std::make_tuple(std::move(glyphAdvances), std::move(glyphOffsets));
      }


      template <typename const_wchar_t_Container, typename const_UINT16_Container, typename DWRITE_SHAPING_TEXT_PROPERTIES_Container, typename const_UINT16_Container2, typename const_DWRITE_SHAPING_GLYPH_PROPERTIES_Container, typename const_DWRITE_TYPOGRAPHIC_FEATURES__Container, typename const_uint32_t_Container>
      std::tuple<std::vector<float>, std::vector<DWRITE_GLYPH_OFFSET>> getGlyphPlacements(const_wchar_t_Container&& textString, const_UINT16_Container&& clusterMap, DWRITE_SHAPING_TEXT_PROPERTIES_Container&& textProps, const_UINT16_Container2&& glyphIndices, const_DWRITE_SHAPING_GLYPH_PROPERTIES_Container&& glyphProps, DW::FontFace& fontFace, float fontEmSize, BOOL isSideways, BOOL isRightToLeft, const DWRITE_SCRIPT_ANALYSIS& scriptAnalysis, const wchar_t* localeName, const_DWRITE_TYPOGRAPHIC_FEATURES__Container&& features, const_uint32_t_Container&& featureRangeLengths)
      {
        std::vector<float> glyphAdvances(static_cast<size_t>(glyphCount));
        std::vector<DWRITE_GLYPH_OFFSET> glyphOffsets(static_cast<size_t>(glyphCount));
        HRESULT hr = getRawInterface()->GetGlyphPlacements(C6::internal::ecount<const_wchar_t_Container>::data(textString), C6::internal::ecount<const_UINT16_Container>::data(clusterMap), C6::internal::ecount<DWRITE_SHAPING_TEXT_PROPERTIES_Container>::data(textProps), (std::min)((std::min)(static_cast<uint32_t>(C6::internal::ecount<const_wchar_t_Container>::size(textString)), static_cast<uint32_t>(C6::internal::ecount<const_UINT16_Container>::size(clusterMap))), static_cast<uint32_t>(C6::internal::ecount<DWRITE_SHAPING_TEXT_PROPERTIES_Container>::size(textProps))), C6::internal::ecount<const_UINT16_Container2>::data(glyphIndices), C6::internal::ecount<const_DWRITE_SHAPING_GLYPH_PROPERTIES_Container>::data(glyphProps), (std::min)(static_cast<uint32_t>(C6::internal::ecount<const_UINT16_Container2>::size(glyphIndices)), static_cast<uint32_t>(C6::internal::ecount<const_DWRITE_SHAPING_GLYPH_PROPERTIES_Container>::size(glyphProps))), fontFace.getRawInterface(), fontEmSize, isSideways, isRightToLeft, &scriptAnalysis, localeName, C6::internal::ecount<const_DWRITE_TYPOGRAPHIC_FEATURES__Container>::data(features), C6::internal::ecount<const_uint32_t_Container>::data(featureRangeLengths), (std::min)(static_cast<uint32_t>(C6::internal::ecount<const_DWRITE_TYPOGRAPHIC_FEATURES__Container>::size(features)), static_cast<uint32_t>(C6::internal::ecount<const_uint32_t_Container>::size(featureRangeLengths))), glyphAdvances.data(), glyphOffsets.data());
        if(FAILED(hr)) throw COMException(hr, "IDWriteTextAnalyzer::GetGlyphPlacements");
        return std::make_tuple(std::move(glyphAdvances), std::move(glyphOffsets));
      }

    };

    class BitmapRenderTarget : public COMObject
    {
    public:
      // Constructors
      BitmapRenderTarget() {}
      BitmapRenderTarget(nullptr_t) {}
      explicit BitmapRenderTarget(::IDWriteBitmapRenderTarget* raw) : COMObject(raw) {}
      BitmapRenderTarget(const BitmapRenderTarget& copy_from) : COMObject(copy_from) {}
      BitmapRenderTarget(BitmapRenderTarget&& move_from) : COMObject(std::move(move_from)) {}

      // Operators
      inline BitmapRenderTarget& operator= (const BitmapRenderTarget& copy_from) {COMObject::operator=(copy_from); return *this;}
      inline BitmapRenderTarget& operator= (BitmapRenderTarget&& move_from) {COMObject::operator=(std::move(move_from)); return *this;}
      _OPERATOR_BOOL() const {return getRawInterface() ? _CONVERTIBLE_TO_TRUE : 0;}

      // Utilities
      inline ::IDWriteBitmapRenderTarget* getRawInterface() {return static_cast<::IDWriteBitmapRenderTarget*>(COMObject::getRawInterface());}
      inline const ::IDWriteBitmapRenderTarget* getRawInterface() const {return static_cast<const ::IDWriteBitmapRenderTarget*>(COMObject::getRawInterface());}
      inline void swap(BitmapRenderTarget& other) {COMObject::swap(other);}
      typedef ::IDWriteBitmapRenderTarget dumb_t;

      // Methods
      HDC getMemoryDC();
      void resize(uint32_t width, uint32_t height);
      float getPixelsPerDip();
      RECT drawGlyphRun(float baselineOriginX, float baselineOriginY, DWRITE_MEASURING_MODE measuringMode, const DWRITE_GLYPH_RUN& glyphRun, DW::RenderingParams& renderingParams, COLORREF textColor);
      SIZE getSize();
      void setCurrentTransform();
      void setCurrentTransform(const DWRITE_MATRIX& transform);
      void setPixelsPerDip(float pixelsPerDip);
      DWRITE_MATRIX getCurrentTransform();
    };

    class InlineObject : public COMObject
    {
    public:
      // Constructors
      InlineObject() {}
      InlineObject(nullptr_t) {}
      explicit InlineObject(::IDWriteInlineObject* raw) : COMObject(raw) {}
      InlineObject(const InlineObject& copy_from) : COMObject(copy_from) {}
      InlineObject(InlineObject&& move_from) : COMObject(std::move(move_from)) {}

      // Operators
      inline InlineObject& operator= (const InlineObject& copy_from) {COMObject::operator=(copy_from); return *this;}
      inline InlineObject& operator= (InlineObject&& move_from) {COMObject::operator=(std::move(move_from)); return *this;}
      _OPERATOR_BOOL() const {return getRawInterface() ? _CONVERTIBLE_TO_TRUE : 0;}

      // Utilities
      inline ::IDWriteInlineObject* getRawInterface() {return static_cast<::IDWriteInlineObject*>(COMObject::getRawInterface());}
      inline const ::IDWriteInlineObject* getRawInterface() const {return static_cast<const ::IDWriteInlineObject*>(COMObject::getRawInterface());}
      inline void swap(InlineObject& other) {COMObject::swap(other);}
      typedef ::IDWriteInlineObject dumb_t;

      // Methods
      void draw(DW::TextRenderer& renderer, float originX, float originY, BOOL isSideways, BOOL isRightToLeft);
      void draw(void* clientDrawingContext, DW::TextRenderer& renderer, float originX, float originY, BOOL isSideways, BOOL isRightToLeft);
      void draw(void* clientDrawingContext, DW::TextRenderer& renderer, float originX, float originY, BOOL isSideways, BOOL isRightToLeft, COMObject& clientDrawingEffect);
      std::tuple<DWRITE_BREAK_CONDITION, DWRITE_BREAK_CONDITION> getBreakConditions();
      DWRITE_OVERHANG_METRICS getOverhangMetrics();
      DWRITE_INLINE_OBJECT_METRICS getMetrics();
    };

    class FontFileEnumerator : public COMObject
    {
    public:
      // Constructors
      FontFileEnumerator() {}
      FontFileEnumerator(nullptr_t) {}
      explicit FontFileEnumerator(::IDWriteFontFileEnumerator* raw) : COMObject(raw) {}
      FontFileEnumerator(const FontFileEnumerator& copy_from) : COMObject(copy_from) {}
      FontFileEnumerator(FontFileEnumerator&& move_from) : COMObject(std::move(move_from)) {}

      // Operators
      inline FontFileEnumerator& operator= (const FontFileEnumerator& copy_from) {COMObject::operator=(copy_from); return *this;}
      inline FontFileEnumerator& operator= (FontFileEnumerator&& move_from) {COMObject::operator=(std::move(move_from)); return *this;}
      _OPERATOR_BOOL() const {return getRawInterface() ? _CONVERTIBLE_TO_TRUE : 0;}

      // Utilities
      inline ::IDWriteFontFileEnumerator* getRawInterface() {return static_cast<::IDWriteFontFileEnumerator*>(COMObject::getRawInterface());}
      inline const ::IDWriteFontFileEnumerator* getRawInterface() const {return static_cast<const ::IDWriteFontFileEnumerator*>(COMObject::getRawInterface());}
      inline void swap(FontFileEnumerator& other) {COMObject::swap(other);}
      typedef ::IDWriteFontFileEnumerator dumb_t;

      // Methods
      DW::FontFile getCurrentFontFile();
      bool moveNext();
    };

    class FontFileStream : public COMObject
    {
    public:
      // Constructors
      FontFileStream() {}
      FontFileStream(nullptr_t) {}
      explicit FontFileStream(::IDWriteFontFileStream* raw) : COMObject(raw) {}
      FontFileStream(const FontFileStream& copy_from) : COMObject(copy_from) {}
      FontFileStream(FontFileStream&& move_from) : COMObject(std::move(move_from)) {}

      // Operators
      inline FontFileStream& operator= (const FontFileStream& copy_from) {COMObject::operator=(copy_from); return *this;}
      inline FontFileStream& operator= (FontFileStream&& move_from) {COMObject::operator=(std::move(move_from)); return *this;}
      _OPERATOR_BOOL() const {return getRawInterface() ? _CONVERTIBLE_TO_TRUE : 0;}

      // Utilities
      inline ::IDWriteFontFileStream* getRawInterface() {return static_cast<::IDWriteFontFileStream*>(COMObject::getRawInterface());}
      inline const ::IDWriteFontFileStream* getRawInterface() const {return static_cast<const ::IDWriteFontFileStream*>(COMObject::getRawInterface());}
      inline void swap(FontFileStream& other) {COMObject::swap(other);}
      typedef ::IDWriteFontFileStream dumb_t;

      // Methods
      uint64_t getLastWriteTime();
      void releaseFileFragment(void* fragmentContext);
      void* readFileFragment(const void** fragmentStart, uint64_t fileOffset, uint64_t fragmentSize);
      uint64_t getFileSize();
    };

    class Factory : public COMObject
    {
    public:
      // Constructors
      Factory() {}
      Factory(nullptr_t) {}
      explicit Factory(::IDWriteFactory* raw) : COMObject(raw) {}
      Factory(const Factory& copy_from) : COMObject(copy_from) {}
      Factory(Factory&& move_from) : COMObject(std::move(move_from)) {}

      // Operators
      inline Factory& operator= (const Factory& copy_from) {COMObject::operator=(copy_from); return *this;}
      inline Factory& operator= (Factory&& move_from) {COMObject::operator=(std::move(move_from)); return *this;}
      _OPERATOR_BOOL() const {return getRawInterface() ? _CONVERTIBLE_TO_TRUE : 0;}

      // Utilities
      inline ::IDWriteFactory* getRawInterface() {return static_cast<::IDWriteFactory*>(COMObject::getRawInterface());}
      inline const ::IDWriteFactory* getRawInterface() const {return static_cast<const ::IDWriteFactory*>(COMObject::getRawInterface());}
      inline void swap(Factory& other) {COMObject::swap(other);}
      typedef ::IDWriteFactory dumb_t;

      // Methods

      template <typename const_wchar_t_Container>
      typename C6::internal::konst<DW::TextLayout, const_wchar_t_Container>::T createTextLayout(const_wchar_t_Container&& string, DW::TextFormat& textFormat)
      {
        IDWriteTextLayout* textLayout = nullptr;
        HRESULT hr = getRawInterface()->CreateTextLayout(C6::internal::ecount<const_wchar_t_Container>::data(string), static_cast<uint32_t>(C6::internal::ecount<const_wchar_t_Container>::size(string)), textFormat.getRawInterface(), std::numeric_limits<float>::infinity(), std::numeric_limits<float>::infinity(), &textLayout);
        if(FAILED(hr)) throw COMException(hr, "IDWriteFactory::CreateTextLayout");
        return DW::TextLayout(textLayout);
      }


      template <typename const_wchar_t_Container>
      typename C6::internal::konst<DW::TextLayout, const_wchar_t_Container>::T createTextLayout(const_wchar_t_Container&& string, DW::TextFormat& textFormat, float maxWidth)
      {
        IDWriteTextLayout* textLayout = nullptr;
        HRESULT hr = getRawInterface()->CreateTextLayout(C6::internal::ecount<const_wchar_t_Container>::data(string), static_cast<uint32_t>(C6::internal::ecount<const_wchar_t_Container>::size(string)), textFormat.getRawInterface(), maxWidth, std::numeric_limits<float>::infinity(), &textLayout);
        if(FAILED(hr)) throw COMException(hr, "IDWriteFactory::CreateTextLayout");
        return DW::TextLayout(textLayout);
      }


      template <typename const_wchar_t_Container>
      typename C6::internal::konst<DW::TextLayout, const_wchar_t_Container>::T createTextLayout(const_wchar_t_Container&& string, DW::TextFormat& textFormat, float maxWidth, float maxHeight)
      {
        IDWriteTextLayout* textLayout = nullptr;
        HRESULT hr = getRawInterface()->CreateTextLayout(C6::internal::ecount<const_wchar_t_Container>::data(string), static_cast<uint32_t>(C6::internal::ecount<const_wchar_t_Container>::size(string)), textFormat.getRawInterface(), maxWidth, maxHeight, &textLayout);
        if(FAILED(hr)) throw COMException(hr, "IDWriteFactory::CreateTextLayout");
        return DW::TextLayout(textLayout);
      }

      void registerFontCollectionLoader(DW::FontCollectionLoader& fontCollectionLoader);
      void unregisterFontCollectionLoader(DW::FontCollectionLoader& fontCollectionLoader);
      DW::GdiInterop getGdiInterop();
      void registerFontFileLoader(DW::FontFileLoader& fontFileLoader);

      template <typename const_wchar_t_Container>
      typename C6::internal::konst<DW::TextLayout, const_wchar_t_Container>::T createGdiCompatibleTextLayout(const_wchar_t_Container&& string, DW::TextFormat& textFormat, float layoutWidth, float layoutHeight, float pixelsPerDip, BOOL useGdiNatural)
      {
        IDWriteTextLayout* textLayout = nullptr;
        HRESULT hr = getRawInterface()->CreateGdiCompatibleTextLayout(C6::internal::ecount<const_wchar_t_Container>::data(string), static_cast<uint32_t>(C6::internal::ecount<const_wchar_t_Container>::size(string)), textFormat.getRawInterface(), layoutWidth, layoutHeight, pixelsPerDip, nullptr, useGdiNatural, &textLayout);
        if(FAILED(hr)) throw COMException(hr, "IDWriteFactory::CreateGdiCompatibleTextLayout");
        return DW::TextLayout(textLayout);
      }


      template <typename const_wchar_t_Container>
      typename C6::internal::konst<DW::TextLayout, const_wchar_t_Container>::T createGdiCompatibleTextLayout(const_wchar_t_Container&& string, DW::TextFormat& textFormat, float layoutWidth, float layoutHeight, float pixelsPerDip, const DWRITE_MATRIX& transform, BOOL useGdiNatural)
      {
        IDWriteTextLayout* textLayout = nullptr;
        HRESULT hr = getRawInterface()->CreateGdiCompatibleTextLayout(C6::internal::ecount<const_wchar_t_Container>::data(string), static_cast<uint32_t>(C6::internal::ecount<const_wchar_t_Container>::size(string)), textFormat.getRawInterface(), layoutWidth, layoutHeight, pixelsPerDip, &transform, useGdiNatural, &textLayout);
        if(FAILED(hr)) throw COMException(hr, "IDWriteFactory::CreateGdiCompatibleTextLayout");
        return DW::TextLayout(textLayout);
      }

      DW::InlineObject createEllipsisTrimmingSign(DW::TextFormat& textFormat);
      DW::FontFile createFontFileReference(const wchar_t* filePath);
      DW::FontFile createFontFileReference(const wchar_t* filePath, const FILETIME& lastWriteTime);
      void unregisterFontFileLoader(DW::FontFileLoader& fontFileLoader);
      DW::RenderingParams createMonitorRenderingParams(HMONITOR monitor);
      DW::FontCollection createCustomFontCollection(DW::FontCollectionLoader& collectionLoader);

      template <typename const_void_Container>
      typename C6::internal::konst<DW::FontCollection, const_void_Container>::T createCustomFontCollection(DW::FontCollectionLoader& collectionLoader, const_void_Container&& collectionKey)
      {
        IDWriteFontCollection* fontCollection = nullptr;
        HRESULT hr = getRawInterface()->CreateCustomFontCollection(collectionLoader.getRawInterface(), C6::internal::ecount<const_void_Container>::data(collectionKey), static_cast<uint32_t>(C6::internal::ecount<const_void_Container>::size(collectionKey) * C6::internal::bcount<decltype(collectionKey.data())>::elem_size), &fontCollection);
        if(FAILED(hr)) throw COMException(hr, "IDWriteFactory::CreateCustomFontCollection");
        return DW::FontCollection(fontCollection);
      }

      DW::TextAnalyzer createTextAnalyzer();
      DW::FontFile createCustomFontFileReference(DW::FontFileLoader& fontFileLoader);

      template <typename const_void_Container>
      typename C6::internal::konst<DW::FontFile, const_void_Container>::T createCustomFontFileReference(const_void_Container&& fontFileReferenceKey, DW::FontFileLoader& fontFileLoader)
      {
        IDWriteFontFile* fontFile = nullptr;
        HRESULT hr = getRawInterface()->CreateCustomFontFileReference(C6::internal::ecount<const_void_Container>::data(fontFileReferenceKey), static_cast<uint32_t>(C6::internal::ecount<const_void_Container>::size(fontFileReferenceKey) * C6::internal::bcount<decltype(fontFileReferenceKey.data())>::elem_size), fontFileLoader.getRawInterface(), &fontFile);
        if(FAILED(hr)) throw COMException(hr, "IDWriteFactory::CreateCustomFontFileReference");
        return DW::FontFile(fontFile);
      }

      DW::RenderingParams createRenderingParams();
      DW::NumberSubstitution createNumberSubstitution(DWRITE_NUMBER_SUBSTITUTION_METHOD substitutionMethod, const wchar_t* localeName, BOOL ignoreUserOverride);
      DW::Typography createTypography();

      template <typename IDWriteFontFile__const_Container>
      typename C6::internal::konst<DW::FontFace, IDWriteFontFile__const_Container>::T createFontFace(DWRITE_FONT_FACE_TYPE fontFaceType, IDWriteFontFile__const_Container&& fontFiles, uint32_t faceIndex, DWRITE_FONT_SIMULATIONS fontFaceSimulationFlags)
      {
        IDWriteFontFace* fontFace = nullptr;
        HRESULT hr = getRawInterface()->CreateFontFace(fontFaceType, static_cast<uint32_t>(C6::internal::ecount<IDWriteFontFile__const_Container>::size(fontFiles)), C6::internal::ecount<IDWriteFontFile__const_Container>::data(fontFiles), faceIndex, fontFaceSimulationFlags, &fontFace);
        if(FAILED(hr)) throw COMException(hr, "IDWriteFactory::CreateFontFace");
        return DW::FontFace(fontFace);
      }

      DW::TextFormat createTextFormat(const wchar_t* fontFamilyName, DWRITE_FONT_WEIGHT fontWeight, DWRITE_FONT_STYLE fontStyle, DWRITE_FONT_STRETCH fontStretch, float fontSize, const wchar_t* localeName);
      DW::TextFormat createTextFormat(const wchar_t* fontFamilyName, DW::FontCollection& fontCollection, DWRITE_FONT_WEIGHT fontWeight, DWRITE_FONT_STYLE fontStyle, DWRITE_FONT_STRETCH fontStretch, float fontSize, const wchar_t* localeName);
      DW::RenderingParams createCustomRenderingParams(float gamma, float enhancedContrast, float clearTypeLevel, DWRITE_PIXEL_GEOMETRY pixelGeometry, DWRITE_RENDERING_MODE renderingMode);
      DW::FontCollection getSystemFontCollection();
      DW::FontCollection getSystemFontCollection(BOOL checkForUpdates);
      DW::GlyphRunAnalysis createGlyphRunAnalysis(const DWRITE_GLYPH_RUN& glyphRun, float pixelsPerDip, DWRITE_RENDERING_MODE renderingMode, DWRITE_MEASURING_MODE measuringMode, float baselineOriginX, float baselineOriginY);
      DW::GlyphRunAnalysis createGlyphRunAnalysis(const DWRITE_GLYPH_RUN& glyphRun, float pixelsPerDip, const DWRITE_MATRIX& transform, DWRITE_RENDERING_MODE renderingMode, DWRITE_MEASURING_MODE measuringMode, float baselineOriginX, float baselineOriginY);
    };

    class RenderingParams : public COMObject
    {
    public:
      // Constructors
      RenderingParams() {}
      RenderingParams(nullptr_t) {}
      explicit RenderingParams(::IDWriteRenderingParams* raw) : COMObject(raw) {}
      RenderingParams(const RenderingParams& copy_from) : COMObject(copy_from) {}
      RenderingParams(RenderingParams&& move_from) : COMObject(std::move(move_from)) {}

      // Operators
      inline RenderingParams& operator= (const RenderingParams& copy_from) {COMObject::operator=(copy_from); return *this;}
      inline RenderingParams& operator= (RenderingParams&& move_from) {COMObject::operator=(std::move(move_from)); return *this;}
      _OPERATOR_BOOL() const {return getRawInterface() ? _CONVERTIBLE_TO_TRUE : 0;}

      // Utilities
      inline ::IDWriteRenderingParams* getRawInterface() {return static_cast<::IDWriteRenderingParams*>(COMObject::getRawInterface());}
      inline const ::IDWriteRenderingParams* getRawInterface() const {return static_cast<const ::IDWriteRenderingParams*>(COMObject::getRawInterface());}
      inline void swap(RenderingParams& other) {COMObject::swap(other);}
      typedef ::IDWriteRenderingParams dumb_t;

      // Methods
      float getGamma();
      DWRITE_RENDERING_MODE getRenderingMode();
      DWRITE_PIXEL_GEOMETRY getPixelGeometry();
      float getClearTypeLevel();
      float getEnhancedContrast();
    };

    class TextFormat : public COMObject
    {
    public:
      // Constructors
      TextFormat() {}
      TextFormat(nullptr_t) {}
      explicit TextFormat(::IDWriteTextFormat* raw) : COMObject(raw) {}
      TextFormat(const TextFormat& copy_from) : COMObject(copy_from) {}
      TextFormat(TextFormat&& move_from) : COMObject(std::move(move_from)) {}

      // Operators
      inline TextFormat& operator= (const TextFormat& copy_from) {COMObject::operator=(copy_from); return *this;}
      inline TextFormat& operator= (TextFormat&& move_from) {COMObject::operator=(std::move(move_from)); return *this;}
      _OPERATOR_BOOL() const {return getRawInterface() ? _CONVERTIBLE_TO_TRUE : 0;}

      // Utilities
      inline ::IDWriteTextFormat* getRawInterface() {return static_cast<::IDWriteTextFormat*>(COMObject::getRawInterface());}
      inline const ::IDWriteTextFormat* getRawInterface() const {return static_cast<const ::IDWriteTextFormat*>(COMObject::getRawInterface());}
      inline void swap(TextFormat& other) {COMObject::swap(other);}
      typedef ::IDWriteTextFormat dumb_t;

      // Methods
      DWRITE_TEXT_ALIGNMENT getTextAlignment();
      std::vector<wchar_t> getFontFamilyName(uint32_t nameSize);
      DWRITE_FONT_STRETCH getFontStretch();
      void setLineSpacing(DWRITE_LINE_SPACING_METHOD lineSpacingMethod, float lineSpacing, float baseline);
      void setIncrementalTabStop(float incrementalTabStop);
      DWRITE_FLOW_DIRECTION getFlowDirection();
      void setTrimming(const DWRITE_TRIMMING& trimmingOptions, DW::InlineObject& trimmingSign);
      void setReadingDirection(DWRITE_READING_DIRECTION readingDirection);
      void setParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT paragraphAlignment);
      std::vector<wchar_t> getLocaleName(uint32_t nameSize);
      uint32_t getFontFamilyNameLength();
      DWRITE_READING_DIRECTION getReadingDirection();
      DWRITE_WORD_WRAPPING getWordWrapping();
      void setFlowDirection(DWRITE_FLOW_DIRECTION flowDirection);
      std::tuple<DWRITE_TRIMMING, DW::InlineObject> getTrimming();
      uint32_t getLocaleNameLength();
      float getFontSize();
      DWRITE_FONT_STYLE getFontStyle();
      DW::FontCollection getFontCollection();
      DWRITE_FONT_WEIGHT getFontWeight();
      float getIncrementalTabStop();
      std::tuple<DWRITE_LINE_SPACING_METHOD, float, float> getLineSpacing();
      void setTextAlignment(DWRITE_TEXT_ALIGNMENT textAlignment);
      DWRITE_PARAGRAPH_ALIGNMENT getParagraphAlignment();
      void setWordWrapping(DWRITE_WORD_WRAPPING wordWrapping);
    };

    class TextLayout : public DW::TextFormat
    {
    public:
      // Constructors
      TextLayout() {}
      TextLayout(nullptr_t) {}
      explicit TextLayout(::IDWriteTextLayout* raw) : DW::TextFormat(raw) {}
      TextLayout(const TextLayout& copy_from) : DW::TextFormat(copy_from) {}
      TextLayout(TextLayout&& move_from) : DW::TextFormat(std::move(move_from)) {}

      // Operators
      inline TextLayout& operator= (const TextLayout& copy_from) {DW::TextFormat::operator=(copy_from); return *this;}
      inline TextLayout& operator= (TextLayout&& move_from) {DW::TextFormat::operator=(std::move(move_from)); return *this;}
      _OPERATOR_BOOL() const {return getRawInterface() ? _CONVERTIBLE_TO_TRUE : 0;}

      // Utilities
      inline ::IDWriteTextLayout* getRawInterface() {return static_cast<::IDWriteTextLayout*>(DW::TextFormat::getRawInterface());}
      inline const ::IDWriteTextLayout* getRawInterface() const {return static_cast<const ::IDWriteTextLayout*>(DW::TextFormat::getRawInterface());}
      inline void swap(TextLayout& other) {DW::TextFormat::swap(other);}
      typedef ::IDWriteTextLayout dumb_t;

      // Methods
      std::tuple<bool, bool, DWRITE_HIT_TEST_METRICS> hitTestPoint(float pointX, float pointY);
      void setLocaleName(const wchar_t* localeName, DWRITE_TEXT_RANGE textRange);
      std::tuple<DWRITE_FONT_STRETCH, DWRITE_TEXT_RANGE> getFontStretch(uint32_t currentPosition);
      void setUnderline(BOOL hasUnderline, DWRITE_TEXT_RANGE textRange);
      std::tuple<DWRITE_FONT_STYLE, DWRITE_TEXT_RANGE> getFontStyle(uint32_t currentPosition);
      std::tuple<float, float, DWRITE_HIT_TEST_METRICS> hitTestTextPosition(uint32_t textPosition, BOOL isTrailingHit);
      void setFontWeight(DWRITE_FONT_WEIGHT fontWeight, DWRITE_TEXT_RANGE textRange);
      std::tuple<bool, DWRITE_TEXT_RANGE> getUnderline(uint32_t currentPosition);
      std::tuple<DW::InlineObject, DWRITE_TEXT_RANGE> getInlineObject(uint32_t currentPosition);
      std::tuple<std::vector<DWRITE_CLUSTER_METRICS>, uint32_t> getClusterMetrics(uint32_t maxClusterCount);
      void setMaxHeight(float maxHeight);
      std::tuple<std::vector<DWRITE_LINE_METRICS>, uint32_t> getLineMetrics(uint32_t maxLineCount);
      std::tuple<std::vector<wchar_t>, DWRITE_TEXT_RANGE> getFontFamilyName(uint32_t currentPosition, uint32_t nameSize);
      std::tuple<COMObject, DWRITE_TEXT_RANGE> getDrawingEffect(uint32_t currentPosition);
      DWRITE_TEXT_METRICS getMetrics();
      void setInlineObject(DW::InlineObject& inlineObject, DWRITE_TEXT_RANGE textRange);
      void draw(DW::TextRenderer& renderer, float originX, float originY);
      void draw(void* clientDrawingContext, DW::TextRenderer& renderer, float originX, float originY);
      float determineMinWidth();
      DWRITE_OVERHANG_METRICS getOverhangMetrics();
      float getMaxHeight();
      std::tuple<std::vector<DWRITE_HIT_TEST_METRICS>, uint32_t> hitTestTextRange(uint32_t textPosition, uint32_t textLength, float originX, float originY, uint32_t maxHitTestMetricsCount);
      std::tuple<std::vector<wchar_t>, DWRITE_TEXT_RANGE> getLocaleName(uint32_t currentPosition, uint32_t nameSize);
      std::tuple<float, DWRITE_TEXT_RANGE> getFontSize(uint32_t currentPosition);
      void setFontCollection(DW::FontCollection& fontCollection, DWRITE_TEXT_RANGE textRange);
      std::tuple<uint32_t, DWRITE_TEXT_RANGE> getFontFamilyNameLength(uint32_t currentPosition);
      std::tuple<uint32_t, DWRITE_TEXT_RANGE> getLocaleNameLength(uint32_t currentPosition);
      std::tuple<DWRITE_FONT_WEIGHT, DWRITE_TEXT_RANGE> getFontWeight(uint32_t currentPosition);
      std::tuple<DW::Typography, DWRITE_TEXT_RANGE> getTypography(uint32_t currentPosition);
      std::tuple<bool, DWRITE_TEXT_RANGE> getStrikethrough(uint32_t currentPosition);
      void setFontStretch(DWRITE_FONT_STRETCH fontStretch, DWRITE_TEXT_RANGE textRange);
      float getMaxWidth();
      void setFontSize(float fontSize, DWRITE_TEXT_RANGE textRange);
      std::tuple<DW::FontCollection, DWRITE_TEXT_RANGE> getFontCollection(uint32_t currentPosition);
      void setDrawingEffect(COMObject& drawingEffect, DWRITE_TEXT_RANGE textRange);
      void setMaxWidth(float maxWidth);
      void setFontStyle(DWRITE_FONT_STYLE fontStyle, DWRITE_TEXT_RANGE textRange);
      void setStrikethrough(BOOL hasStrikethrough, DWRITE_TEXT_RANGE textRange);
      void setFontFamilyName(const wchar_t* fontFamilyName, DWRITE_TEXT_RANGE textRange);
      void setTypography(DW::Typography& typography, DWRITE_TEXT_RANGE textRange);
    };

    class FontFileLoader : public COMObject
    {
    public:
      // Constructors
      FontFileLoader() {}
      FontFileLoader(nullptr_t) {}
      explicit FontFileLoader(::IDWriteFontFileLoader* raw) : COMObject(raw) {}
      FontFileLoader(const FontFileLoader& copy_from) : COMObject(copy_from) {}
      FontFileLoader(FontFileLoader&& move_from) : COMObject(std::move(move_from)) {}

      // Operators
      inline FontFileLoader& operator= (const FontFileLoader& copy_from) {COMObject::operator=(copy_from); return *this;}
      inline FontFileLoader& operator= (FontFileLoader&& move_from) {COMObject::operator=(std::move(move_from)); return *this;}
      _OPERATOR_BOOL() const {return getRawInterface() ? _CONVERTIBLE_TO_TRUE : 0;}

      // Utilities
      inline ::IDWriteFontFileLoader* getRawInterface() {return static_cast<::IDWriteFontFileLoader*>(COMObject::getRawInterface());}
      inline const ::IDWriteFontFileLoader* getRawInterface() const {return static_cast<const ::IDWriteFontFileLoader*>(COMObject::getRawInterface());}
      inline void swap(FontFileLoader& other) {COMObject::swap(other);}
      typedef ::IDWriteFontFileLoader dumb_t;

      // Methods
      DW::FontFileStream createStreamFromKey();

      template <typename const_void_Container>
      typename C6::internal::konst<DW::FontFileStream, const_void_Container>::T createStreamFromKey(const_void_Container&& fontFileReferenceKey)
      {
        IDWriteFontFileStream* fontFileStream = nullptr;
        HRESULT hr = getRawInterface()->CreateStreamFromKey(C6::internal::ecount<const_void_Container>::data(fontFileReferenceKey), static_cast<uint32_t>(C6::internal::ecount<const_void_Container>::size(fontFileReferenceKey) * C6::internal::bcount<decltype(fontFileReferenceKey.data())>::elem_size), &fontFileStream);
        if(FAILED(hr)) throw COMException(hr, "IDWriteFontFileLoader::CreateStreamFromKey");
        return DW::FontFileStream(fontFileStream);
      }

    };

    class LocalFontFileLoader : public DW::FontFileLoader
    {
    public:
      // Constructors
      LocalFontFileLoader() {}
      LocalFontFileLoader(nullptr_t) {}
      explicit LocalFontFileLoader(::IDWriteLocalFontFileLoader* raw) : DW::FontFileLoader(raw) {}
      LocalFontFileLoader(const LocalFontFileLoader& copy_from) : DW::FontFileLoader(copy_from) {}
      LocalFontFileLoader(LocalFontFileLoader&& move_from) : DW::FontFileLoader(std::move(move_from)) {}

      // Operators
      inline LocalFontFileLoader& operator= (const LocalFontFileLoader& copy_from) {DW::FontFileLoader::operator=(copy_from); return *this;}
      inline LocalFontFileLoader& operator= (LocalFontFileLoader&& move_from) {DW::FontFileLoader::operator=(std::move(move_from)); return *this;}
      _OPERATOR_BOOL() const {return getRawInterface() ? _CONVERTIBLE_TO_TRUE : 0;}

      // Utilities
      inline ::IDWriteLocalFontFileLoader* getRawInterface() {return static_cast<::IDWriteLocalFontFileLoader*>(DW::FontFileLoader::getRawInterface());}
      inline const ::IDWriteLocalFontFileLoader* getRawInterface() const {return static_cast<const ::IDWriteLocalFontFileLoader*>(DW::FontFileLoader::getRawInterface());}
      inline void swap(LocalFontFileLoader& other) {DW::FontFileLoader::swap(other);}
      typedef ::IDWriteLocalFontFileLoader dumb_t;

      // Methods
      std::vector<wchar_t> getFilePathFromKey(uint32_t filePathSize);

      template <typename const_void_Container>
      std::vector<wchar_t> getFilePathFromKey(const_void_Container&& fontFileReferenceKey, uint32_t filePathSize)
      {
        std::vector<wchar_t> filePath(static_cast<size_t>(filePathSize));
        HRESULT hr = getRawInterface()->GetFilePathFromKey(C6::internal::ecount<const_void_Container>::data(fontFileReferenceKey), static_cast<uint32_t>(C6::internal::ecount<const_void_Container>::size(fontFileReferenceKey) * C6::internal::bcount<decltype(fontFileReferenceKey.data())>::elem_size), filePath.data(), filePathSize);
        if(FAILED(hr)) throw COMException(hr, "IDWriteLocalFontFileLoader::GetFilePathFromKey");
        return filePath;
      }

      FILETIME getLastWriteTimeFromKey();

      template <typename const_void_Container>
      FILETIME getLastWriteTimeFromKey(const_void_Container&& fontFileReferenceKey)
      {
        FILETIME lastWriteTime = FILETIME();
        HRESULT hr = getRawInterface()->GetLastWriteTimeFromKey(C6::internal::ecount<const_void_Container>::data(fontFileReferenceKey), static_cast<uint32_t>(C6::internal::ecount<const_void_Container>::size(fontFileReferenceKey) * C6::internal::bcount<decltype(fontFileReferenceKey.data())>::elem_size), &lastWriteTime);
        if(FAILED(hr)) throw COMException(hr, "IDWriteLocalFontFileLoader::GetLastWriteTimeFromKey");
        return lastWriteTime;
      }

      uint32_t getFilePathLengthFromKey();

      template <typename const_void_Container>
      uint32_t getFilePathLengthFromKey(const_void_Container&& fontFileReferenceKey)
      {
        uint32_t filePathLength = uint32_t();
        HRESULT hr = getRawInterface()->GetFilePathLengthFromKey(C6::internal::ecount<const_void_Container>::data(fontFileReferenceKey), static_cast<uint32_t>(C6::internal::ecount<const_void_Container>::size(fontFileReferenceKey) * C6::internal::bcount<decltype(fontFileReferenceKey.data())>::elem_size), &filePathLength);
        if(FAILED(hr)) throw COMException(hr, "IDWriteLocalFontFileLoader::GetFilePathLengthFromKey");
        return filePathLength;
      }

    };

    class Font : public COMObject
    {
    public:
      // Constructors
      Font() {}
      Font(nullptr_t) {}
      explicit Font(::IDWriteFont* raw) : COMObject(raw) {}
      Font(const Font& copy_from) : COMObject(copy_from) {}
      Font(Font&& move_from) : COMObject(std::move(move_from)) {}

      // Operators
      inline Font& operator= (const Font& copy_from) {COMObject::operator=(copy_from); return *this;}
      inline Font& operator= (Font&& move_from) {COMObject::operator=(std::move(move_from)); return *this;}
      _OPERATOR_BOOL() const {return getRawInterface() ? _CONVERTIBLE_TO_TRUE : 0;}

      // Utilities
      inline ::IDWriteFont* getRawInterface() {return static_cast<::IDWriteFont*>(COMObject::getRawInterface());}
      inline const ::IDWriteFont* getRawInterface() const {return static_cast<const ::IDWriteFont*>(COMObject::getRawInterface());}
      inline void swap(Font& other) {COMObject::swap(other);}
      typedef ::IDWriteFont dumb_t;

      // Methods
      DWRITE_FONT_STYLE getStyle();
      DW::LocalizedStrings getFaceNames();
      DWRITE_FONT_STRETCH getStretch();
      BOOL isSymbolFont();
      DWRITE_FONT_SIMULATIONS getSimulations();
      bool hasCharacter(uint32_t unicodeValue);
      DWRITE_FONT_WEIGHT getWeight();
      DW::FontFamily getFontFamily();
      std::tuple<DW::LocalizedStrings, bool> getInformationalStrings(DWRITE_INFORMATIONAL_STRING_ID informationalStringID);
      DW::FontFace createFontFace();
      DWRITE_FONT_METRICS getMetrics();
    };

    class Typography : public COMObject
    {
    public:
      // Constructors
      Typography() {}
      Typography(nullptr_t) {}
      explicit Typography(::IDWriteTypography* raw) : COMObject(raw) {}
      Typography(const Typography& copy_from) : COMObject(copy_from) {}
      Typography(Typography&& move_from) : COMObject(std::move(move_from)) {}

      // Operators
      inline Typography& operator= (const Typography& copy_from) {COMObject::operator=(copy_from); return *this;}
      inline Typography& operator= (Typography&& move_from) {COMObject::operator=(std::move(move_from)); return *this;}
      _OPERATOR_BOOL() const {return getRawInterface() ? _CONVERTIBLE_TO_TRUE : 0;}

      // Utilities
      inline ::IDWriteTypography* getRawInterface() {return static_cast<::IDWriteTypography*>(COMObject::getRawInterface());}
      inline const ::IDWriteTypography* getRawInterface() const {return static_cast<const ::IDWriteTypography*>(COMObject::getRawInterface());}
      inline void swap(Typography& other) {COMObject::swap(other);}
      typedef ::IDWriteTypography dumb_t;

      // Methods
      void addFontFeature(DWRITE_FONT_FEATURE fontFeature);
      uint32_t getFontFeatureCount();
      DWRITE_FONT_FEATURE getFontFeature(uint32_t fontFeatureIndex);
    };

    class TextAnalysisSource : public COMObject
    {
    public:
      // Constructors
      TextAnalysisSource() {}
      TextAnalysisSource(nullptr_t) {}
      explicit TextAnalysisSource(::IDWriteTextAnalysisSource* raw) : COMObject(raw) {}
      TextAnalysisSource(const TextAnalysisSource& copy_from) : COMObject(copy_from) {}
      TextAnalysisSource(TextAnalysisSource&& move_from) : COMObject(std::move(move_from)) {}

      // Operators
      inline TextAnalysisSource& operator= (const TextAnalysisSource& copy_from) {COMObject::operator=(copy_from); return *this;}
      inline TextAnalysisSource& operator= (TextAnalysisSource&& move_from) {COMObject::operator=(std::move(move_from)); return *this;}
      _OPERATOR_BOOL() const {return getRawInterface() ? _CONVERTIBLE_TO_TRUE : 0;}

      // Utilities
      inline ::IDWriteTextAnalysisSource* getRawInterface() {return static_cast<::IDWriteTextAnalysisSource*>(COMObject::getRawInterface());}
      inline const ::IDWriteTextAnalysisSource* getRawInterface() const {return static_cast<const ::IDWriteTextAnalysisSource*>(COMObject::getRawInterface());}
      inline void swap(TextAnalysisSource& other) {COMObject::swap(other);}
      typedef ::IDWriteTextAnalysisSource dumb_t;

      // Methods
      std::tuple<uint32_t, DW::NumberSubstitution> getNumberSubstitution(uint32_t textPosition);
      std::tuple<const wchar_t*, uint32_t> getTextAtPosition(uint32_t textPosition);
      std::tuple<const wchar_t*, uint32_t> getTextBeforePosition(uint32_t textPosition);
      DWRITE_READING_DIRECTION getParagraphReadingDirection();
      std::tuple<uint32_t, const wchar_t*> getLocaleName(uint32_t textPosition);
    };

    class PixelSnapping : public COMObject
    {
    public:
      // Constructors
      PixelSnapping() {}
      PixelSnapping(nullptr_t) {}
      explicit PixelSnapping(::IDWritePixelSnapping* raw) : COMObject(raw) {}
      PixelSnapping(const PixelSnapping& copy_from) : COMObject(copy_from) {}
      PixelSnapping(PixelSnapping&& move_from) : COMObject(std::move(move_from)) {}

      // Operators
      inline PixelSnapping& operator= (const PixelSnapping& copy_from) {COMObject::operator=(copy_from); return *this;}
      inline PixelSnapping& operator= (PixelSnapping&& move_from) {COMObject::operator=(std::move(move_from)); return *this;}
      _OPERATOR_BOOL() const {return getRawInterface() ? _CONVERTIBLE_TO_TRUE : 0;}

      // Utilities
      inline ::IDWritePixelSnapping* getRawInterface() {return static_cast<::IDWritePixelSnapping*>(COMObject::getRawInterface());}
      inline const ::IDWritePixelSnapping* getRawInterface() const {return static_cast<const ::IDWritePixelSnapping*>(COMObject::getRawInterface());}
      inline void swap(PixelSnapping& other) {COMObject::swap(other);}
      typedef ::IDWritePixelSnapping dumb_t;

      // Methods
      bool isPixelSnappingDisabled();
      bool isPixelSnappingDisabled(void* clientDrawingContext);
      DWRITE_MATRIX getCurrentTransform();
      DWRITE_MATRIX getCurrentTransform(void* clientDrawingContext);
      float getPixelsPerDip();
      float getPixelsPerDip(void* clientDrawingContext);
    };

    class TextRenderer : public DW::PixelSnapping
    {
    public:
      // Constructors
      TextRenderer() {}
      TextRenderer(nullptr_t) {}
      explicit TextRenderer(::IDWriteTextRenderer* raw) : DW::PixelSnapping(raw) {}
      TextRenderer(const TextRenderer& copy_from) : DW::PixelSnapping(copy_from) {}
      TextRenderer(TextRenderer&& move_from) : DW::PixelSnapping(std::move(move_from)) {}

      // Operators
      inline TextRenderer& operator= (const TextRenderer& copy_from) {DW::PixelSnapping::operator=(copy_from); return *this;}
      inline TextRenderer& operator= (TextRenderer&& move_from) {DW::PixelSnapping::operator=(std::move(move_from)); return *this;}
      _OPERATOR_BOOL() const {return getRawInterface() ? _CONVERTIBLE_TO_TRUE : 0;}

      // Utilities
      inline ::IDWriteTextRenderer* getRawInterface() {return static_cast<::IDWriteTextRenderer*>(DW::PixelSnapping::getRawInterface());}
      inline const ::IDWriteTextRenderer* getRawInterface() const {return static_cast<const ::IDWriteTextRenderer*>(DW::PixelSnapping::getRawInterface());}
      inline void swap(TextRenderer& other) {DW::PixelSnapping::swap(other);}
      typedef ::IDWriteTextRenderer dumb_t;

      // Methods
      void drawStrikethrough(float baselineOriginX, float baselineOriginY, const DWRITE_STRIKETHROUGH& strikethrough);
      void drawStrikethrough(void* clientDrawingContext, float baselineOriginX, float baselineOriginY, const DWRITE_STRIKETHROUGH& strikethrough);
      void drawStrikethrough(void* clientDrawingContext, float baselineOriginX, float baselineOriginY, const DWRITE_STRIKETHROUGH& strikethrough, COMObject& clientDrawingEffect);
      void drawInlineObject(float originX, float originY, DW::InlineObject& inlineObject, BOOL isSideways, BOOL isRightToLeft);
      void drawInlineObject(void* clientDrawingContext, float originX, float originY, DW::InlineObject& inlineObject, BOOL isSideways, BOOL isRightToLeft);
      void drawInlineObject(void* clientDrawingContext, float originX, float originY, DW::InlineObject& inlineObject, BOOL isSideways, BOOL isRightToLeft, COMObject& clientDrawingEffect);
      void drawUnderline(float baselineOriginX, float baselineOriginY, const DWRITE_UNDERLINE& underline);
      void drawUnderline(void* clientDrawingContext, float baselineOriginX, float baselineOriginY, const DWRITE_UNDERLINE& underline);
      void drawUnderline(void* clientDrawingContext, float baselineOriginX, float baselineOriginY, const DWRITE_UNDERLINE& underline, COMObject& clientDrawingEffect);
      void drawGlyphRun(float baselineOriginX, float baselineOriginY, DWRITE_MEASURING_MODE measuringMode, const DWRITE_GLYPH_RUN& glyphRun, const DWRITE_GLYPH_RUN_DESCRIPTION& glyphRunDescription);
      void drawGlyphRun(void* clientDrawingContext, float baselineOriginX, float baselineOriginY, DWRITE_MEASURING_MODE measuringMode, const DWRITE_GLYPH_RUN& glyphRun, const DWRITE_GLYPH_RUN_DESCRIPTION& glyphRunDescription);
      void drawGlyphRun(void* clientDrawingContext, float baselineOriginX, float baselineOriginY, DWRITE_MEASURING_MODE measuringMode, const DWRITE_GLYPH_RUN& glyphRun, const DWRITE_GLYPH_RUN_DESCRIPTION& glyphRunDescription, COMObject& clientDrawingEffect);
    };

    class FontCollectionLoader : public COMObject
    {
    public:
      // Constructors
      FontCollectionLoader() {}
      FontCollectionLoader(nullptr_t) {}
      explicit FontCollectionLoader(::IDWriteFontCollectionLoader* raw) : COMObject(raw) {}
      FontCollectionLoader(const FontCollectionLoader& copy_from) : COMObject(copy_from) {}
      FontCollectionLoader(FontCollectionLoader&& move_from) : COMObject(std::move(move_from)) {}

      // Operators
      inline FontCollectionLoader& operator= (const FontCollectionLoader& copy_from) {COMObject::operator=(copy_from); return *this;}
      inline FontCollectionLoader& operator= (FontCollectionLoader&& move_from) {COMObject::operator=(std::move(move_from)); return *this;}
      _OPERATOR_BOOL() const {return getRawInterface() ? _CONVERTIBLE_TO_TRUE : 0;}

      // Utilities
      inline ::IDWriteFontCollectionLoader* getRawInterface() {return static_cast<::IDWriteFontCollectionLoader*>(COMObject::getRawInterface());}
      inline const ::IDWriteFontCollectionLoader* getRawInterface() const {return static_cast<const ::IDWriteFontCollectionLoader*>(COMObject::getRawInterface());}
      inline void swap(FontCollectionLoader& other) {COMObject::swap(other);}
      typedef ::IDWriteFontCollectionLoader dumb_t;

      // Methods
      DW::FontFileEnumerator createEnumeratorFromKey(DW::Factory& factory);

      template <typename const_void_Container>
      typename C6::internal::konst<DW::FontFileEnumerator, const_void_Container>::T createEnumeratorFromKey(DW::Factory& factory, const_void_Container&& collectionKey)
      {
        IDWriteFontFileEnumerator* fontFileEnumerator = nullptr;
        HRESULT hr = getRawInterface()->CreateEnumeratorFromKey(factory.getRawInterface(), C6::internal::ecount<const_void_Container>::data(collectionKey), static_cast<uint32_t>(C6::internal::ecount<const_void_Container>::size(collectionKey) * C6::internal::bcount<decltype(collectionKey.data())>::elem_size), &fontFileEnumerator);
        if(FAILED(hr)) throw COMException(hr, "IDWriteFontCollectionLoader::CreateEnumeratorFromKey");
        return DW::FontFileEnumerator(fontFileEnumerator);
      }

    };

    class TextAnalysisSink : public COMObject
    {
    public:
      // Constructors
      TextAnalysisSink() {}
      TextAnalysisSink(nullptr_t) {}
      explicit TextAnalysisSink(::IDWriteTextAnalysisSink* raw) : COMObject(raw) {}
      TextAnalysisSink(const TextAnalysisSink& copy_from) : COMObject(copy_from) {}
      TextAnalysisSink(TextAnalysisSink&& move_from) : COMObject(std::move(move_from)) {}

      // Operators
      inline TextAnalysisSink& operator= (const TextAnalysisSink& copy_from) {COMObject::operator=(copy_from); return *this;}
      inline TextAnalysisSink& operator= (TextAnalysisSink&& move_from) {COMObject::operator=(std::move(move_from)); return *this;}
      _OPERATOR_BOOL() const {return getRawInterface() ? _CONVERTIBLE_TO_TRUE : 0;}

      // Utilities
      inline ::IDWriteTextAnalysisSink* getRawInterface() {return static_cast<::IDWriteTextAnalysisSink*>(COMObject::getRawInterface());}
      inline const ::IDWriteTextAnalysisSink* getRawInterface() const {return static_cast<const ::IDWriteTextAnalysisSink*>(COMObject::getRawInterface());}
      inline void swap(TextAnalysisSink& other) {COMObject::swap(other);}
      typedef ::IDWriteTextAnalysisSink dumb_t;

      // Methods
      void setNumberSubstitution(uint32_t textPosition, uint32_t textLength, DW::NumberSubstitution& numberSubstitution);
      void setBidiLevel(uint32_t textPosition, uint32_t textLength, UINT8 explicitLevel, UINT8 resolvedLevel);
      void setScriptAnalysis(uint32_t textPosition, uint32_t textLength, const DWRITE_SCRIPT_ANALYSIS& scriptAnalysis);

      template <typename const_DWRITE_LINE_BREAKPOINT_Container>
      void setLineBreakpoints(uint32_t textPosition, const_DWRITE_LINE_BREAKPOINT_Container&& lineBreakpoints)
      {
        HRESULT hr = getRawInterface()->SetLineBreakpoints(textPosition, static_cast<uint32_t>(C6::internal::ecount<const_DWRITE_LINE_BREAKPOINT_Container>::size(lineBreakpoints)), C6::internal::ecount<const_DWRITE_LINE_BREAKPOINT_Container>::data(lineBreakpoints));
        if(FAILED(hr)) throw COMException(hr, "IDWriteTextAnalysisSink::SetLineBreakpoints");
      }

    };

    class FontFile : public COMObject
    {
    public:
      // Constructors
      FontFile() {}
      FontFile(nullptr_t) {}
      explicit FontFile(::IDWriteFontFile* raw) : COMObject(raw) {}
      FontFile(const FontFile& copy_from) : COMObject(copy_from) {}
      FontFile(FontFile&& move_from) : COMObject(std::move(move_from)) {}

      // Operators
      inline FontFile& operator= (const FontFile& copy_from) {COMObject::operator=(copy_from); return *this;}
      inline FontFile& operator= (FontFile&& move_from) {COMObject::operator=(std::move(move_from)); return *this;}
      _OPERATOR_BOOL() const {return getRawInterface() ? _CONVERTIBLE_TO_TRUE : 0;}

      // Utilities
      inline ::IDWriteFontFile* getRawInterface() {return static_cast<::IDWriteFontFile*>(COMObject::getRawInterface());}
      inline const ::IDWriteFontFile* getRawInterface() const {return static_cast<const ::IDWriteFontFile*>(COMObject::getRawInterface());}
      inline void swap(FontFile& other) {COMObject::swap(other);}
      typedef ::IDWriteFontFile dumb_t;

      // Methods
      DW::FontFileLoader getLoader();
      uint32_t getReferenceKey(const void** fontFileReferenceKey);
      std::tuple<bool, DWRITE_FONT_FILE_TYPE, DWRITE_FONT_FACE_TYPE, uint32_t> analyze();
    };

    class NumberSubstitution : public COMObject
    {
    public:
      // Constructors
      NumberSubstitution() {}
      NumberSubstitution(nullptr_t) {}
      explicit NumberSubstitution(::IDWriteNumberSubstitution* raw) : COMObject(raw) {}
      NumberSubstitution(const NumberSubstitution& copy_from) : COMObject(copy_from) {}
      NumberSubstitution(NumberSubstitution&& move_from) : COMObject(std::move(move_from)) {}

      // Operators
      inline NumberSubstitution& operator= (const NumberSubstitution& copy_from) {COMObject::operator=(copy_from); return *this;}
      inline NumberSubstitution& operator= (NumberSubstitution&& move_from) {COMObject::operator=(std::move(move_from)); return *this;}
      _OPERATOR_BOOL() const {return getRawInterface() ? _CONVERTIBLE_TO_TRUE : 0;}

      // Utilities
      inline ::IDWriteNumberSubstitution* getRawInterface() {return static_cast<::IDWriteNumberSubstitution*>(COMObject::getRawInterface());}
      inline const ::IDWriteNumberSubstitution* getRawInterface() const {return static_cast<const ::IDWriteNumberSubstitution*>(COMObject::getRawInterface());}
      inline void swap(NumberSubstitution& other) {COMObject::swap(other);}
      typedef ::IDWriteNumberSubstitution dumb_t;

      // Methods
    };

    class FontFace : public COMObject
    {
    public:
      // Constructors
      FontFace() {}
      FontFace(nullptr_t) {}
      explicit FontFace(::IDWriteFontFace* raw) : COMObject(raw) {}
      FontFace(const FontFace& copy_from) : COMObject(copy_from) {}
      FontFace(FontFace&& move_from) : COMObject(std::move(move_from)) {}

      // Operators
      inline FontFace& operator= (const FontFace& copy_from) {COMObject::operator=(copy_from); return *this;}
      inline FontFace& operator= (FontFace&& move_from) {COMObject::operator=(std::move(move_from)); return *this;}
      _OPERATOR_BOOL() const {return getRawInterface() ? _CONVERTIBLE_TO_TRUE : 0;}

      // Utilities
      inline ::IDWriteFontFace* getRawInterface() {return static_cast<::IDWriteFontFace*>(COMObject::getRawInterface());}
      inline const ::IDWriteFontFace* getRawInterface() const {return static_cast<const ::IDWriteFontFace*>(COMObject::getRawInterface());}
      inline void swap(FontFace& other) {COMObject::swap(other);}
      typedef ::IDWriteFontFace dumb_t;

      // Methods

      template <typename const_UINT16_Container>
      void getGlyphRunOutline(float emSize, const_UINT16_Container&& glyphIndices, BOOL isSideways, BOOL isRightToLeft, IDWriteGeometrySink* geometrySink)
      {
        HRESULT hr = getRawInterface()->GetGlyphRunOutline(emSize, C6::internal::ecount<const_UINT16_Container>::data(glyphIndices), nullptr, nullptr, static_cast<uint32_t>(C6::internal::ecount<const_UINT16_Container>::size(glyphIndices)), isSideways, isRightToLeft, geometrySink);
        if(FAILED(hr)) throw COMException(hr, "IDWriteFontFace::GetGlyphRunOutline");
      }


      template <typename const_UINT16_Container, typename const_float_Container>
      void getGlyphRunOutline(float emSize, const_UINT16_Container&& glyphIndices, const_float_Container&& glyphAdvances, BOOL isSideways, BOOL isRightToLeft, IDWriteGeometrySink* geometrySink)
      {
        HRESULT hr = getRawInterface()->GetGlyphRunOutline(emSize, C6::internal::ecount<const_UINT16_Container>::data(glyphIndices), C6::internal::ecount<const_float_Container>::data(glyphAdvances), nullptr, (std::min)(static_cast<uint32_t>(C6::internal::ecount<const_UINT16_Container>::size(glyphIndices)), static_cast<uint32_t>(C6::internal::ecount<const_float_Container>::size(glyphAdvances))), isSideways, isRightToLeft, geometrySink);
        if(FAILED(hr)) throw COMException(hr, "IDWriteFontFace::GetGlyphRunOutline");
      }


      template <typename const_UINT16_Container, typename const_float_Container, typename const_DWRITE_GLYPH_OFFSET_Container>
      void getGlyphRunOutline(float emSize, const_UINT16_Container&& glyphIndices, const_float_Container&& glyphAdvances, const_DWRITE_GLYPH_OFFSET_Container&& glyphOffsets, BOOL isSideways, BOOL isRightToLeft, IDWriteGeometrySink* geometrySink)
      {
        HRESULT hr = getRawInterface()->GetGlyphRunOutline(emSize, C6::internal::ecount<const_UINT16_Container>::data(glyphIndices), C6::internal::ecount<const_float_Container>::data(glyphAdvances), C6::internal::ecount<const_DWRITE_GLYPH_OFFSET_Container>::data(glyphOffsets), (std::min)((std::min)(static_cast<uint32_t>(C6::internal::ecount<const_UINT16_Container>::size(glyphIndices)), static_cast<uint32_t>(C6::internal::ecount<const_float_Container>::size(glyphAdvances))), static_cast<uint32_t>(C6::internal::ecount<const_DWRITE_GLYPH_OFFSET_Container>::size(glyphOffsets))), isSideways, isRightToLeft, geometrySink);
        if(FAILED(hr)) throw COMException(hr, "IDWriteFontFace::GetGlyphRunOutline");
      }

      std::vector<IDWriteFontFile*> getFiles(uint32_t* numberOfFiles);

      template <typename const_UINT16_Container>
      std::vector<DWRITE_GLYPH_METRICS> getGdiCompatibleGlyphMetrics(float emSize, float pixelsPerDip, BOOL useGdiNatural, const_UINT16_Container&& glyphIndices)
      {
        std::vector<DWRITE_GLYPH_METRICS> glyphMetrics(static_cast<size_t>(glyphCount));
        HRESULT hr = getRawInterface()->GetGdiCompatibleGlyphMetrics(emSize, pixelsPerDip, nullptr, useGdiNatural, C6::internal::ecount<const_UINT16_Container>::data(glyphIndices), static_cast<uint32_t>(C6::internal::ecount<const_UINT16_Container>::size(glyphIndices)), glyphMetrics.data(), FALSE);
        if(FAILED(hr)) throw COMException(hr, "IDWriteFontFace::GetGdiCompatibleGlyphMetrics");
        return glyphMetrics;
      }


      template <typename const_UINT16_Container>
      std::vector<DWRITE_GLYPH_METRICS> getGdiCompatibleGlyphMetrics(float emSize, float pixelsPerDip, const DWRITE_MATRIX& transform, BOOL useGdiNatural, const_UINT16_Container&& glyphIndices)
      {
        std::vector<DWRITE_GLYPH_METRICS> glyphMetrics(static_cast<size_t>(glyphCount));
        HRESULT hr = getRawInterface()->GetGdiCompatibleGlyphMetrics(emSize, pixelsPerDip, &transform, useGdiNatural, C6::internal::ecount<const_UINT16_Container>::data(glyphIndices), static_cast<uint32_t>(C6::internal::ecount<const_UINT16_Container>::size(glyphIndices)), glyphMetrics.data(), FALSE);
        if(FAILED(hr)) throw COMException(hr, "IDWriteFontFace::GetGdiCompatibleGlyphMetrics");
        return glyphMetrics;
      }


      template <typename const_UINT16_Container>
      std::vector<DWRITE_GLYPH_METRICS> getGdiCompatibleGlyphMetrics(float emSize, float pixelsPerDip, const DWRITE_MATRIX& transform, BOOL useGdiNatural, const_UINT16_Container&& glyphIndices, BOOL isSideways)
      {
        std::vector<DWRITE_GLYPH_METRICS> glyphMetrics(static_cast<size_t>(glyphCount));
        HRESULT hr = getRawInterface()->GetGdiCompatibleGlyphMetrics(emSize, pixelsPerDip, &transform, useGdiNatural, C6::internal::ecount<const_UINT16_Container>::data(glyphIndices), static_cast<uint32_t>(C6::internal::ecount<const_UINT16_Container>::size(glyphIndices)), glyphMetrics.data(), isSideways);
        if(FAILED(hr)) throw COMException(hr, "IDWriteFontFace::GetGdiCompatibleGlyphMetrics");
        return glyphMetrics;
      }

      DWRITE_FONT_METRICS getMetrics();

      template <typename const_UINT16_Container>
      std::vector<DWRITE_GLYPH_METRICS> getDesignGlyphMetrics(const_UINT16_Container&& glyphIndices)
      {
        auto glyphCount = C6::internal::ecount<const_UINT16_Container>::size(glyphIndices);
        std::vector<DWRITE_GLYPH_METRICS> glyphMetrics(static_cast<size_t>(glyphCount));
        HRESULT hr = getRawInterface()->GetDesignGlyphMetrics(C6::internal::ecount<const_UINT16_Container>::data(glyphIndices), static_cast<uint32_t>(glyphCount), glyphMetrics.data(), FALSE);
        if(FAILED(hr)) throw COMException(hr, "IDWriteFontFace::GetDesignGlyphMetrics");
        return glyphMetrics;
      }


      template <typename const_UINT16_Container>
      std::vector<DWRITE_GLYPH_METRICS> getDesignGlyphMetrics(const_UINT16_Container&& glyphIndices, BOOL isSideways)
      {
        auto glyphCount = C6::internal::ecount<const_UINT16_Container>::size(glyphIndices);
        std::vector<DWRITE_GLYPH_METRICS> glyphMetrics(static_cast<size_t>(glyphCount));
        HRESULT hr = getRawInterface()->GetDesignGlyphMetrics(C6::internal::ecount<const_UINT16_Container>::data(glyphIndices), static_cast<uint32_t>(glyphCount), glyphMetrics.data(), isSideways);
        if(FAILED(hr)) throw COMException(hr, "IDWriteFontFace::GetDesignGlyphMetrics");
        return glyphMetrics;
      }

      BOOL isSymbolFont();
      uint32_t getIndex();
      DWRITE_RENDERING_MODE getRecommendedRenderingMode(float emSize, float pixelsPerDip, DWRITE_MEASURING_MODE measuringMode, DW::RenderingParams& renderingParams);
      void releaseFontTable(void* tableContext);

      template <typename const_uint32_t_Container>
      std::vector<UINT16> getGlyphIndices(const_uint32_t_Container&& codePoints)
      {
        auto codePointCount = C6::internal::ecount<const_uint32_t_Container>::size(codePoints);
        std::vector<UINT16> glyphIndices(static_cast<size_t>(codePointCount));
        HRESULT hr = getRawInterface()->GetGlyphIndices(C6::internal::ecount<const_uint32_t_Container>::data(codePoints), static_cast<uint32_t>(codePointCount), glyphIndices.data());
        if(FAILED(hr)) throw COMException(hr, "IDWriteFontFace::GetGlyphIndices");
        return glyphIndices;
      }

      DWRITE_FONT_FACE_TYPE getType();
      std::tuple<uint32_t, void*, bool> tryGetFontTable(uint32_t openTypeTableTag, const void** tableData);
      DWRITE_FONT_SIMULATIONS getSimulations();
      UINT16 getGlyphCount();
      DWRITE_FONT_METRICS getGdiCompatibleMetrics(float emSize, float pixelsPerDip);
      DWRITE_FONT_METRICS getGdiCompatibleMetrics(float emSize, float pixelsPerDip, const DWRITE_MATRIX& transform);
    };

    class GdiInterop : public COMObject
    {
    public:
      // Constructors
      GdiInterop() {}
      GdiInterop(nullptr_t) {}
      explicit GdiInterop(::IDWriteGdiInterop* raw) : COMObject(raw) {}
      GdiInterop(const GdiInterop& copy_from) : COMObject(copy_from) {}
      GdiInterop(GdiInterop&& move_from) : COMObject(std::move(move_from)) {}

      // Operators
      inline GdiInterop& operator= (const GdiInterop& copy_from) {COMObject::operator=(copy_from); return *this;}
      inline GdiInterop& operator= (GdiInterop&& move_from) {COMObject::operator=(std::move(move_from)); return *this;}
      _OPERATOR_BOOL() const {return getRawInterface() ? _CONVERTIBLE_TO_TRUE : 0;}

      // Utilities
      inline ::IDWriteGdiInterop* getRawInterface() {return static_cast<::IDWriteGdiInterop*>(COMObject::getRawInterface());}
      inline const ::IDWriteGdiInterop* getRawInterface() const {return static_cast<const ::IDWriteGdiInterop*>(COMObject::getRawInterface());}
      inline void swap(GdiInterop& other) {COMObject::swap(other);}
      typedef ::IDWriteGdiInterop dumb_t;

      // Methods
      DW::BitmapRenderTarget createBitmapRenderTarget(HDC hdc, uint32_t width, uint32_t height);
      DW::FontFace createFontFaceFromHdc(HDC hdc);
      DW::Font createFontFromLOGFONT(const LOGFONTW& logFont);
      std::tuple<LOGFONTW, bool> convertFontToLOGFONT(DW::Font& font);
      LOGFONTW convertFontFaceToLOGFONT(DW::FontFace& font);
    };

    class FontCollection : public COMObject
    {
    public:
      // Constructors
      FontCollection() {}
      FontCollection(nullptr_t) {}
      explicit FontCollection(::IDWriteFontCollection* raw) : COMObject(raw) {}
      FontCollection(const FontCollection& copy_from) : COMObject(copy_from) {}
      FontCollection(FontCollection&& move_from) : COMObject(std::move(move_from)) {}

      // Operators
      inline FontCollection& operator= (const FontCollection& copy_from) {COMObject::operator=(copy_from); return *this;}
      inline FontCollection& operator= (FontCollection&& move_from) {COMObject::operator=(std::move(move_from)); return *this;}
      _OPERATOR_BOOL() const {return getRawInterface() ? _CONVERTIBLE_TO_TRUE : 0;}

      // Utilities
      inline ::IDWriteFontCollection* getRawInterface() {return static_cast<::IDWriteFontCollection*>(COMObject::getRawInterface());}
      inline const ::IDWriteFontCollection* getRawInterface() const {return static_cast<const ::IDWriteFontCollection*>(COMObject::getRawInterface());}
      inline void swap(FontCollection& other) {COMObject::swap(other);}
      typedef ::IDWriteFontCollection dumb_t;

      // Methods
      DW::FontFamily getFontFamily(uint32_t index);
      uint32_t getFontFamilyCount();
      DW::Font getFontFromFontFace(DW::FontFace& fontFace);
      std::tuple<uint32_t, bool> findFamilyName(const wchar_t* familyName);
    };

    class FontList : public COMObject
    {
    public:
      // Constructors
      FontList() {}
      FontList(nullptr_t) {}
      explicit FontList(::IDWriteFontList* raw) : COMObject(raw) {}
      FontList(const FontList& copy_from) : COMObject(copy_from) {}
      FontList(FontList&& move_from) : COMObject(std::move(move_from)) {}

      // Operators
      inline FontList& operator= (const FontList& copy_from) {COMObject::operator=(copy_from); return *this;}
      inline FontList& operator= (FontList&& move_from) {COMObject::operator=(std::move(move_from)); return *this;}
      _OPERATOR_BOOL() const {return getRawInterface() ? _CONVERTIBLE_TO_TRUE : 0;}

      // Utilities
      inline ::IDWriteFontList* getRawInterface() {return static_cast<::IDWriteFontList*>(COMObject::getRawInterface());}
      inline const ::IDWriteFontList* getRawInterface() const {return static_cast<const ::IDWriteFontList*>(COMObject::getRawInterface());}
      inline void swap(FontList& other) {COMObject::swap(other);}
      typedef ::IDWriteFontList dumb_t;

      // Methods
      DW::FontCollection getFontCollection();
      DW::Font getFont(uint32_t index);
      uint32_t getFontCount();
    };

    class FontFamily : public DW::FontList
    {
    public:
      // Constructors
      FontFamily() {}
      FontFamily(nullptr_t) {}
      explicit FontFamily(::IDWriteFontFamily* raw) : DW::FontList(raw) {}
      FontFamily(const FontFamily& copy_from) : DW::FontList(copy_from) {}
      FontFamily(FontFamily&& move_from) : DW::FontList(std::move(move_from)) {}

      // Operators
      inline FontFamily& operator= (const FontFamily& copy_from) {DW::FontList::operator=(copy_from); return *this;}
      inline FontFamily& operator= (FontFamily&& move_from) {DW::FontList::operator=(std::move(move_from)); return *this;}
      _OPERATOR_BOOL() const {return getRawInterface() ? _CONVERTIBLE_TO_TRUE : 0;}

      // Utilities
      inline ::IDWriteFontFamily* getRawInterface() {return static_cast<::IDWriteFontFamily*>(DW::FontList::getRawInterface());}
      inline const ::IDWriteFontFamily* getRawInterface() const {return static_cast<const ::IDWriteFontFamily*>(DW::FontList::getRawInterface());}
      inline void swap(FontFamily& other) {DW::FontList::swap(other);}
      typedef ::IDWriteFontFamily dumb_t;

      // Methods
      DW::Font getFirstMatchingFont(DWRITE_FONT_WEIGHT weight, DWRITE_FONT_STRETCH stretch, DWRITE_FONT_STYLE style);
      DW::FontList getMatchingFonts(DWRITE_FONT_WEIGHT weight, DWRITE_FONT_STRETCH stretch, DWRITE_FONT_STYLE style);
      DW::LocalizedStrings getFamilyNames();
    };
  }
  namespace internal
  {
    template <>
    struct ecount<DW::LocalizedStrings&>
    {
      static size_t size(DW::LocalizedStrings& x) {return 1;}
      static IDWriteLocalizedStrings*const* data(DW::LocalizedStrings& x) {return reinterpret_cast<IDWriteLocalizedStrings*const*>(&x);}
    };
    template <>
    struct ecount<DW::GlyphRunAnalysis&>
    {
      static size_t size(DW::GlyphRunAnalysis& x) {return 1;}
      static IDWriteGlyphRunAnalysis*const* data(DW::GlyphRunAnalysis& x) {return reinterpret_cast<IDWriteGlyphRunAnalysis*const*>(&x);}
    };
    template <>
    struct ecount<DW::TextAnalyzer&>
    {
      static size_t size(DW::TextAnalyzer& x) {return 1;}
      static IDWriteTextAnalyzer*const* data(DW::TextAnalyzer& x) {return reinterpret_cast<IDWriteTextAnalyzer*const*>(&x);}
    };
    template <>
    struct ecount<DW::BitmapRenderTarget&>
    {
      static size_t size(DW::BitmapRenderTarget& x) {return 1;}
      static IDWriteBitmapRenderTarget*const* data(DW::BitmapRenderTarget& x) {return reinterpret_cast<IDWriteBitmapRenderTarget*const*>(&x);}
    };
    template <>
    struct ecount<DW::InlineObject&>
    {
      static size_t size(DW::InlineObject& x) {return 1;}
      static IDWriteInlineObject*const* data(DW::InlineObject& x) {return reinterpret_cast<IDWriteInlineObject*const*>(&x);}
    };
    template <>
    struct ecount<DW::FontFileEnumerator&>
    {
      static size_t size(DW::FontFileEnumerator& x) {return 1;}
      static IDWriteFontFileEnumerator*const* data(DW::FontFileEnumerator& x) {return reinterpret_cast<IDWriteFontFileEnumerator*const*>(&x);}
    };
    template <>
    struct ecount<DW::FontFileStream&>
    {
      static size_t size(DW::FontFileStream& x) {return 1;}
      static IDWriteFontFileStream*const* data(DW::FontFileStream& x) {return reinterpret_cast<IDWriteFontFileStream*const*>(&x);}
    };
    template <>
    struct ecount<DW::Factory&>
    {
      static size_t size(DW::Factory& x) {return 1;}
      static IDWriteFactory*const* data(DW::Factory& x) {return reinterpret_cast<IDWriteFactory*const*>(&x);}
    };
    template <>
    struct ecount<DW::RenderingParams&>
    {
      static size_t size(DW::RenderingParams& x) {return 1;}
      static IDWriteRenderingParams*const* data(DW::RenderingParams& x) {return reinterpret_cast<IDWriteRenderingParams*const*>(&x);}
    };
    template <>
    struct ecount<DW::TextFormat&>
    {
      static size_t size(DW::TextFormat& x) {return 1;}
      static IDWriteTextFormat*const* data(DW::TextFormat& x) {return reinterpret_cast<IDWriteTextFormat*const*>(&x);}
    };
    template <>
    struct ecount<DW::TextLayout&>
    {
      static size_t size(DW::TextLayout& x) {return 1;}
      static IDWriteTextLayout*const* data(DW::TextLayout& x) {return reinterpret_cast<IDWriteTextLayout*const*>(&x);}
    };
    template <>
    struct ecount<DW::FontFileLoader&>
    {
      static size_t size(DW::FontFileLoader& x) {return 1;}
      static IDWriteFontFileLoader*const* data(DW::FontFileLoader& x) {return reinterpret_cast<IDWriteFontFileLoader*const*>(&x);}
    };
    template <>
    struct ecount<DW::LocalFontFileLoader&>
    {
      static size_t size(DW::LocalFontFileLoader& x) {return 1;}
      static IDWriteLocalFontFileLoader*const* data(DW::LocalFontFileLoader& x) {return reinterpret_cast<IDWriteLocalFontFileLoader*const*>(&x);}
    };
    template <>
    struct ecount<DW::Font&>
    {
      static size_t size(DW::Font& x) {return 1;}
      static IDWriteFont*const* data(DW::Font& x) {return reinterpret_cast<IDWriteFont*const*>(&x);}
    };
    template <>
    struct ecount<DW::Typography&>
    {
      static size_t size(DW::Typography& x) {return 1;}
      static IDWriteTypography*const* data(DW::Typography& x) {return reinterpret_cast<IDWriteTypography*const*>(&x);}
    };
    template <>
    struct ecount<DW::TextAnalysisSource&>
    {
      static size_t size(DW::TextAnalysisSource& x) {return 1;}
      static IDWriteTextAnalysisSource*const* data(DW::TextAnalysisSource& x) {return reinterpret_cast<IDWriteTextAnalysisSource*const*>(&x);}
    };
    template <>
    struct ecount<DW::PixelSnapping&>
    {
      static size_t size(DW::PixelSnapping& x) {return 1;}
      static IDWritePixelSnapping*const* data(DW::PixelSnapping& x) {return reinterpret_cast<IDWritePixelSnapping*const*>(&x);}
    };
    template <>
    struct ecount<DW::TextRenderer&>
    {
      static size_t size(DW::TextRenderer& x) {return 1;}
      static IDWriteTextRenderer*const* data(DW::TextRenderer& x) {return reinterpret_cast<IDWriteTextRenderer*const*>(&x);}
    };
    template <>
    struct ecount<DW::FontCollectionLoader&>
    {
      static size_t size(DW::FontCollectionLoader& x) {return 1;}
      static IDWriteFontCollectionLoader*const* data(DW::FontCollectionLoader& x) {return reinterpret_cast<IDWriteFontCollectionLoader*const*>(&x);}
    };
    template <>
    struct ecount<DW::TextAnalysisSink&>
    {
      static size_t size(DW::TextAnalysisSink& x) {return 1;}
      static IDWriteTextAnalysisSink*const* data(DW::TextAnalysisSink& x) {return reinterpret_cast<IDWriteTextAnalysisSink*const*>(&x);}
    };
    template <>
    struct ecount<DW::FontFile&>
    {
      static size_t size(DW::FontFile& x) {return 1;}
      static IDWriteFontFile*const* data(DW::FontFile& x) {return reinterpret_cast<IDWriteFontFile*const*>(&x);}
    };
    template <>
    struct ecount<DW::NumberSubstitution&>
    {
      static size_t size(DW::NumberSubstitution& x) {return 1;}
      static IDWriteNumberSubstitution*const* data(DW::NumberSubstitution& x) {return reinterpret_cast<IDWriteNumberSubstitution*const*>(&x);}
    };
    template <>
    struct ecount<DW::FontFace&>
    {
      static size_t size(DW::FontFace& x) {return 1;}
      static IDWriteFontFace*const* data(DW::FontFace& x) {return reinterpret_cast<IDWriteFontFace*const*>(&x);}
    };
    template <>
    struct ecount<DW::GdiInterop&>
    {
      static size_t size(DW::GdiInterop& x) {return 1;}
      static IDWriteGdiInterop*const* data(DW::GdiInterop& x) {return reinterpret_cast<IDWriteGdiInterop*const*>(&x);}
    };
    template <>
    struct ecount<DW::FontCollection&>
    {
      static size_t size(DW::FontCollection& x) {return 1;}
      static IDWriteFontCollection*const* data(DW::FontCollection& x) {return reinterpret_cast<IDWriteFontCollection*const*>(&x);}
    };
    template <>
    struct ecount<DW::FontList&>
    {
      static size_t size(DW::FontList& x) {return 1;}
      static IDWriteFontList*const* data(DW::FontList& x) {return reinterpret_cast<IDWriteFontList*const*>(&x);}
    };
    template <>
    struct ecount<DW::FontFamily&>
    {
      static size_t size(DW::FontFamily& x) {return 1;}
      static IDWriteFontFamily*const* data(DW::FontFamily& x) {return reinterpret_cast<IDWriteFontFamily*const*>(&x);}
    };
  }
}
namespace std {
  inline void swap(C6::DW::LocalizedStrings& a, C6::DW::LocalizedStrings& b) {a.swap(b);}
  inline void swap(C6::DW::TextRenderer& a, C6::DW::TextRenderer& b) {a.swap(b);}
  inline void swap(C6::DW::GlyphRunAnalysis& a, C6::DW::GlyphRunAnalysis& b) {a.swap(b);}
  inline void swap(C6::DW::TextAnalyzer& a, C6::DW::TextAnalyzer& b) {a.swap(b);}
  inline void swap(C6::DW::LocalFontFileLoader& a, C6::DW::LocalFontFileLoader& b) {a.swap(b);}
  inline void swap(C6::DW::BitmapRenderTarget& a, C6::DW::BitmapRenderTarget& b) {a.swap(b);}
  inline void swap(C6::DW::InlineObject& a, C6::DW::InlineObject& b) {a.swap(b);}
  inline void swap(C6::DW::FontFileEnumerator& a, C6::DW::FontFileEnumerator& b) {a.swap(b);}
  inline void swap(C6::DW::FontFileStream& a, C6::DW::FontFileStream& b) {a.swap(b);}
  inline void swap(C6::DW::Factory& a, C6::DW::Factory& b) {a.swap(b);}
  inline void swap(C6::DW::FontCollection& a, C6::DW::FontCollection& b) {a.swap(b);}
  inline void swap(C6::DW::TextFormat& a, C6::DW::TextFormat& b) {a.swap(b);}
  inline void swap(C6::DW::FontFileLoader& a, C6::DW::FontFileLoader& b) {a.swap(b);}
  inline void swap(C6::DW::FontList& a, C6::DW::FontList& b) {a.swap(b);}
  inline void swap(C6::DW::FontFamily& a, C6::DW::FontFamily& b) {a.swap(b);}
  inline void swap(C6::DW::Typography& a, C6::DW::Typography& b) {a.swap(b);}
  inline void swap(C6::DW::GdiInterop& a, C6::DW::GdiInterop& b) {a.swap(b);}
  inline void swap(C6::DW::TextAnalysisSink& a, C6::DW::TextAnalysisSink& b) {a.swap(b);}
  inline void swap(C6::DW::NumberSubstitution& a, C6::DW::NumberSubstitution& b) {a.swap(b);}
  inline void swap(C6::DW::FontCollectionLoader& a, C6::DW::FontCollectionLoader& b) {a.swap(b);}
  inline void swap(C6::DW::FontFile& a, C6::DW::FontFile& b) {a.swap(b);}
  inline void swap(C6::DW::RenderingParams& a, C6::DW::RenderingParams& b) {a.swap(b);}
  inline void swap(C6::DW::TextAnalysisSource& a, C6::DW::TextAnalysisSource& b) {a.swap(b);}
  inline void swap(C6::DW::FontFace& a, C6::DW::FontFace& b) {a.swap(b);}
  inline void swap(C6::DW::PixelSnapping& a, C6::DW::PixelSnapping& b) {a.swap(b);}
  inline void swap(C6::DW::Font& a, C6::DW::Font& b) {a.swap(b);}
  inline void swap(C6::DW::TextLayout& a, C6::DW::TextLayout& b) {a.swap(b);}
}
