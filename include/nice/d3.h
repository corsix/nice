#pragma once
// Autogenerated by nicify.lua -- do not edit by hand.
#include <d3d10_1.h>
#include "com.h"
namespace C6
{
  namespace D3
  {
    class PixelShader;
    class Predicate;
    class BlendState;
    class Multithread;
    class Resource;
    class Device1;
    class Buffer;
    class Texture1D;
    class DepthStencilView;
    class Texture3D;
    class SamplerState;
    class RenderTargetView;
    class GeometryShader;
    class VertexShader;
    class Texture2D;
    class Query;
    class ShaderResourceView;
    class ShaderResourceView1;
    class View;
    class InputLayout;
    class Device;
    class Asynchronous;
    class DeviceChild;
    class DepthStencilState;
    class Counter;
    class RasterizerState;
    class BlendState1;

    class Multithread : public COMObject
    {
    public:
      // Constructors
      Multithread() {}
      Multithread(nullptr_t) {}
      explicit Multithread(::ID3D10Multithread* raw) : COMObject(raw) {}
      Multithread(const Multithread& copy_from) : COMObject(copy_from) {}
      Multithread(Multithread&& move_from) : COMObject(std::move(move_from)) {}

      // Operators
      inline Multithread& operator= (const Multithread& copy_from) {COMObject::operator=(copy_from); return *this;}
      inline Multithread& operator= (Multithread&& move_from) {COMObject::operator=(std::move(move_from)); return *this;}
      _OPERATOR_BOOL() const {return getRawInterface() ? _CONVERTIBLE_TO_TRUE : 0;}

      // Utilities
      inline ::ID3D10Multithread* getRawInterface() {return static_cast<::ID3D10Multithread*>(COMObject::getRawInterface());}
      inline const ::ID3D10Multithread* getRawInterface() const {return static_cast<const ::ID3D10Multithread*>(COMObject::getRawInterface());}
      inline void swap(Multithread& other) {COMObject::swap(other);}
      typedef ::ID3D10Multithread dumb_t;

      // Methods
      void leave();
      BOOL getMultithreadProtected();
      BOOL setMultithreadProtected(BOOL bMTProtect);
      void enter();
    };

    class DeviceChild : public COMObject
    {
    public:
      // Constructors
      DeviceChild() {}
      DeviceChild(nullptr_t) {}
      explicit DeviceChild(::ID3D10DeviceChild* raw) : COMObject(raw) {}
      DeviceChild(const DeviceChild& copy_from) : COMObject(copy_from) {}
      DeviceChild(DeviceChild&& move_from) : COMObject(std::move(move_from)) {}

      // Operators
      inline DeviceChild& operator= (const DeviceChild& copy_from) {COMObject::operator=(copy_from); return *this;}
      inline DeviceChild& operator= (DeviceChild&& move_from) {COMObject::operator=(std::move(move_from)); return *this;}
      _OPERATOR_BOOL() const {return getRawInterface() ? _CONVERTIBLE_TO_TRUE : 0;}

      // Utilities
      inline ::ID3D10DeviceChild* getRawInterface() {return static_cast<::ID3D10DeviceChild*>(COMObject::getRawInterface());}
      inline const ::ID3D10DeviceChild* getRawInterface() const {return static_cast<const ::ID3D10DeviceChild*>(COMObject::getRawInterface());}
      inline void swap(DeviceChild& other) {COMObject::swap(other);}
      typedef ::ID3D10DeviceChild dumb_t;

      // Methods
      void getPrivateData(REFGUID guid, unsigned int* pDataSize, void* pData);
      D3::Device getDevice();
      void setPrivateData(REFGUID guid);

      template <typename const_void_Container>
      void setPrivateData(REFGUID guid, const_void_Container&& pData)
      {
        HRESULT hr = getRawInterface()->SetPrivateData(guid, static_cast<unsigned int>(C6::internal::ecount<const_void_Container>::size(pData) * C6::internal::bcount<decltype(pData.data())>::elem_size), C6::internal::ecount<const_void_Container>::data(pData));
        if(FAILED(hr)) throw COMException(hr, "ID3D10DeviceChild::SetPrivateData");
      }

      void setPrivateDataInterface(REFGUID guid);
      void setPrivateDataInterface(REFGUID guid, const IUnknown& pData);
    };

    class PixelShader : public D3::DeviceChild
    {
    public:
      // Constructors
      PixelShader() {}
      PixelShader(nullptr_t) {}
      explicit PixelShader(::ID3D10PixelShader* raw) : D3::DeviceChild(raw) {}
      PixelShader(const PixelShader& copy_from) : D3::DeviceChild(copy_from) {}
      PixelShader(PixelShader&& move_from) : D3::DeviceChild(std::move(move_from)) {}

      // Operators
      inline PixelShader& operator= (const PixelShader& copy_from) {D3::DeviceChild::operator=(copy_from); return *this;}
      inline PixelShader& operator= (PixelShader&& move_from) {D3::DeviceChild::operator=(std::move(move_from)); return *this;}
      _OPERATOR_BOOL() const {return getRawInterface() ? _CONVERTIBLE_TO_TRUE : 0;}

      // Utilities
      inline ::ID3D10PixelShader* getRawInterface() {return static_cast<::ID3D10PixelShader*>(D3::DeviceChild::getRawInterface());}
      inline const ::ID3D10PixelShader* getRawInterface() const {return static_cast<const ::ID3D10PixelShader*>(D3::DeviceChild::getRawInterface());}
      inline void swap(PixelShader& other) {D3::DeviceChild::swap(other);}
      typedef ::ID3D10PixelShader dumb_t;

      // Methods
    };

    class VertexShader : public D3::DeviceChild
    {
    public:
      // Constructors
      VertexShader() {}
      VertexShader(nullptr_t) {}
      explicit VertexShader(::ID3D10VertexShader* raw) : D3::DeviceChild(raw) {}
      VertexShader(const VertexShader& copy_from) : D3::DeviceChild(copy_from) {}
      VertexShader(VertexShader&& move_from) : D3::DeviceChild(std::move(move_from)) {}

      // Operators
      inline VertexShader& operator= (const VertexShader& copy_from) {D3::DeviceChild::operator=(copy_from); return *this;}
      inline VertexShader& operator= (VertexShader&& move_from) {D3::DeviceChild::operator=(std::move(move_from)); return *this;}
      _OPERATOR_BOOL() const {return getRawInterface() ? _CONVERTIBLE_TO_TRUE : 0;}

      // Utilities
      inline ::ID3D10VertexShader* getRawInterface() {return static_cast<::ID3D10VertexShader*>(D3::DeviceChild::getRawInterface());}
      inline const ::ID3D10VertexShader* getRawInterface() const {return static_cast<const ::ID3D10VertexShader*>(D3::DeviceChild::getRawInterface());}
      inline void swap(VertexShader& other) {D3::DeviceChild::swap(other);}
      typedef ::ID3D10VertexShader dumb_t;

      // Methods
    };

    class GeometryShader : public D3::DeviceChild
    {
    public:
      // Constructors
      GeometryShader() {}
      GeometryShader(nullptr_t) {}
      explicit GeometryShader(::ID3D10GeometryShader* raw) : D3::DeviceChild(raw) {}
      GeometryShader(const GeometryShader& copy_from) : D3::DeviceChild(copy_from) {}
      GeometryShader(GeometryShader&& move_from) : D3::DeviceChild(std::move(move_from)) {}

      // Operators
      inline GeometryShader& operator= (const GeometryShader& copy_from) {D3::DeviceChild::operator=(copy_from); return *this;}
      inline GeometryShader& operator= (GeometryShader&& move_from) {D3::DeviceChild::operator=(std::move(move_from)); return *this;}
      _OPERATOR_BOOL() const {return getRawInterface() ? _CONVERTIBLE_TO_TRUE : 0;}

      // Utilities
      inline ::ID3D10GeometryShader* getRawInterface() {return static_cast<::ID3D10GeometryShader*>(D3::DeviceChild::getRawInterface());}
      inline const ::ID3D10GeometryShader* getRawInterface() const {return static_cast<const ::ID3D10GeometryShader*>(D3::DeviceChild::getRawInterface());}
      inline void swap(GeometryShader& other) {D3::DeviceChild::swap(other);}
      typedef ::ID3D10GeometryShader dumb_t;

      // Methods
    };

    class RasterizerState : public D3::DeviceChild
    {
    public:
      // Constructors
      RasterizerState() {}
      RasterizerState(nullptr_t) {}
      explicit RasterizerState(::ID3D10RasterizerState* raw) : D3::DeviceChild(raw) {}
      RasterizerState(const RasterizerState& copy_from) : D3::DeviceChild(copy_from) {}
      RasterizerState(RasterizerState&& move_from) : D3::DeviceChild(std::move(move_from)) {}

      // Operators
      inline RasterizerState& operator= (const RasterizerState& copy_from) {D3::DeviceChild::operator=(copy_from); return *this;}
      inline RasterizerState& operator= (RasterizerState&& move_from) {D3::DeviceChild::operator=(std::move(move_from)); return *this;}
      _OPERATOR_BOOL() const {return getRawInterface() ? _CONVERTIBLE_TO_TRUE : 0;}

      // Utilities
      inline ::ID3D10RasterizerState* getRawInterface() {return static_cast<::ID3D10RasterizerState*>(D3::DeviceChild::getRawInterface());}
      inline const ::ID3D10RasterizerState* getRawInterface() const {return static_cast<const ::ID3D10RasterizerState*>(D3::DeviceChild::getRawInterface());}
      inline void swap(RasterizerState& other) {D3::DeviceChild::swap(other);}
      typedef ::ID3D10RasterizerState dumb_t;

      // Methods
      D3D10_RASTERIZER_DESC getDesc();
    };

    class BlendState : public D3::DeviceChild
    {
    public:
      // Constructors
      BlendState() {}
      BlendState(nullptr_t) {}
      explicit BlendState(::ID3D10BlendState* raw) : D3::DeviceChild(raw) {}
      BlendState(const BlendState& copy_from) : D3::DeviceChild(copy_from) {}
      BlendState(BlendState&& move_from) : D3::DeviceChild(std::move(move_from)) {}

      // Operators
      inline BlendState& operator= (const BlendState& copy_from) {D3::DeviceChild::operator=(copy_from); return *this;}
      inline BlendState& operator= (BlendState&& move_from) {D3::DeviceChild::operator=(std::move(move_from)); return *this;}
      _OPERATOR_BOOL() const {return getRawInterface() ? _CONVERTIBLE_TO_TRUE : 0;}

      // Utilities
      inline ::ID3D10BlendState* getRawInterface() {return static_cast<::ID3D10BlendState*>(D3::DeviceChild::getRawInterface());}
      inline const ::ID3D10BlendState* getRawInterface() const {return static_cast<const ::ID3D10BlendState*>(D3::DeviceChild::getRawInterface());}
      inline void swap(BlendState& other) {D3::DeviceChild::swap(other);}
      typedef ::ID3D10BlendState dumb_t;

      // Methods
      D3D10_BLEND_DESC getDesc();
    };

    class BlendState1 : public D3::BlendState
    {
    public:
      // Constructors
      BlendState1() {}
      BlendState1(nullptr_t) {}
      explicit BlendState1(::ID3D10BlendState1* raw) : D3::BlendState(raw) {}
      BlendState1(const BlendState1& copy_from) : D3::BlendState(copy_from) {}
      BlendState1(BlendState1&& move_from) : D3::BlendState(std::move(move_from)) {}

      // Operators
      inline BlendState1& operator= (const BlendState1& copy_from) {D3::BlendState::operator=(copy_from); return *this;}
      inline BlendState1& operator= (BlendState1&& move_from) {D3::BlendState::operator=(std::move(move_from)); return *this;}
      _OPERATOR_BOOL() const {return getRawInterface() ? _CONVERTIBLE_TO_TRUE : 0;}

      // Utilities
      inline ::ID3D10BlendState1* getRawInterface() {return static_cast<::ID3D10BlendState1*>(D3::BlendState::getRawInterface());}
      inline const ::ID3D10BlendState1* getRawInterface() const {return static_cast<const ::ID3D10BlendState1*>(D3::BlendState::getRawInterface());}
      inline void swap(BlendState1& other) {D3::BlendState::swap(other);}
      typedef ::ID3D10BlendState1 dumb_t;

      // Methods
      D3D10_BLEND_DESC1 getDesc1();
    };

    class Asynchronous : public D3::DeviceChild
    {
    public:
      // Constructors
      Asynchronous() {}
      Asynchronous(nullptr_t) {}
      explicit Asynchronous(::ID3D10Asynchronous* raw) : D3::DeviceChild(raw) {}
      Asynchronous(const Asynchronous& copy_from) : D3::DeviceChild(copy_from) {}
      Asynchronous(Asynchronous&& move_from) : D3::DeviceChild(std::move(move_from)) {}

      // Operators
      inline Asynchronous& operator= (const Asynchronous& copy_from) {D3::DeviceChild::operator=(copy_from); return *this;}
      inline Asynchronous& operator= (Asynchronous&& move_from) {D3::DeviceChild::operator=(std::move(move_from)); return *this;}
      _OPERATOR_BOOL() const {return getRawInterface() ? _CONVERTIBLE_TO_TRUE : 0;}

      // Utilities
      inline ::ID3D10Asynchronous* getRawInterface() {return static_cast<::ID3D10Asynchronous*>(D3::DeviceChild::getRawInterface());}
      inline const ::ID3D10Asynchronous* getRawInterface() const {return static_cast<const ::ID3D10Asynchronous*>(D3::DeviceChild::getRawInterface());}
      inline void swap(Asynchronous& other) {D3::DeviceChild::swap(other);}
      typedef ::ID3D10Asynchronous dumb_t;

      // Methods
      void begin();
      void getData(void* pData, unsigned int DataSize, unsigned int GetDataFlags);
      unsigned int getDataSize();
      void end();
    };

    class Query : public D3::Asynchronous
    {
    public:
      // Constructors
      Query() {}
      Query(nullptr_t) {}
      explicit Query(::ID3D10Query* raw) : D3::Asynchronous(raw) {}
      Query(const Query& copy_from) : D3::Asynchronous(copy_from) {}
      Query(Query&& move_from) : D3::Asynchronous(std::move(move_from)) {}

      // Operators
      inline Query& operator= (const Query& copy_from) {D3::Asynchronous::operator=(copy_from); return *this;}
      inline Query& operator= (Query&& move_from) {D3::Asynchronous::operator=(std::move(move_from)); return *this;}
      _OPERATOR_BOOL() const {return getRawInterface() ? _CONVERTIBLE_TO_TRUE : 0;}

      // Utilities
      inline ::ID3D10Query* getRawInterface() {return static_cast<::ID3D10Query*>(D3::Asynchronous::getRawInterface());}
      inline const ::ID3D10Query* getRawInterface() const {return static_cast<const ::ID3D10Query*>(D3::Asynchronous::getRawInterface());}
      inline void swap(Query& other) {D3::Asynchronous::swap(other);}
      typedef ::ID3D10Query dumb_t;

      // Methods
      D3D10_QUERY_DESC getDesc();
    };

    class Predicate : public D3::Query
    {
    public:
      // Constructors
      Predicate() {}
      Predicate(nullptr_t) {}
      explicit Predicate(::ID3D10Predicate* raw) : D3::Query(raw) {}
      Predicate(const Predicate& copy_from) : D3::Query(copy_from) {}
      Predicate(Predicate&& move_from) : D3::Query(std::move(move_from)) {}

      // Operators
      inline Predicate& operator= (const Predicate& copy_from) {D3::Query::operator=(copy_from); return *this;}
      inline Predicate& operator= (Predicate&& move_from) {D3::Query::operator=(std::move(move_from)); return *this;}
      _OPERATOR_BOOL() const {return getRawInterface() ? _CONVERTIBLE_TO_TRUE : 0;}

      // Utilities
      inline ::ID3D10Predicate* getRawInterface() {return static_cast<::ID3D10Predicate*>(D3::Query::getRawInterface());}
      inline const ::ID3D10Predicate* getRawInterface() const {return static_cast<const ::ID3D10Predicate*>(D3::Query::getRawInterface());}
      inline void swap(Predicate& other) {D3::Query::swap(other);}
      typedef ::ID3D10Predicate dumb_t;

      // Methods
    };

    class Counter : public D3::Asynchronous
    {
    public:
      // Constructors
      Counter() {}
      Counter(nullptr_t) {}
      explicit Counter(::ID3D10Counter* raw) : D3::Asynchronous(raw) {}
      Counter(const Counter& copy_from) : D3::Asynchronous(copy_from) {}
      Counter(Counter&& move_from) : D3::Asynchronous(std::move(move_from)) {}

      // Operators
      inline Counter& operator= (const Counter& copy_from) {D3::Asynchronous::operator=(copy_from); return *this;}
      inline Counter& operator= (Counter&& move_from) {D3::Asynchronous::operator=(std::move(move_from)); return *this;}
      _OPERATOR_BOOL() const {return getRawInterface() ? _CONVERTIBLE_TO_TRUE : 0;}

      // Utilities
      inline ::ID3D10Counter* getRawInterface() {return static_cast<::ID3D10Counter*>(D3::Asynchronous::getRawInterface());}
      inline const ::ID3D10Counter* getRawInterface() const {return static_cast<const ::ID3D10Counter*>(D3::Asynchronous::getRawInterface());}
      inline void swap(Counter& other) {D3::Asynchronous::swap(other);}
      typedef ::ID3D10Counter dumb_t;

      // Methods
      D3D10_COUNTER_DESC getDesc();
    };

    class Resource : public D3::DeviceChild
    {
    public:
      // Constructors
      Resource() {}
      Resource(nullptr_t) {}
      explicit Resource(::ID3D10Resource* raw) : D3::DeviceChild(raw) {}
      Resource(const Resource& copy_from) : D3::DeviceChild(copy_from) {}
      Resource(Resource&& move_from) : D3::DeviceChild(std::move(move_from)) {}

      // Operators
      inline Resource& operator= (const Resource& copy_from) {D3::DeviceChild::operator=(copy_from); return *this;}
      inline Resource& operator= (Resource&& move_from) {D3::DeviceChild::operator=(std::move(move_from)); return *this;}
      _OPERATOR_BOOL() const {return getRawInterface() ? _CONVERTIBLE_TO_TRUE : 0;}

      // Utilities
      inline ::ID3D10Resource* getRawInterface() {return static_cast<::ID3D10Resource*>(D3::DeviceChild::getRawInterface());}
      inline const ::ID3D10Resource* getRawInterface() const {return static_cast<const ::ID3D10Resource*>(D3::DeviceChild::getRawInterface());}
      inline void swap(Resource& other) {D3::DeviceChild::swap(other);}
      typedef ::ID3D10Resource dumb_t;

      // Methods
      unsigned int getEvictionPriority();
      void setEvictionPriority(unsigned int EvictionPriority);
      D3D10_RESOURCE_DIMENSION getType();
    };

    class Texture1D : public D3::Resource
    {
    public:
      // Constructors
      Texture1D() {}
      Texture1D(nullptr_t) {}
      explicit Texture1D(::ID3D10Texture1D* raw) : D3::Resource(raw) {}
      Texture1D(const Texture1D& copy_from) : D3::Resource(copy_from) {}
      Texture1D(Texture1D&& move_from) : D3::Resource(std::move(move_from)) {}

      // Operators
      inline Texture1D& operator= (const Texture1D& copy_from) {D3::Resource::operator=(copy_from); return *this;}
      inline Texture1D& operator= (Texture1D&& move_from) {D3::Resource::operator=(std::move(move_from)); return *this;}
      _OPERATOR_BOOL() const {return getRawInterface() ? _CONVERTIBLE_TO_TRUE : 0;}

      // Utilities
      inline ::ID3D10Texture1D* getRawInterface() {return static_cast<::ID3D10Texture1D*>(D3::Resource::getRawInterface());}
      inline const ::ID3D10Texture1D* getRawInterface() const {return static_cast<const ::ID3D10Texture1D*>(D3::Resource::getRawInterface());}
      inline void swap(Texture1D& other) {D3::Resource::swap(other);}
      typedef ::ID3D10Texture1D dumb_t;

      // Methods
      void unmap(unsigned int Subresource);
      D3D10_TEXTURE1D_DESC getDesc();
      void* map(unsigned int Subresource, D3D10_MAP MapType, unsigned int MapFlags);
    };

    class Texture2D : public D3::Resource
    {
    public:
      // Constructors
      Texture2D() {}
      Texture2D(nullptr_t) {}
      explicit Texture2D(::ID3D10Texture2D* raw) : D3::Resource(raw) {}
      Texture2D(const Texture2D& copy_from) : D3::Resource(copy_from) {}
      Texture2D(Texture2D&& move_from) : D3::Resource(std::move(move_from)) {}

      // Operators
      inline Texture2D& operator= (const Texture2D& copy_from) {D3::Resource::operator=(copy_from); return *this;}
      inline Texture2D& operator= (Texture2D&& move_from) {D3::Resource::operator=(std::move(move_from)); return *this;}
      _OPERATOR_BOOL() const {return getRawInterface() ? _CONVERTIBLE_TO_TRUE : 0;}

      // Utilities
      inline ::ID3D10Texture2D* getRawInterface() {return static_cast<::ID3D10Texture2D*>(D3::Resource::getRawInterface());}
      inline const ::ID3D10Texture2D* getRawInterface() const {return static_cast<const ::ID3D10Texture2D*>(D3::Resource::getRawInterface());}
      inline void swap(Texture2D& other) {D3::Resource::swap(other);}
      typedef ::ID3D10Texture2D dumb_t;

      // Methods
      void unmap(unsigned int Subresource);
      D3D10_TEXTURE2D_DESC getDesc();
      D3D10_MAPPED_TEXTURE2D map(unsigned int Subresource, D3D10_MAP MapType, unsigned int MapFlags);
    };

    class Texture3D : public D3::Resource
    {
    public:
      // Constructors
      Texture3D() {}
      Texture3D(nullptr_t) {}
      explicit Texture3D(::ID3D10Texture3D* raw) : D3::Resource(raw) {}
      Texture3D(const Texture3D& copy_from) : D3::Resource(copy_from) {}
      Texture3D(Texture3D&& move_from) : D3::Resource(std::move(move_from)) {}

      // Operators
      inline Texture3D& operator= (const Texture3D& copy_from) {D3::Resource::operator=(copy_from); return *this;}
      inline Texture3D& operator= (Texture3D&& move_from) {D3::Resource::operator=(std::move(move_from)); return *this;}
      _OPERATOR_BOOL() const {return getRawInterface() ? _CONVERTIBLE_TO_TRUE : 0;}

      // Utilities
      inline ::ID3D10Texture3D* getRawInterface() {return static_cast<::ID3D10Texture3D*>(D3::Resource::getRawInterface());}
      inline const ::ID3D10Texture3D* getRawInterface() const {return static_cast<const ::ID3D10Texture3D*>(D3::Resource::getRawInterface());}
      inline void swap(Texture3D& other) {D3::Resource::swap(other);}
      typedef ::ID3D10Texture3D dumb_t;

      // Methods
      void unmap(unsigned int Subresource);
      D3D10_TEXTURE3D_DESC getDesc();
      D3D10_MAPPED_TEXTURE3D map(unsigned int Subresource, D3D10_MAP MapType, unsigned int MapFlags);
    };

    class Buffer : public D3::Resource
    {
    public:
      // Constructors
      Buffer() {}
      Buffer(nullptr_t) {}
      explicit Buffer(::ID3D10Buffer* raw) : D3::Resource(raw) {}
      Buffer(const Buffer& copy_from) : D3::Resource(copy_from) {}
      Buffer(Buffer&& move_from) : D3::Resource(std::move(move_from)) {}

      // Operators
      inline Buffer& operator= (const Buffer& copy_from) {D3::Resource::operator=(copy_from); return *this;}
      inline Buffer& operator= (Buffer&& move_from) {D3::Resource::operator=(std::move(move_from)); return *this;}
      _OPERATOR_BOOL() const {return getRawInterface() ? _CONVERTIBLE_TO_TRUE : 0;}

      // Utilities
      inline ::ID3D10Buffer* getRawInterface() {return static_cast<::ID3D10Buffer*>(D3::Resource::getRawInterface());}
      inline const ::ID3D10Buffer* getRawInterface() const {return static_cast<const ::ID3D10Buffer*>(D3::Resource::getRawInterface());}
      inline void swap(Buffer& other) {D3::Resource::swap(other);}
      typedef ::ID3D10Buffer dumb_t;

      // Methods
      void unmap();
      D3D10_BUFFER_DESC getDesc();
      void* map(D3D10_MAP MapType, unsigned int MapFlags);
    };

    class InputLayout : public D3::DeviceChild
    {
    public:
      // Constructors
      InputLayout() {}
      InputLayout(nullptr_t) {}
      explicit InputLayout(::ID3D10InputLayout* raw) : D3::DeviceChild(raw) {}
      InputLayout(const InputLayout& copy_from) : D3::DeviceChild(copy_from) {}
      InputLayout(InputLayout&& move_from) : D3::DeviceChild(std::move(move_from)) {}

      // Operators
      inline InputLayout& operator= (const InputLayout& copy_from) {D3::DeviceChild::operator=(copy_from); return *this;}
      inline InputLayout& operator= (InputLayout&& move_from) {D3::DeviceChild::operator=(std::move(move_from)); return *this;}
      _OPERATOR_BOOL() const {return getRawInterface() ? _CONVERTIBLE_TO_TRUE : 0;}

      // Utilities
      inline ::ID3D10InputLayout* getRawInterface() {return static_cast<::ID3D10InputLayout*>(D3::DeviceChild::getRawInterface());}
      inline const ::ID3D10InputLayout* getRawInterface() const {return static_cast<const ::ID3D10InputLayout*>(D3::DeviceChild::getRawInterface());}
      inline void swap(InputLayout& other) {D3::DeviceChild::swap(other);}
      typedef ::ID3D10InputLayout dumb_t;

      // Methods
    };

    class DepthStencilState : public D3::DeviceChild
    {
    public:
      // Constructors
      DepthStencilState() {}
      DepthStencilState(nullptr_t) {}
      explicit DepthStencilState(::ID3D10DepthStencilState* raw) : D3::DeviceChild(raw) {}
      DepthStencilState(const DepthStencilState& copy_from) : D3::DeviceChild(copy_from) {}
      DepthStencilState(DepthStencilState&& move_from) : D3::DeviceChild(std::move(move_from)) {}

      // Operators
      inline DepthStencilState& operator= (const DepthStencilState& copy_from) {D3::DeviceChild::operator=(copy_from); return *this;}
      inline DepthStencilState& operator= (DepthStencilState&& move_from) {D3::DeviceChild::operator=(std::move(move_from)); return *this;}
      _OPERATOR_BOOL() const {return getRawInterface() ? _CONVERTIBLE_TO_TRUE : 0;}

      // Utilities
      inline ::ID3D10DepthStencilState* getRawInterface() {return static_cast<::ID3D10DepthStencilState*>(D3::DeviceChild::getRawInterface());}
      inline const ::ID3D10DepthStencilState* getRawInterface() const {return static_cast<const ::ID3D10DepthStencilState*>(D3::DeviceChild::getRawInterface());}
      inline void swap(DepthStencilState& other) {D3::DeviceChild::swap(other);}
      typedef ::ID3D10DepthStencilState dumb_t;

      // Methods
      D3D10_DEPTH_STENCIL_DESC getDesc();
    };

    class View : public D3::DeviceChild
    {
    public:
      // Constructors
      View() {}
      View(nullptr_t) {}
      explicit View(::ID3D10View* raw) : D3::DeviceChild(raw) {}
      View(const View& copy_from) : D3::DeviceChild(copy_from) {}
      View(View&& move_from) : D3::DeviceChild(std::move(move_from)) {}

      // Operators
      inline View& operator= (const View& copy_from) {D3::DeviceChild::operator=(copy_from); return *this;}
      inline View& operator= (View&& move_from) {D3::DeviceChild::operator=(std::move(move_from)); return *this;}
      _OPERATOR_BOOL() const {return getRawInterface() ? _CONVERTIBLE_TO_TRUE : 0;}

      // Utilities
      inline ::ID3D10View* getRawInterface() {return static_cast<::ID3D10View*>(D3::DeviceChild::getRawInterface());}
      inline const ::ID3D10View* getRawInterface() const {return static_cast<const ::ID3D10View*>(D3::DeviceChild::getRawInterface());}
      inline void swap(View& other) {D3::DeviceChild::swap(other);}
      typedef ::ID3D10View dumb_t;

      // Methods
      D3::Resource getResource();
    };

    class RenderTargetView : public D3::View
    {
    public:
      // Constructors
      RenderTargetView() {}
      RenderTargetView(nullptr_t) {}
      explicit RenderTargetView(::ID3D10RenderTargetView* raw) : D3::View(raw) {}
      RenderTargetView(const RenderTargetView& copy_from) : D3::View(copy_from) {}
      RenderTargetView(RenderTargetView&& move_from) : D3::View(std::move(move_from)) {}

      // Operators
      inline RenderTargetView& operator= (const RenderTargetView& copy_from) {D3::View::operator=(copy_from); return *this;}
      inline RenderTargetView& operator= (RenderTargetView&& move_from) {D3::View::operator=(std::move(move_from)); return *this;}
      _OPERATOR_BOOL() const {return getRawInterface() ? _CONVERTIBLE_TO_TRUE : 0;}

      // Utilities
      inline ::ID3D10RenderTargetView* getRawInterface() {return static_cast<::ID3D10RenderTargetView*>(D3::View::getRawInterface());}
      inline const ::ID3D10RenderTargetView* getRawInterface() const {return static_cast<const ::ID3D10RenderTargetView*>(D3::View::getRawInterface());}
      inline void swap(RenderTargetView& other) {D3::View::swap(other);}
      typedef ::ID3D10RenderTargetView dumb_t;

      // Methods
      D3D10_RENDER_TARGET_VIEW_DESC getDesc();
    };

    class ShaderResourceView : public D3::View
    {
    public:
      // Constructors
      ShaderResourceView() {}
      ShaderResourceView(nullptr_t) {}
      explicit ShaderResourceView(::ID3D10ShaderResourceView* raw) : D3::View(raw) {}
      ShaderResourceView(const ShaderResourceView& copy_from) : D3::View(copy_from) {}
      ShaderResourceView(ShaderResourceView&& move_from) : D3::View(std::move(move_from)) {}

      // Operators
      inline ShaderResourceView& operator= (const ShaderResourceView& copy_from) {D3::View::operator=(copy_from); return *this;}
      inline ShaderResourceView& operator= (ShaderResourceView&& move_from) {D3::View::operator=(std::move(move_from)); return *this;}
      _OPERATOR_BOOL() const {return getRawInterface() ? _CONVERTIBLE_TO_TRUE : 0;}

      // Utilities
      inline ::ID3D10ShaderResourceView* getRawInterface() {return static_cast<::ID3D10ShaderResourceView*>(D3::View::getRawInterface());}
      inline const ::ID3D10ShaderResourceView* getRawInterface() const {return static_cast<const ::ID3D10ShaderResourceView*>(D3::View::getRawInterface());}
      inline void swap(ShaderResourceView& other) {D3::View::swap(other);}
      typedef ::ID3D10ShaderResourceView dumb_t;

      // Methods
      D3D10_SHADER_RESOURCE_VIEW_DESC getDesc();
    };

    class ShaderResourceView1 : public D3::ShaderResourceView
    {
    public:
      // Constructors
      ShaderResourceView1() {}
      ShaderResourceView1(nullptr_t) {}
      explicit ShaderResourceView1(::ID3D10ShaderResourceView1* raw) : D3::ShaderResourceView(raw) {}
      ShaderResourceView1(const ShaderResourceView1& copy_from) : D3::ShaderResourceView(copy_from) {}
      ShaderResourceView1(ShaderResourceView1&& move_from) : D3::ShaderResourceView(std::move(move_from)) {}

      // Operators
      inline ShaderResourceView1& operator= (const ShaderResourceView1& copy_from) {D3::ShaderResourceView::operator=(copy_from); return *this;}
      inline ShaderResourceView1& operator= (ShaderResourceView1&& move_from) {D3::ShaderResourceView::operator=(std::move(move_from)); return *this;}
      _OPERATOR_BOOL() const {return getRawInterface() ? _CONVERTIBLE_TO_TRUE : 0;}

      // Utilities
      inline ::ID3D10ShaderResourceView1* getRawInterface() {return static_cast<::ID3D10ShaderResourceView1*>(D3::ShaderResourceView::getRawInterface());}
      inline const ::ID3D10ShaderResourceView1* getRawInterface() const {return static_cast<const ::ID3D10ShaderResourceView1*>(D3::ShaderResourceView::getRawInterface());}
      inline void swap(ShaderResourceView1& other) {D3::ShaderResourceView::swap(other);}
      typedef ::ID3D10ShaderResourceView1 dumb_t;

      // Methods
      D3D10_SHADER_RESOURCE_VIEW_DESC1 getDesc1();
    };

    class DepthStencilView : public D3::View
    {
    public:
      // Constructors
      DepthStencilView() {}
      DepthStencilView(nullptr_t) {}
      explicit DepthStencilView(::ID3D10DepthStencilView* raw) : D3::View(raw) {}
      DepthStencilView(const DepthStencilView& copy_from) : D3::View(copy_from) {}
      DepthStencilView(DepthStencilView&& move_from) : D3::View(std::move(move_from)) {}

      // Operators
      inline DepthStencilView& operator= (const DepthStencilView& copy_from) {D3::View::operator=(copy_from); return *this;}
      inline DepthStencilView& operator= (DepthStencilView&& move_from) {D3::View::operator=(std::move(move_from)); return *this;}
      _OPERATOR_BOOL() const {return getRawInterface() ? _CONVERTIBLE_TO_TRUE : 0;}

      // Utilities
      inline ::ID3D10DepthStencilView* getRawInterface() {return static_cast<::ID3D10DepthStencilView*>(D3::View::getRawInterface());}
      inline const ::ID3D10DepthStencilView* getRawInterface() const {return static_cast<const ::ID3D10DepthStencilView*>(D3::View::getRawInterface());}
      inline void swap(DepthStencilView& other) {D3::View::swap(other);}
      typedef ::ID3D10DepthStencilView dumb_t;

      // Methods
      D3D10_DEPTH_STENCIL_VIEW_DESC getDesc();
    };

    class SamplerState : public D3::DeviceChild
    {
    public:
      // Constructors
      SamplerState() {}
      SamplerState(nullptr_t) {}
      explicit SamplerState(::ID3D10SamplerState* raw) : D3::DeviceChild(raw) {}
      SamplerState(const SamplerState& copy_from) : D3::DeviceChild(copy_from) {}
      SamplerState(SamplerState&& move_from) : D3::DeviceChild(std::move(move_from)) {}

      // Operators
      inline SamplerState& operator= (const SamplerState& copy_from) {D3::DeviceChild::operator=(copy_from); return *this;}
      inline SamplerState& operator= (SamplerState&& move_from) {D3::DeviceChild::operator=(std::move(move_from)); return *this;}
      _OPERATOR_BOOL() const {return getRawInterface() ? _CONVERTIBLE_TO_TRUE : 0;}

      // Utilities
      inline ::ID3D10SamplerState* getRawInterface() {return static_cast<::ID3D10SamplerState*>(D3::DeviceChild::getRawInterface());}
      inline const ::ID3D10SamplerState* getRawInterface() const {return static_cast<const ::ID3D10SamplerState*>(D3::DeviceChild::getRawInterface());}
      inline void swap(SamplerState& other) {D3::DeviceChild::swap(other);}
      typedef ::ID3D10SamplerState dumb_t;

      // Methods
      D3D10_SAMPLER_DESC getDesc();
    };

    class Device : public COMObject
    {
    public:
      // Constructors
      Device() {}
      Device(nullptr_t) {}
      explicit Device(::ID3D10Device* raw) : COMObject(raw) {}
      Device(const Device& copy_from) : COMObject(copy_from) {}
      Device(Device&& move_from) : COMObject(std::move(move_from)) {}

      // Operators
      inline Device& operator= (const Device& copy_from) {COMObject::operator=(copy_from); return *this;}
      inline Device& operator= (Device&& move_from) {COMObject::operator=(std::move(move_from)); return *this;}
      _OPERATOR_BOOL() const {return getRawInterface() ? _CONVERTIBLE_TO_TRUE : 0;}

      // Utilities
      inline ::ID3D10Device* getRawInterface() {return static_cast<::ID3D10Device*>(COMObject::getRawInterface());}
      inline const ::ID3D10Device* getRawInterface() const {return static_cast<const ::ID3D10Device*>(COMObject::getRawInterface());}
      inline void swap(Device& other) {COMObject::swap(other);}
      typedef ::ID3D10Device dumb_t;

      // Methods
      std::vector<D3D10_VIEWPORT> RSGetViewports(unsigned int* NumViewports);
      void GSSetShader();
      void GSSetShader(D3::GeometryShader& pShader);
      D3::RasterizerState createRasterizerState(const D3D10_RASTERIZER_DESC& pRasterizerDesc);

      template <typename SmartContainer>
      SmartContainer openSharedResource(HANDLE hResource)
      {
        void* ppResource;
        HRESULT hr = getRawInterface()->OpenSharedResource(hResource, __uuidof(typename SmartContainer::dumb_t), &ppResource);
        if(FAILED(hr)) throw COMException(hr, "ID3D10Device::OpenSharedResource");
        return SmartContainer(static_cast<typename SmartContainer::dumb_t*>(ppResource));
      }

      void RSSetViewports();

      template <typename const_D3D10_VIEWPORT_Container>
      void RSSetViewports(const_D3D10_VIEWPORT_Container&& pViewports)
      {
        getRawInterface()->RSSetViewports(static_cast<unsigned int>(C6::internal::ecount<const_D3D10_VIEWPORT_Container>::size(pViewports)), C6::internal::ecount<const_D3D10_VIEWPORT_Container>::data(pViewports));
      }

      D3::PixelShader PSGetShader();
      std::tuple<unsigned int, unsigned int> getTextFilterSize();

      template <typename const_void_Container>
      typename C6::internal::konst<D3::PixelShader, const_void_Container>::T createPixelShader(const_void_Container&& pShaderBytecode)
      {
        ID3D10PixelShader* ppPixelShader = nullptr;
        HRESULT hr = getRawInterface()->CreatePixelShader(C6::internal::ecount<const_void_Container>::data(pShaderBytecode), static_cast<SIZE_T>(C6::internal::ecount<const_void_Container>::size(pShaderBytecode) * C6::internal::bcount<decltype(pShaderBytecode.data())>::elem_size), &ppPixelShader);
        if(FAILED(hr)) throw COMException(hr, "ID3D10Device::CreatePixelShader");
        return D3::PixelShader(ppPixelShader);
      }

      void VSSetShader();
      void VSSetShader(D3::VertexShader& pVertexShader);
      std::vector<ID3D10ShaderResourceView*> VSGetShaderResources(unsigned int StartSlot, unsigned int NumViews);
      D3::VertexShader VSGetShader();
      void drawInstanced(unsigned int VertexCountPerInstance, unsigned int InstanceCount, unsigned int StartVertexLocation, unsigned int StartInstanceLocation);
      void drawIndexed(unsigned int IndexCount, unsigned int StartIndexLocation, int BaseVertexLocation);
      void copyResource(D3::Resource& pDstResource, D3::Resource& pSrcResource);
      std::tuple<std::vector<ID3D10Buffer*>, std::vector<unsigned int>> SOGetTargets(unsigned int NumBuffers);
      std::vector<ID3D10ShaderResourceView*> PSGetShaderResources(unsigned int StartSlot, unsigned int NumViews);
      D3::InputLayout IAGetInputLayout();
      void setTextFilterSize(unsigned int Width, unsigned int Height);
      void PSSetShader();
      void PSSetShader(D3::PixelShader& pPixelShader);
      void updateSubresource(D3::Resource& pDstResource, unsigned int DstSubresource, const void* pSrcData, unsigned int SrcRowPitch, unsigned int SrcDepthPitch);
      void updateSubresource(D3::Resource& pDstResource, unsigned int DstSubresource, const D3D10_BOX& pDstBox, const void* pSrcData, unsigned int SrcRowPitch, unsigned int SrcDepthPitch);
      unsigned int checkMultisampleQualityLevels(DXGI_FORMAT Format, unsigned int SampleCount);
      void clearState();
      void OMSetDepthStencilState(unsigned int StencilRef);
      void OMSetDepthStencilState(D3::DepthStencilState& pDepthStencilState, unsigned int StencilRef);
      std::vector<ID3D10Buffer*> PSGetConstantBuffers(unsigned int StartSlot, unsigned int NumBuffers);

      template <typename const_D3D10_INPUT_ELEMENT_DESC_Container, typename const_void_Container>
      typename C6::internal::konst<D3::InputLayout, const_void_Container>::T createInputLayout(const_D3D10_INPUT_ELEMENT_DESC_Container&& pInputElementDescs, const_void_Container&& pShaderBytecodeWithInputSignature)
      {
        ID3D10InputLayout* ppInputLayout = nullptr;
        HRESULT hr = getRawInterface()->CreateInputLayout(C6::internal::ecount<const_D3D10_INPUT_ELEMENT_DESC_Container>::data(pInputElementDescs), static_cast<unsigned int>(C6::internal::ecount<const_D3D10_INPUT_ELEMENT_DESC_Container>::size(pInputElementDescs)), C6::internal::ecount<const_void_Container>::data(pShaderBytecodeWithInputSignature), static_cast<SIZE_T>(C6::internal::ecount<const_void_Container>::size(pShaderBytecodeWithInputSignature) * C6::internal::bcount<decltype(pShaderBytecodeWithInputSignature.data())>::elem_size), &ppInputLayout);
        if(FAILED(hr)) throw COMException(hr, "ID3D10Device::CreateInputLayout");
        return D3::InputLayout(ppInputLayout);
      }

      std::vector<ID3D10SamplerState*> PSGetSamplers(unsigned int StartSlot, unsigned int NumSamplers);
      std::vector<ID3D10Buffer*> GSGetConstantBuffers(unsigned int StartSlot, unsigned int NumBuffers);
      void drawAuto();
      D3::BlendState createBlendState(const D3D10_BLEND_DESC& pBlendStateDesc);
      void OMSetBlendState(const float BlendFactor[4], unsigned int SampleMask);
      void OMSetBlendState(D3::BlendState& pBlendState, const float BlendFactor[4], unsigned int SampleMask);
      void RSSetScissorRects();

      template <typename const_D3D10_RECT_Container>
      void RSSetScissorRects(const_D3D10_RECT_Container&& pRects)
      {
        getRawInterface()->RSSetScissorRects(static_cast<unsigned int>(C6::internal::ecount<const_D3D10_RECT_Container>::size(pRects)), C6::internal::ecount<const_D3D10_RECT_Container>::data(pRects));
      }

      std::vector<ID3D10SamplerState*> GSGetSamplers(unsigned int StartSlot, unsigned int NumSamplers);
      void SOSetTargets();

      template <typename ID3D10Buffer__const_Container>
      void SOSetTargets(ID3D10Buffer__const_Container&& ppSOTargets)
      {
        getRawInterface()->SOSetTargets(static_cast<unsigned int>(C6::internal::ecount<ID3D10Buffer__const_Container>::size(ppSOTargets)), C6::internal::ecount<ID3D10Buffer__const_Container>::data(ppSOTargets), nullptr);
      }


      template <typename ID3D10Buffer__const_Container, typename const_unsigned_int_Container>
      void SOSetTargets(ID3D10Buffer__const_Container&& ppSOTargets, const_unsigned_int_Container&& pOffsets)
      {
        getRawInterface()->SOSetTargets((std::min)(static_cast<unsigned int>(C6::internal::ecount<ID3D10Buffer__const_Container>::size(ppSOTargets)), static_cast<unsigned int>(C6::internal::ecount<const_unsigned_int_Container>::size(pOffsets))), C6::internal::ecount<ID3D10Buffer__const_Container>::data(ppSOTargets), C6::internal::ecount<const_unsigned_int_Container>::data(pOffsets));
      }

      std::tuple<D3::BlendState, unsigned int> OMGetBlendState(float BlendFactor[4]);
      void getPrivateData(REFGUID guid, unsigned int* pDataSize, void* pData);
      unsigned int getCreationFlags();
      D3::ShaderResourceView createShaderResourceView(D3::Resource& pResource);
      D3::ShaderResourceView createShaderResourceView(D3::Resource& pResource, const D3D10_SHADER_RESOURCE_VIEW_DESC& pDesc);

      template <typename ID3D10Buffer__const_Container>
      void GSSetConstantBuffers(unsigned int StartSlot, ID3D10Buffer__const_Container&& ppConstantBuffers)
      {
        getRawInterface()->GSSetConstantBuffers(StartSlot, static_cast<unsigned int>(C6::internal::ecount<ID3D10Buffer__const_Container>::size(ppConstantBuffers)), C6::internal::ecount<ID3D10Buffer__const_Container>::data(ppConstantBuffers));
      }


      template <typename ID3D10Buffer__const_Container>
      void VSSetConstantBuffers(unsigned int StartSlot, ID3D10Buffer__const_Container&& ppConstantBuffers)
      {
        getRawInterface()->VSSetConstantBuffers(StartSlot, static_cast<unsigned int>(C6::internal::ecount<ID3D10Buffer__const_Container>::size(ppConstantBuffers)), C6::internal::ecount<ID3D10Buffer__const_Container>::data(ppConstantBuffers));
      }

      void IASetPrimitiveTopology(D3D10_PRIMITIVE_TOPOLOGY Topology);
      std::vector<D3D10_RECT> RSGetScissorRects(unsigned int* NumRects);

      template <typename ID3D10Buffer__const_Container>
      void PSSetConstantBuffers(unsigned int StartSlot, ID3D10Buffer__const_Container&& ppConstantBuffers)
      {
        getRawInterface()->PSSetConstantBuffers(StartSlot, static_cast<unsigned int>(C6::internal::ecount<ID3D10Buffer__const_Container>::size(ppConstantBuffers)), C6::internal::ecount<ID3D10Buffer__const_Container>::data(ppConstantBuffers));
      }

      std::tuple<D3D10_COUNTER_TYPE, unsigned int> checkCounter(const D3D10_COUNTER_DESC& pDesc, LPSTR szName, unsigned int* pNameLength, LPSTR szUnits, unsigned int* pUnitsLength, LPSTR szDescription, unsigned int* pDescriptionLength);
      D3D10_COUNTER_INFO checkCounterInfo();
      unsigned int checkFormatSupport(DXGI_FORMAT Format);
      D3::Counter createCounter(const D3D10_COUNTER_DESC& pCounterDesc);
      D3::Query createQuery(const D3D10_QUERY_DESC& pQueryDesc);
      void OMSetRenderTargets();

      template <typename ID3D10RenderTargetView__const_Container>
      void OMSetRenderTargets(ID3D10RenderTargetView__const_Container&& ppRenderTargetViews)
      {
        getRawInterface()->OMSetRenderTargets(static_cast<unsigned int>(C6::internal::ecount<ID3D10RenderTargetView__const_Container>::size(ppRenderTargetViews)), C6::internal::ecount<ID3D10RenderTargetView__const_Container>::data(ppRenderTargetViews), nullptr);
      }


      template <typename ID3D10RenderTargetView__const_Container>
      void OMSetRenderTargets(ID3D10RenderTargetView__const_Container&& ppRenderTargetViews, D3::DepthStencilView& pDepthStencilView)
      {
        getRawInterface()->OMSetRenderTargets(static_cast<unsigned int>(C6::internal::ecount<ID3D10RenderTargetView__const_Container>::size(ppRenderTargetViews)), C6::internal::ecount<ID3D10RenderTargetView__const_Container>::data(ppRenderTargetViews), pDepthStencilView.getRawInterface());
      }

      std::tuple<D3::Buffer, DXGI_FORMAT, unsigned int> IAGetIndexBuffer();
      void IASetInputLayout();
      void IASetInputLayout(D3::InputLayout& pInputLayout);
      void setPrivateData(REFGUID guid);

      template <typename const_void_Container>
      void setPrivateData(REFGUID guid, const_void_Container&& pData)
      {
        HRESULT hr = getRawInterface()->SetPrivateData(guid, static_cast<unsigned int>(C6::internal::ecount<const_void_Container>::size(pData) * C6::internal::bcount<decltype(pData.data())>::elem_size), C6::internal::ecount<const_void_Container>::data(pData));
        if(FAILED(hr)) throw COMException(hr, "ID3D10Device::SetPrivateData");
      }

      void draw(unsigned int VertexCount, unsigned int StartVertexLocation);
      void flush();
      D3::DepthStencilState createDepthStencilState(const D3D10_DEPTH_STENCIL_DESC& pDepthStencilDesc);
      D3D10_PRIMITIVE_TOPOLOGY IAGetPrimitiveTopology();
      std::tuple<D3::DepthStencilState, unsigned int> OMGetDepthStencilState();

      template <typename const_void_Container>
      typename C6::internal::konst<D3::GeometryShader, const_void_Container>::T createGeometryShaderWithStreamOutput(const_void_Container&& pShaderBytecode, unsigned int OutputStreamStride)
      {
        ID3D10GeometryShader* ppGeometryShader = nullptr;
        HRESULT hr = getRawInterface()->CreateGeometryShaderWithStreamOutput(C6::internal::ecount<const_void_Container>::data(pShaderBytecode), static_cast<SIZE_T>(C6::internal::ecount<const_void_Container>::size(pShaderBytecode) * C6::internal::bcount<decltype(pShaderBytecode.data())>::elem_size), nullptr, 0, OutputStreamStride, &ppGeometryShader);
        if(FAILED(hr)) throw COMException(hr, "ID3D10Device::CreateGeometryShaderWithStreamOutput");
        return D3::GeometryShader(ppGeometryShader);
      }


      template <typename const_void_Container, typename const_D3D10_SO_DECLARATION_ENTRY_Container>
      typename C6::internal::konst<D3::GeometryShader, const_D3D10_SO_DECLARATION_ENTRY_Container>::T createGeometryShaderWithStreamOutput(const_void_Container&& pShaderBytecode, const_D3D10_SO_DECLARATION_ENTRY_Container&& pSODeclaration, unsigned int OutputStreamStride)
      {
        ID3D10GeometryShader* ppGeometryShader = nullptr;
        HRESULT hr = getRawInterface()->CreateGeometryShaderWithStreamOutput(C6::internal::ecount<const_void_Container>::data(pShaderBytecode), static_cast<SIZE_T>(C6::internal::ecount<const_void_Container>::size(pShaderBytecode) * C6::internal::bcount<decltype(pShaderBytecode.data())>::elem_size), C6::internal::ecount<const_D3D10_SO_DECLARATION_ENTRY_Container>::data(pSODeclaration), static_cast<unsigned int>(C6::internal::ecount<const_D3D10_SO_DECLARATION_ENTRY_Container>::size(pSODeclaration)), OutputStreamStride, &ppGeometryShader);
        if(FAILED(hr)) throw COMException(hr, "ID3D10Device::CreateGeometryShaderWithStreamOutput");
        return D3::GeometryShader(ppGeometryShader);
      }


      template <typename const_void_Container>
      typename C6::internal::konst<D3::GeometryShader, const_void_Container>::T createGeometryShader(const_void_Container&& pShaderBytecode)
      {
        ID3D10GeometryShader* ppGeometryShader = nullptr;
        HRESULT hr = getRawInterface()->CreateGeometryShader(C6::internal::ecount<const_void_Container>::data(pShaderBytecode), static_cast<SIZE_T>(C6::internal::ecount<const_void_Container>::size(pShaderBytecode) * C6::internal::bcount<decltype(pShaderBytecode.data())>::elem_size), &ppGeometryShader);
        if(FAILED(hr)) throw COMException(hr, "ID3D10Device::CreateGeometryShader");
        return D3::GeometryShader(ppGeometryShader);
      }

      void setPrivateDataInterface(REFGUID guid);
      void setPrivateDataInterface(REFGUID guid, const IUnknown& pData);

      template <typename ID3D10SamplerState__const_Container>
      void VSSetSamplers(unsigned int StartSlot, ID3D10SamplerState__const_Container&& ppSamplers)
      {
        getRawInterface()->VSSetSamplers(StartSlot, static_cast<unsigned int>(C6::internal::ecount<ID3D10SamplerState__const_Container>::size(ppSamplers)), C6::internal::ecount<ID3D10SamplerState__const_Container>::data(ppSamplers));
      }

      void clearRenderTargetView(D3::RenderTargetView& pRenderTargetView, const float ColorRGBA[4]);

      template <typename ID3D10SamplerState__const_Container>
      void PSSetSamplers(unsigned int StartSlot, ID3D10SamplerState__const_Container&& ppSamplers)
      {
        getRawInterface()->PSSetSamplers(StartSlot, static_cast<unsigned int>(C6::internal::ecount<ID3D10SamplerState__const_Container>::size(ppSamplers)), C6::internal::ecount<ID3D10SamplerState__const_Container>::data(ppSamplers));
      }

      D3::RenderTargetView createRenderTargetView(D3::Resource& pResource);
      D3::RenderTargetView createRenderTargetView(D3::Resource& pResource, const D3D10_RENDER_TARGET_VIEW_DESC& pDesc);

      template <typename ID3D10ShaderResourceView__const_Container>
      void GSSetShaderResources(unsigned int StartSlot, ID3D10ShaderResourceView__const_Container&& ppShaderResourceViews)
      {
        getRawInterface()->GSSetShaderResources(StartSlot, static_cast<unsigned int>(C6::internal::ecount<ID3D10ShaderResourceView__const_Container>::size(ppShaderResourceViews)), C6::internal::ecount<ID3D10ShaderResourceView__const_Container>::data(ppShaderResourceViews));
      }

      D3::DepthStencilView createDepthStencilView(D3::Resource& pResource);
      D3::DepthStencilView createDepthStencilView(D3::Resource& pResource, const D3D10_DEPTH_STENCIL_VIEW_DESC& pDesc);
      D3::RasterizerState RSGetState();
      void generateMips(D3::ShaderResourceView& pShaderResourceView);
      D3::Texture2D createTexture2D(const D3D10_TEXTURE2D_DESC& pDesc);
      D3::Texture2D createTexture2D(const D3D10_TEXTURE2D_DESC& pDesc, const D3D10_SUBRESOURCE_DATA& pInitialData);
      D3::GeometryShader GSGetShader();
      D3::Buffer createBuffer(const D3D10_BUFFER_DESC& pDesc);
      D3::Buffer createBuffer(const D3D10_BUFFER_DESC& pDesc, const D3D10_SUBRESOURCE_DATA& pInitialData);
      std::vector<ID3D10ShaderResourceView*> GSGetShaderResources(unsigned int StartSlot, unsigned int NumViews);

      template <typename const_void_Container>
      typename C6::internal::konst<D3::VertexShader, const_void_Container>::T createVertexShader(const_void_Container&& pShaderBytecode)
      {
        ID3D10VertexShader* ppVertexShader = nullptr;
        HRESULT hr = getRawInterface()->CreateVertexShader(C6::internal::ecount<const_void_Container>::data(pShaderBytecode), static_cast<SIZE_T>(C6::internal::ecount<const_void_Container>::size(pShaderBytecode) * C6::internal::bcount<decltype(pShaderBytecode.data())>::elem_size), &ppVertexShader);
        if(FAILED(hr)) throw COMException(hr, "ID3D10Device::CreateVertexShader");
        return D3::VertexShader(ppVertexShader);
      }

      D3::SamplerState createSamplerState(const D3D10_SAMPLER_DESC& pSamplerDesc);
      void copySubresourceRegion(D3::Resource& pDstResource, unsigned int DstSubresource, unsigned int DstX, unsigned int DstY, unsigned int DstZ, D3::Resource& pSrcResource, unsigned int SrcSubresource);
      void copySubresourceRegion(D3::Resource& pDstResource, unsigned int DstSubresource, unsigned int DstX, unsigned int DstY, unsigned int DstZ, D3::Resource& pSrcResource, unsigned int SrcSubresource, const D3D10_BOX& pSrcBox);
      D3::Texture1D createTexture1D(const D3D10_TEXTURE1D_DESC& pDesc);
      D3::Texture1D createTexture1D(const D3D10_TEXTURE1D_DESC& pDesc, const D3D10_SUBRESOURCE_DATA& pInitialData);

      template <typename ID3D10Buffer__const_Container, typename const_unsigned_int_Container, typename const_unsigned_int_Container2>
      void IASetVertexBuffers(unsigned int StartSlot, ID3D10Buffer__const_Container&& ppVertexBuffers, const_unsigned_int_Container&& pStrides, const_unsigned_int_Container2&& pOffsets)
      {
        getRawInterface()->IASetVertexBuffers(StartSlot, (std::min)((std::min)(static_cast<unsigned int>(C6::internal::ecount<ID3D10Buffer__const_Container>::size(ppVertexBuffers)), static_cast<unsigned int>(C6::internal::ecount<const_unsigned_int_Container>::size(pStrides))), static_cast<unsigned int>(C6::internal::ecount<const_unsigned_int_Container2>::size(pOffsets))), C6::internal::ecount<ID3D10Buffer__const_Container>::data(ppVertexBuffers), C6::internal::ecount<const_unsigned_int_Container>::data(pStrides), C6::internal::ecount<const_unsigned_int_Container2>::data(pOffsets));
      }

      void setExceptionMode(unsigned int RaiseFlags);
      std::vector<ID3D10SamplerState*> VSGetSamplers(unsigned int StartSlot, unsigned int NumSamplers);
      void RSSetState();
      void RSSetState(D3::RasterizerState& pRasterizerState);
      D3::Texture3D createTexture3D(const D3D10_TEXTURE3D_DESC& pDesc);
      D3::Texture3D createTexture3D(const D3D10_TEXTURE3D_DESC& pDesc, const D3D10_SUBRESOURCE_DATA& pInitialData);
      void drawIndexedInstanced(unsigned int IndexCountPerInstance, unsigned int InstanceCount, unsigned int StartIndexLocation, int BaseVertexLocation, unsigned int StartInstanceLocation);
      void resolveSubresource(D3::Resource& pDstResource, unsigned int DstSubresource, D3::Resource& pSrcResource, unsigned int SrcSubresource, DXGI_FORMAT Format);
      D3::Predicate createPredicate(const D3D10_QUERY_DESC& pPredicateDesc);
      std::tuple<D3::Predicate, bool> getPredication();
      void clearDepthStencilView(D3::DepthStencilView& pDepthStencilView, unsigned int ClearFlags, float Depth, UINT8 Stencil);

      template <typename ID3D10SamplerState__const_Container>
      void GSSetSamplers(unsigned int StartSlot, ID3D10SamplerState__const_Container&& ppSamplers)
      {
        getRawInterface()->GSSetSamplers(StartSlot, static_cast<unsigned int>(C6::internal::ecount<ID3D10SamplerState__const_Container>::size(ppSamplers)), C6::internal::ecount<ID3D10SamplerState__const_Container>::data(ppSamplers));
      }

      std::tuple<std::vector<ID3D10Buffer*>, std::vector<unsigned int>, std::vector<unsigned int>> IAGetVertexBuffers(unsigned int StartSlot, unsigned int NumBuffers);
      void setPredication(BOOL PredicateValue);
      void setPredication(D3::Predicate& pPredicate, BOOL PredicateValue);
      unsigned int getExceptionMode();
      void getDeviceRemovedReason();

      template <typename ID3D10ShaderResourceView__const_Container>
      void PSSetShaderResources(unsigned int StartSlot, ID3D10ShaderResourceView__const_Container&& ppShaderResourceViews)
      {
        getRawInterface()->PSSetShaderResources(StartSlot, static_cast<unsigned int>(C6::internal::ecount<ID3D10ShaderResourceView__const_Container>::size(ppShaderResourceViews)), C6::internal::ecount<ID3D10ShaderResourceView__const_Container>::data(ppShaderResourceViews));
      }


      template <typename ID3D10ShaderResourceView__const_Container>
      void VSSetShaderResources(unsigned int StartSlot, ID3D10ShaderResourceView__const_Container&& ppShaderResourceViews)
      {
        getRawInterface()->VSSetShaderResources(StartSlot, static_cast<unsigned int>(C6::internal::ecount<ID3D10ShaderResourceView__const_Container>::size(ppShaderResourceViews)), C6::internal::ecount<ID3D10ShaderResourceView__const_Container>::data(ppShaderResourceViews));
      }

      std::tuple<std::vector<ID3D10RenderTargetView*>, D3::DepthStencilView> OMGetRenderTargets(unsigned int NumViews);
      void IASetIndexBuffer(DXGI_FORMAT Format, unsigned int Offset);
      void IASetIndexBuffer(D3::Buffer& pIndexBuffer, DXGI_FORMAT Format, unsigned int Offset);
      std::vector<ID3D10Buffer*> VSGetConstantBuffers(unsigned int StartSlot, unsigned int NumBuffers);
    };

    class Device1 : public D3::Device
    {
    public:
      // Constructors
      Device1() {}
      Device1(nullptr_t) {}
      explicit Device1(::ID3D10Device1* raw) : D3::Device(raw) {}
      Device1(const Device1& copy_from) : D3::Device(copy_from) {}
      Device1(Device1&& move_from) : D3::Device(std::move(move_from)) {}

      // Operators
      inline Device1& operator= (const Device1& copy_from) {D3::Device::operator=(copy_from); return *this;}
      inline Device1& operator= (Device1&& move_from) {D3::Device::operator=(std::move(move_from)); return *this;}
      _OPERATOR_BOOL() const {return getRawInterface() ? _CONVERTIBLE_TO_TRUE : 0;}

      // Utilities
      inline ::ID3D10Device1* getRawInterface() {return static_cast<::ID3D10Device1*>(D3::Device::getRawInterface());}
      inline const ::ID3D10Device1* getRawInterface() const {return static_cast<const ::ID3D10Device1*>(D3::Device::getRawInterface());}
      inline void swap(Device1& other) {D3::Device::swap(other);}
      typedef ::ID3D10Device1 dumb_t;

      // Methods
      D3::ShaderResourceView1 createShaderResourceView1(D3::Resource& pResource);
      D3::ShaderResourceView1 createShaderResourceView1(D3::Resource& pResource, const D3D10_SHADER_RESOURCE_VIEW_DESC1& pDesc);
      D3D10_FEATURE_LEVEL1 getFeatureLevel();
      D3::BlendState1 createBlendState1(const D3D10_BLEND_DESC1& pBlendStateDesc);
    };
  }
  namespace internal
  {
    template <>
    struct ecount<D3::Multithread&>
    {
      static size_t size(D3::Multithread& x) {return 1;}
      static ID3D10Multithread*const* data(D3::Multithread& x) {return reinterpret_cast<ID3D10Multithread*const*>(&x);}
    };
    template <>
    struct ecount<D3::DeviceChild&>
    {
      static size_t size(D3::DeviceChild& x) {return 1;}
      static ID3D10DeviceChild*const* data(D3::DeviceChild& x) {return reinterpret_cast<ID3D10DeviceChild*const*>(&x);}
    };
    template <>
    struct ecount<D3::PixelShader&>
    {
      static size_t size(D3::PixelShader& x) {return 1;}
      static ID3D10PixelShader*const* data(D3::PixelShader& x) {return reinterpret_cast<ID3D10PixelShader*const*>(&x);}
    };
    template <>
    struct ecount<D3::VertexShader&>
    {
      static size_t size(D3::VertexShader& x) {return 1;}
      static ID3D10VertexShader*const* data(D3::VertexShader& x) {return reinterpret_cast<ID3D10VertexShader*const*>(&x);}
    };
    template <>
    struct ecount<D3::GeometryShader&>
    {
      static size_t size(D3::GeometryShader& x) {return 1;}
      static ID3D10GeometryShader*const* data(D3::GeometryShader& x) {return reinterpret_cast<ID3D10GeometryShader*const*>(&x);}
    };
    template <>
    struct ecount<D3::RasterizerState&>
    {
      static size_t size(D3::RasterizerState& x) {return 1;}
      static ID3D10RasterizerState*const* data(D3::RasterizerState& x) {return reinterpret_cast<ID3D10RasterizerState*const*>(&x);}
    };
    template <>
    struct ecount<D3::BlendState&>
    {
      static size_t size(D3::BlendState& x) {return 1;}
      static ID3D10BlendState*const* data(D3::BlendState& x) {return reinterpret_cast<ID3D10BlendState*const*>(&x);}
    };
    template <>
    struct ecount<D3::BlendState1&>
    {
      static size_t size(D3::BlendState1& x) {return 1;}
      static ID3D10BlendState1*const* data(D3::BlendState1& x) {return reinterpret_cast<ID3D10BlendState1*const*>(&x);}
    };
    template <>
    struct ecount<D3::Asynchronous&>
    {
      static size_t size(D3::Asynchronous& x) {return 1;}
      static ID3D10Asynchronous*const* data(D3::Asynchronous& x) {return reinterpret_cast<ID3D10Asynchronous*const*>(&x);}
    };
    template <>
    struct ecount<D3::Query&>
    {
      static size_t size(D3::Query& x) {return 1;}
      static ID3D10Query*const* data(D3::Query& x) {return reinterpret_cast<ID3D10Query*const*>(&x);}
    };
    template <>
    struct ecount<D3::Predicate&>
    {
      static size_t size(D3::Predicate& x) {return 1;}
      static ID3D10Predicate*const* data(D3::Predicate& x) {return reinterpret_cast<ID3D10Predicate*const*>(&x);}
    };
    template <>
    struct ecount<D3::Counter&>
    {
      static size_t size(D3::Counter& x) {return 1;}
      static ID3D10Counter*const* data(D3::Counter& x) {return reinterpret_cast<ID3D10Counter*const*>(&x);}
    };
    template <>
    struct ecount<D3::Resource&>
    {
      static size_t size(D3::Resource& x) {return 1;}
      static ID3D10Resource*const* data(D3::Resource& x) {return reinterpret_cast<ID3D10Resource*const*>(&x);}
    };
    template <>
    struct ecount<D3::Texture1D&>
    {
      static size_t size(D3::Texture1D& x) {return 1;}
      static ID3D10Texture1D*const* data(D3::Texture1D& x) {return reinterpret_cast<ID3D10Texture1D*const*>(&x);}
    };
    template <>
    struct ecount<D3::Texture2D&>
    {
      static size_t size(D3::Texture2D& x) {return 1;}
      static ID3D10Texture2D*const* data(D3::Texture2D& x) {return reinterpret_cast<ID3D10Texture2D*const*>(&x);}
    };
    template <>
    struct ecount<D3::Texture3D&>
    {
      static size_t size(D3::Texture3D& x) {return 1;}
      static ID3D10Texture3D*const* data(D3::Texture3D& x) {return reinterpret_cast<ID3D10Texture3D*const*>(&x);}
    };
    template <>
    struct ecount<D3::Buffer&>
    {
      static size_t size(D3::Buffer& x) {return 1;}
      static ID3D10Buffer*const* data(D3::Buffer& x) {return reinterpret_cast<ID3D10Buffer*const*>(&x);}
    };
    template <>
    struct ecount<D3::InputLayout&>
    {
      static size_t size(D3::InputLayout& x) {return 1;}
      static ID3D10InputLayout*const* data(D3::InputLayout& x) {return reinterpret_cast<ID3D10InputLayout*const*>(&x);}
    };
    template <>
    struct ecount<D3::DepthStencilState&>
    {
      static size_t size(D3::DepthStencilState& x) {return 1;}
      static ID3D10DepthStencilState*const* data(D3::DepthStencilState& x) {return reinterpret_cast<ID3D10DepthStencilState*const*>(&x);}
    };
    template <>
    struct ecount<D3::View&>
    {
      static size_t size(D3::View& x) {return 1;}
      static ID3D10View*const* data(D3::View& x) {return reinterpret_cast<ID3D10View*const*>(&x);}
    };
    template <>
    struct ecount<D3::RenderTargetView&>
    {
      static size_t size(D3::RenderTargetView& x) {return 1;}
      static ID3D10RenderTargetView*const* data(D3::RenderTargetView& x) {return reinterpret_cast<ID3D10RenderTargetView*const*>(&x);}
    };
    template <>
    struct ecount<D3::ShaderResourceView&>
    {
      static size_t size(D3::ShaderResourceView& x) {return 1;}
      static ID3D10ShaderResourceView*const* data(D3::ShaderResourceView& x) {return reinterpret_cast<ID3D10ShaderResourceView*const*>(&x);}
    };
    template <>
    struct ecount<D3::ShaderResourceView1&>
    {
      static size_t size(D3::ShaderResourceView1& x) {return 1;}
      static ID3D10ShaderResourceView1*const* data(D3::ShaderResourceView1& x) {return reinterpret_cast<ID3D10ShaderResourceView1*const*>(&x);}
    };
    template <>
    struct ecount<D3::DepthStencilView&>
    {
      static size_t size(D3::DepthStencilView& x) {return 1;}
      static ID3D10DepthStencilView*const* data(D3::DepthStencilView& x) {return reinterpret_cast<ID3D10DepthStencilView*const*>(&x);}
    };
    template <>
    struct ecount<D3::SamplerState&>
    {
      static size_t size(D3::SamplerState& x) {return 1;}
      static ID3D10SamplerState*const* data(D3::SamplerState& x) {return reinterpret_cast<ID3D10SamplerState*const*>(&x);}
    };
    template <>
    struct ecount<D3::Device&>
    {
      static size_t size(D3::Device& x) {return 1;}
      static ID3D10Device*const* data(D3::Device& x) {return reinterpret_cast<ID3D10Device*const*>(&x);}
    };
    template <>
    struct ecount<D3::Device1&>
    {
      static size_t size(D3::Device1& x) {return 1;}
      static ID3D10Device1*const* data(D3::Device1& x) {return reinterpret_cast<ID3D10Device1*const*>(&x);}
    };
  }
}
namespace std {
  inline void swap(C6::D3::PixelShader& a, C6::D3::PixelShader& b) {a.swap(b);}
  inline void swap(C6::D3::Predicate& a, C6::D3::Predicate& b) {a.swap(b);}
  inline void swap(C6::D3::BlendState& a, C6::D3::BlendState& b) {a.swap(b);}
  inline void swap(C6::D3::Multithread& a, C6::D3::Multithread& b) {a.swap(b);}
  inline void swap(C6::D3::Resource& a, C6::D3::Resource& b) {a.swap(b);}
  inline void swap(C6::D3::Device1& a, C6::D3::Device1& b) {a.swap(b);}
  inline void swap(C6::D3::Buffer& a, C6::D3::Buffer& b) {a.swap(b);}
  inline void swap(C6::D3::Texture1D& a, C6::D3::Texture1D& b) {a.swap(b);}
  inline void swap(C6::D3::DepthStencilView& a, C6::D3::DepthStencilView& b) {a.swap(b);}
  inline void swap(C6::D3::Texture3D& a, C6::D3::Texture3D& b) {a.swap(b);}
  inline void swap(C6::D3::SamplerState& a, C6::D3::SamplerState& b) {a.swap(b);}
  inline void swap(C6::D3::RenderTargetView& a, C6::D3::RenderTargetView& b) {a.swap(b);}
  inline void swap(C6::D3::GeometryShader& a, C6::D3::GeometryShader& b) {a.swap(b);}
  inline void swap(C6::D3::VertexShader& a, C6::D3::VertexShader& b) {a.swap(b);}
  inline void swap(C6::D3::Texture2D& a, C6::D3::Texture2D& b) {a.swap(b);}
  inline void swap(C6::D3::Query& a, C6::D3::Query& b) {a.swap(b);}
  inline void swap(C6::D3::ShaderResourceView& a, C6::D3::ShaderResourceView& b) {a.swap(b);}
  inline void swap(C6::D3::ShaderResourceView1& a, C6::D3::ShaderResourceView1& b) {a.swap(b);}
  inline void swap(C6::D3::View& a, C6::D3::View& b) {a.swap(b);}
  inline void swap(C6::D3::InputLayout& a, C6::D3::InputLayout& b) {a.swap(b);}
  inline void swap(C6::D3::Device& a, C6::D3::Device& b) {a.swap(b);}
  inline void swap(C6::D3::Asynchronous& a, C6::D3::Asynchronous& b) {a.swap(b);}
  inline void swap(C6::D3::DeviceChild& a, C6::D3::DeviceChild& b) {a.swap(b);}
  inline void swap(C6::D3::DepthStencilState& a, C6::D3::DepthStencilState& b) {a.swap(b);}
  inline void swap(C6::D3::Counter& a, C6::D3::Counter& b) {a.swap(b);}
  inline void swap(C6::D3::RasterizerState& a, C6::D3::RasterizerState& b) {a.swap(b);}
  inline void swap(C6::D3::BlendState1& a, C6::D3::BlendState1& b) {a.swap(b);}
}
