#pragma once
// Autogenerated by nicify.lua -- do not edit by hand.
#include <dxgi.h>
#include "com.h"
namespace C6
{
  namespace DXGI
  {
    class KeyedMutex;
    class Adapter1;
    class Output;
    class DeviceSubObject;
    class Surface1;
    class Factory1;
    class Device;
    class Adapter;
    class Device1;
    class Surface;
    class Object;
    class Factory;
    class Resource;
    class SwapChain;

    class Object : public COMObject
    {
    public:
      // Constructors
      Object() {}
      Object(nullptr_t) {}
      explicit Object(::IDXGIObject* raw) : COMObject(raw) {}
      Object(const Object& copy_from) : COMObject(copy_from) {}
      Object(Object&& move_from) : COMObject(std::move(move_from)) {}

      // Operators
      inline Object& operator= (const Object& copy_from) {COMObject::operator=(copy_from); return *this;}
      inline Object& operator= (Object&& move_from) {COMObject::operator=(std::move(move_from)); return *this;}
      _OPERATOR_BOOL() const {return getRawInterface() ? _CONVERTIBLE_TO_TRUE : 0;}

      // Utilities
      inline ::IDXGIObject* getRawInterface() {return static_cast<::IDXGIObject*>(COMObject::getRawInterface());}
      inline const ::IDXGIObject* getRawInterface() const {return static_cast<const ::IDXGIObject*>(COMObject::getRawInterface());}
      inline void swap(Object& other) {COMObject::swap(other);}
      typedef ::IDXGIObject dumb_t;

      // Methods
      void setPrivateData(REFGUID Name, unsigned int DataSize, const void* pData);
      void getParent(REFIID riid, void** ppParent);
      void getPrivateData(REFGUID Name, unsigned int* pDataSize, void* pData);
      void setPrivateDataInterface(REFGUID Name, const IUnknown& pUnknown);
    };

    class Adapter : public DXGI::Object
    {
    public:
      // Constructors
      Adapter() {}
      Adapter(nullptr_t) {}
      explicit Adapter(::IDXGIAdapter* raw) : DXGI::Object(raw) {}
      Adapter(const Adapter& copy_from) : DXGI::Object(copy_from) {}
      Adapter(Adapter&& move_from) : DXGI::Object(std::move(move_from)) {}

      // Operators
      inline Adapter& operator= (const Adapter& copy_from) {DXGI::Object::operator=(copy_from); return *this;}
      inline Adapter& operator= (Adapter&& move_from) {DXGI::Object::operator=(std::move(move_from)); return *this;}
      _OPERATOR_BOOL() const {return getRawInterface() ? _CONVERTIBLE_TO_TRUE : 0;}

      // Utilities
      inline ::IDXGIAdapter* getRawInterface() {return static_cast<::IDXGIAdapter*>(DXGI::Object::getRawInterface());}
      inline const ::IDXGIAdapter* getRawInterface() const {return static_cast<const ::IDXGIAdapter*>(DXGI::Object::getRawInterface());}
      inline void swap(Adapter& other) {DXGI::Object::swap(other);}
      typedef ::IDXGIAdapter dumb_t;

      // Methods
      DXGI_ADAPTER_DESC getDesc();
      LARGE_INTEGER checkInterfaceSupport(REFGUID InterfaceName);
      void enumOutputs(unsigned int Output, IDXGIOutput** ppOutput);
    };

    class Adapter1 : public DXGI::Adapter
    {
    public:
      // Constructors
      Adapter1() {}
      Adapter1(nullptr_t) {}
      explicit Adapter1(::IDXGIAdapter1* raw) : DXGI::Adapter(raw) {}
      Adapter1(const Adapter1& copy_from) : DXGI::Adapter(copy_from) {}
      Adapter1(Adapter1&& move_from) : DXGI::Adapter(std::move(move_from)) {}

      // Operators
      inline Adapter1& operator= (const Adapter1& copy_from) {DXGI::Adapter::operator=(copy_from); return *this;}
      inline Adapter1& operator= (Adapter1&& move_from) {DXGI::Adapter::operator=(std::move(move_from)); return *this;}
      _OPERATOR_BOOL() const {return getRawInterface() ? _CONVERTIBLE_TO_TRUE : 0;}

      // Utilities
      inline ::IDXGIAdapter1* getRawInterface() {return static_cast<::IDXGIAdapter1*>(DXGI::Adapter::getRawInterface());}
      inline const ::IDXGIAdapter1* getRawInterface() const {return static_cast<const ::IDXGIAdapter1*>(DXGI::Adapter::getRawInterface());}
      inline void swap(Adapter1& other) {DXGI::Adapter::swap(other);}
      typedef ::IDXGIAdapter1 dumb_t;

      // Methods
      DXGI_ADAPTER_DESC1 getDesc1();
    };

    class Output : public DXGI::Object
    {
    public:
      // Constructors
      Output() {}
      Output(nullptr_t) {}
      explicit Output(::IDXGIOutput* raw) : DXGI::Object(raw) {}
      Output(const Output& copy_from) : DXGI::Object(copy_from) {}
      Output(Output&& move_from) : DXGI::Object(std::move(move_from)) {}

      // Operators
      inline Output& operator= (const Output& copy_from) {DXGI::Object::operator=(copy_from); return *this;}
      inline Output& operator= (Output&& move_from) {DXGI::Object::operator=(std::move(move_from)); return *this;}
      _OPERATOR_BOOL() const {return getRawInterface() ? _CONVERTIBLE_TO_TRUE : 0;}

      // Utilities
      inline ::IDXGIOutput* getRawInterface() {return static_cast<::IDXGIOutput*>(DXGI::Object::getRawInterface());}
      inline const ::IDXGIOutput* getRawInterface() const {return static_cast<const ::IDXGIOutput*>(DXGI::Object::getRawInterface());}
      inline void swap(Output& other) {DXGI::Object::swap(other);}
      typedef ::IDXGIOutput dumb_t;

      // Methods
      void releaseOwnership();
      DXGI_FRAME_STATISTICS getFrameStatistics();
      void takeOwnership(COMObject& pDevice, BOOL Exclusive);
      DXGI_MODE_DESC getDisplayModeList(DXGI_FORMAT EnumFormat, unsigned int Flags, unsigned int* pNumModes);
      void getDisplaySurfaceData(DXGI::Surface& pDestination);
      DXGI_MODE_DESC findClosestMatchingMode(const DXGI_MODE_DESC& pModeToMatch, COMObject& pConcernedDevice);
      void setGammaControl(const DXGI_GAMMA_CONTROL& pArray);
      void setDisplaySurface(DXGI::Surface& pScanoutSurface);
      DXGI_GAMMA_CONTROL_CAPABILITIES getGammaControlCapabilities();
      DXGI_GAMMA_CONTROL getGammaControl();
      void waitForVBlank();
      DXGI_OUTPUT_DESC getDesc();
    };

    class DeviceSubObject : public DXGI::Object
    {
    public:
      // Constructors
      DeviceSubObject() {}
      DeviceSubObject(nullptr_t) {}
      explicit DeviceSubObject(::IDXGIDeviceSubObject* raw) : DXGI::Object(raw) {}
      DeviceSubObject(const DeviceSubObject& copy_from) : DXGI::Object(copy_from) {}
      DeviceSubObject(DeviceSubObject&& move_from) : DXGI::Object(std::move(move_from)) {}

      // Operators
      inline DeviceSubObject& operator= (const DeviceSubObject& copy_from) {DXGI::Object::operator=(copy_from); return *this;}
      inline DeviceSubObject& operator= (DeviceSubObject&& move_from) {DXGI::Object::operator=(std::move(move_from)); return *this;}
      _OPERATOR_BOOL() const {return getRawInterface() ? _CONVERTIBLE_TO_TRUE : 0;}

      // Utilities
      inline ::IDXGIDeviceSubObject* getRawInterface() {return static_cast<::IDXGIDeviceSubObject*>(DXGI::Object::getRawInterface());}
      inline const ::IDXGIDeviceSubObject* getRawInterface() const {return static_cast<const ::IDXGIDeviceSubObject*>(DXGI::Object::getRawInterface());}
      inline void swap(DeviceSubObject& other) {DXGI::Object::swap(other);}
      typedef ::IDXGIDeviceSubObject dumb_t;

      // Methods
      void getDevice(REFIID riid, void** ppDevice);
    };

    class KeyedMutex : public DXGI::DeviceSubObject
    {
    public:
      // Constructors
      KeyedMutex() {}
      KeyedMutex(nullptr_t) {}
      explicit KeyedMutex(::IDXGIKeyedMutex* raw) : DXGI::DeviceSubObject(raw) {}
      KeyedMutex(const KeyedMutex& copy_from) : DXGI::DeviceSubObject(copy_from) {}
      KeyedMutex(KeyedMutex&& move_from) : DXGI::DeviceSubObject(std::move(move_from)) {}

      // Operators
      inline KeyedMutex& operator= (const KeyedMutex& copy_from) {DXGI::DeviceSubObject::operator=(copy_from); return *this;}
      inline KeyedMutex& operator= (KeyedMutex&& move_from) {DXGI::DeviceSubObject::operator=(std::move(move_from)); return *this;}
      _OPERATOR_BOOL() const {return getRawInterface() ? _CONVERTIBLE_TO_TRUE : 0;}

      // Utilities
      inline ::IDXGIKeyedMutex* getRawInterface() {return static_cast<::IDXGIKeyedMutex*>(DXGI::DeviceSubObject::getRawInterface());}
      inline const ::IDXGIKeyedMutex* getRawInterface() const {return static_cast<const ::IDXGIKeyedMutex*>(DXGI::DeviceSubObject::getRawInterface());}
      inline void swap(KeyedMutex& other) {DXGI::DeviceSubObject::swap(other);}
      typedef ::IDXGIKeyedMutex dumb_t;

      // Methods
      void acquireSync(uint64_t Key, DWORD dwMilliseconds);
      void releaseSync(uint64_t Key);
    };

    class Resource : public DXGI::DeviceSubObject
    {
    public:
      // Constructors
      Resource() {}
      Resource(nullptr_t) {}
      explicit Resource(::IDXGIResource* raw) : DXGI::DeviceSubObject(raw) {}
      Resource(const Resource& copy_from) : DXGI::DeviceSubObject(copy_from) {}
      Resource(Resource&& move_from) : DXGI::DeviceSubObject(std::move(move_from)) {}

      // Operators
      inline Resource& operator= (const Resource& copy_from) {DXGI::DeviceSubObject::operator=(copy_from); return *this;}
      inline Resource& operator= (Resource&& move_from) {DXGI::DeviceSubObject::operator=(std::move(move_from)); return *this;}
      _OPERATOR_BOOL() const {return getRawInterface() ? _CONVERTIBLE_TO_TRUE : 0;}

      // Utilities
      inline ::IDXGIResource* getRawInterface() {return static_cast<::IDXGIResource*>(DXGI::DeviceSubObject::getRawInterface());}
      inline const ::IDXGIResource* getRawInterface() const {return static_cast<const ::IDXGIResource*>(DXGI::DeviceSubObject::getRawInterface());}
      inline void swap(Resource& other) {DXGI::DeviceSubObject::swap(other);}
      typedef ::IDXGIResource dumb_t;

      // Methods
      DXGI_USAGE getUsage();
      HANDLE getSharedHandle();
      void setEvictionPriority(unsigned int EvictionPriority);
      void getEvictionPriority(unsigned int* pEvictionPriority);
    };

    class Surface : public DXGI::DeviceSubObject
    {
    public:
      // Constructors
      Surface() {}
      Surface(nullptr_t) {}
      explicit Surface(::IDXGISurface* raw) : DXGI::DeviceSubObject(raw) {}
      Surface(const Surface& copy_from) : DXGI::DeviceSubObject(copy_from) {}
      Surface(Surface&& move_from) : DXGI::DeviceSubObject(std::move(move_from)) {}

      // Operators
      inline Surface& operator= (const Surface& copy_from) {DXGI::DeviceSubObject::operator=(copy_from); return *this;}
      inline Surface& operator= (Surface&& move_from) {DXGI::DeviceSubObject::operator=(std::move(move_from)); return *this;}
      _OPERATOR_BOOL() const {return getRawInterface() ? _CONVERTIBLE_TO_TRUE : 0;}

      // Utilities
      inline ::IDXGISurface* getRawInterface() {return static_cast<::IDXGISurface*>(DXGI::DeviceSubObject::getRawInterface());}
      inline const ::IDXGISurface* getRawInterface() const {return static_cast<const ::IDXGISurface*>(DXGI::DeviceSubObject::getRawInterface());}
      inline void swap(Surface& other) {DXGI::DeviceSubObject::swap(other);}
      typedef ::IDXGISurface dumb_t;

      // Methods
      DXGI_MAPPED_RECT map(unsigned int MapFlags);
      void unmap();
      DXGI_SURFACE_DESC getDesc();
    };

    class Surface1 : public DXGI::Surface
    {
    public:
      // Constructors
      Surface1() {}
      Surface1(nullptr_t) {}
      explicit Surface1(::IDXGISurface1* raw) : DXGI::Surface(raw) {}
      Surface1(const Surface1& copy_from) : DXGI::Surface(copy_from) {}
      Surface1(Surface1&& move_from) : DXGI::Surface(std::move(move_from)) {}

      // Operators
      inline Surface1& operator= (const Surface1& copy_from) {DXGI::Surface::operator=(copy_from); return *this;}
      inline Surface1& operator= (Surface1&& move_from) {DXGI::Surface::operator=(std::move(move_from)); return *this;}
      _OPERATOR_BOOL() const {return getRawInterface() ? _CONVERTIBLE_TO_TRUE : 0;}

      // Utilities
      inline ::IDXGISurface1* getRawInterface() {return static_cast<::IDXGISurface1*>(DXGI::Surface::getRawInterface());}
      inline const ::IDXGISurface1* getRawInterface() const {return static_cast<const ::IDXGISurface1*>(DXGI::Surface::getRawInterface());}
      inline void swap(Surface1& other) {DXGI::Surface::swap(other);}
      typedef ::IDXGISurface1 dumb_t;

      // Methods
      HDC getDC(BOOL Discard);
      void releaseDC(RECT* pDirtyRect);
    };

    class SwapChain : public DXGI::DeviceSubObject
    {
    public:
      // Constructors
      SwapChain() {}
      SwapChain(nullptr_t) {}
      explicit SwapChain(::IDXGISwapChain* raw) : DXGI::DeviceSubObject(raw) {}
      SwapChain(const SwapChain& copy_from) : DXGI::DeviceSubObject(copy_from) {}
      SwapChain(SwapChain&& move_from) : DXGI::DeviceSubObject(std::move(move_from)) {}

      // Operators
      inline SwapChain& operator= (const SwapChain& copy_from) {DXGI::DeviceSubObject::operator=(copy_from); return *this;}
      inline SwapChain& operator= (SwapChain&& move_from) {DXGI::DeviceSubObject::operator=(std::move(move_from)); return *this;}
      _OPERATOR_BOOL() const {return getRawInterface() ? _CONVERTIBLE_TO_TRUE : 0;}

      // Utilities
      inline ::IDXGISwapChain* getRawInterface() {return static_cast<::IDXGISwapChain*>(DXGI::DeviceSubObject::getRawInterface());}
      inline const ::IDXGISwapChain* getRawInterface() const {return static_cast<const ::IDXGISwapChain*>(DXGI::DeviceSubObject::getRawInterface());}
      inline void swap(SwapChain& other) {DXGI::DeviceSubObject::swap(other);}
      typedef ::IDXGISwapChain dumb_t;

      // Methods
      void resizeBuffers(unsigned int BufferCount, unsigned int Width, unsigned int Height, DXGI_FORMAT NewFormat, unsigned int SwapChainFlags);
      DXGI_FRAME_STATISTICS getFrameStatistics();
      std::tuple<bool, DXGI::Output> getFullscreenState();
      DXGI_SWAP_CHAIN_DESC getDesc();
      void getContainingOutput(IDXGIOutput** ppOutput);
      unsigned int getLastPresentCount();
      void setFullscreenState(BOOL Fullscreen, DXGI::Output& pTarget);
      void present(unsigned int SyncInterval, unsigned int Flags);

      template <typename SmartContainer>
      SmartContainer getBuffer(unsigned int Buffer)
      {
        void* ppSurface;
        HRESULT hr = getRawInterface()->GetBuffer(Buffer, __uuidof(typename SmartContainer::dumb_t), &ppSurface);
        if(FAILED(hr)) throw COMException(hr, "IDXGISwapChain::GetBuffer");
        return SmartContainer(static_cast<typename SmartContainer::dumb_t*>(ppSurface));
      }

      void resizeTarget(const DXGI_MODE_DESC& pNewTargetParameters);
    };

    class Device : public DXGI::Object
    {
    public:
      // Constructors
      Device() {}
      Device(nullptr_t) {}
      explicit Device(::IDXGIDevice* raw) : DXGI::Object(raw) {}
      Device(const Device& copy_from) : DXGI::Object(copy_from) {}
      Device(Device&& move_from) : DXGI::Object(std::move(move_from)) {}

      // Operators
      inline Device& operator= (const Device& copy_from) {DXGI::Object::operator=(copy_from); return *this;}
      inline Device& operator= (Device&& move_from) {DXGI::Object::operator=(std::move(move_from)); return *this;}
      _OPERATOR_BOOL() const {return getRawInterface() ? _CONVERTIBLE_TO_TRUE : 0;}

      // Utilities
      inline ::IDXGIDevice* getRawInterface() {return static_cast<::IDXGIDevice*>(DXGI::Object::getRawInterface());}
      inline const ::IDXGIDevice* getRawInterface() const {return static_cast<const ::IDXGIDevice*>(DXGI::Object::getRawInterface());}
      inline void swap(Device& other) {DXGI::Object::swap(other);}
      typedef ::IDXGIDevice dumb_t;

      // Methods
      DXGI::Adapter getAdapter();
      void queryResourceResidency(IUnknown* const& ppResources, DXGI_RESIDENCY* pResidencyStatus, unsigned int NumResources);
      void getGPUThreadPriority(int* pPriority);
      void setGPUThreadPriority(int Priority);
      DXGI::Surface createSurface(const DXGI_SURFACE_DESC& pDesc, unsigned int NumSurfaces, DXGI_USAGE Usage, const DXGI_SHARED_RESOURCE& pSharedResource);
    };

    class Device1 : public DXGI::Device
    {
    public:
      // Constructors
      Device1() {}
      Device1(nullptr_t) {}
      explicit Device1(::IDXGIDevice1* raw) : DXGI::Device(raw) {}
      Device1(const Device1& copy_from) : DXGI::Device(copy_from) {}
      Device1(Device1&& move_from) : DXGI::Device(std::move(move_from)) {}

      // Operators
      inline Device1& operator= (const Device1& copy_from) {DXGI::Device::operator=(copy_from); return *this;}
      inline Device1& operator= (Device1&& move_from) {DXGI::Device::operator=(std::move(move_from)); return *this;}
      _OPERATOR_BOOL() const {return getRawInterface() ? _CONVERTIBLE_TO_TRUE : 0;}

      // Utilities
      inline ::IDXGIDevice1* getRawInterface() {return static_cast<::IDXGIDevice1*>(DXGI::Device::getRawInterface());}
      inline const ::IDXGIDevice1* getRawInterface() const {return static_cast<const ::IDXGIDevice1*>(DXGI::Device::getRawInterface());}
      inline void swap(Device1& other) {DXGI::Device::swap(other);}
      typedef ::IDXGIDevice1 dumb_t;

      // Methods
      void setMaximumFrameLatency(unsigned int MaxLatency);
      unsigned int getMaximumFrameLatency();
    };

    class Factory : public DXGI::Object
    {
    public:
      // Constructors
      Factory() {}
      Factory(nullptr_t) {}
      explicit Factory(::IDXGIFactory* raw) : DXGI::Object(raw) {}
      Factory(const Factory& copy_from) : DXGI::Object(copy_from) {}
      Factory(Factory&& move_from) : DXGI::Object(std::move(move_from)) {}

      // Operators
      inline Factory& operator= (const Factory& copy_from) {DXGI::Object::operator=(copy_from); return *this;}
      inline Factory& operator= (Factory&& move_from) {DXGI::Object::operator=(std::move(move_from)); return *this;}
      _OPERATOR_BOOL() const {return getRawInterface() ? _CONVERTIBLE_TO_TRUE : 0;}

      // Utilities
      inline ::IDXGIFactory* getRawInterface() {return static_cast<::IDXGIFactory*>(DXGI::Object::getRawInterface());}
      inline const ::IDXGIFactory* getRawInterface() const {return static_cast<const ::IDXGIFactory*>(DXGI::Object::getRawInterface());}
      inline void swap(Factory& other) {DXGI::Object::swap(other);}
      typedef ::IDXGIFactory dumb_t;

      // Methods
      void makeWindowAssociation(HWND WindowHandle, unsigned int Flags);
      DXGI::Adapter enumAdapters(unsigned int Adapter);
      void getWindowAssociation(HWND* pWindowHandle);
      DXGI::Adapter createSoftwareAdapter(HMODULE Module);
      DXGI::SwapChain createSwapChain(COMObject& pDevice, DXGI_SWAP_CHAIN_DESC* pDesc);
    };

    class Factory1 : public DXGI::Factory
    {
    public:
      // Constructors
      Factory1() {}
      Factory1(nullptr_t) {}
      explicit Factory1(::IDXGIFactory1* raw) : DXGI::Factory(raw) {}
      Factory1(const Factory1& copy_from) : DXGI::Factory(copy_from) {}
      Factory1(Factory1&& move_from) : DXGI::Factory(std::move(move_from)) {}

      // Operators
      inline Factory1& operator= (const Factory1& copy_from) {DXGI::Factory::operator=(copy_from); return *this;}
      inline Factory1& operator= (Factory1&& move_from) {DXGI::Factory::operator=(std::move(move_from)); return *this;}
      _OPERATOR_BOOL() const {return getRawInterface() ? _CONVERTIBLE_TO_TRUE : 0;}

      // Utilities
      inline ::IDXGIFactory1* getRawInterface() {return static_cast<::IDXGIFactory1*>(DXGI::Factory::getRawInterface());}
      inline const ::IDXGIFactory1* getRawInterface() const {return static_cast<const ::IDXGIFactory1*>(DXGI::Factory::getRawInterface());}
      inline void swap(Factory1& other) {DXGI::Factory::swap(other);}
      typedef ::IDXGIFactory1 dumb_t;

      // Methods
      BOOL isCurrent();
      DXGI::Adapter1 enumAdapters1(unsigned int Adapter);
    };
  }
  namespace internal
  {
    template <>
    struct ecount<DXGI::Object&>
    {
      static size_t size(DXGI::Object& x) {return 1;}
      static IDXGIObject*const* data(DXGI::Object& x) {return reinterpret_cast<IDXGIObject*const*>(&x);}
    };
    template <>
    struct ecount<DXGI::Adapter&>
    {
      static size_t size(DXGI::Adapter& x) {return 1;}
      static IDXGIAdapter*const* data(DXGI::Adapter& x) {return reinterpret_cast<IDXGIAdapter*const*>(&x);}
    };
    template <>
    struct ecount<DXGI::Adapter1&>
    {
      static size_t size(DXGI::Adapter1& x) {return 1;}
      static IDXGIAdapter1*const* data(DXGI::Adapter1& x) {return reinterpret_cast<IDXGIAdapter1*const*>(&x);}
    };
    template <>
    struct ecount<DXGI::Output&>
    {
      static size_t size(DXGI::Output& x) {return 1;}
      static IDXGIOutput*const* data(DXGI::Output& x) {return reinterpret_cast<IDXGIOutput*const*>(&x);}
    };
    template <>
    struct ecount<DXGI::DeviceSubObject&>
    {
      static size_t size(DXGI::DeviceSubObject& x) {return 1;}
      static IDXGIDeviceSubObject*const* data(DXGI::DeviceSubObject& x) {return reinterpret_cast<IDXGIDeviceSubObject*const*>(&x);}
    };
    template <>
    struct ecount<DXGI::KeyedMutex&>
    {
      static size_t size(DXGI::KeyedMutex& x) {return 1;}
      static IDXGIKeyedMutex*const* data(DXGI::KeyedMutex& x) {return reinterpret_cast<IDXGIKeyedMutex*const*>(&x);}
    };
    template <>
    struct ecount<DXGI::Resource&>
    {
      static size_t size(DXGI::Resource& x) {return 1;}
      static IDXGIResource*const* data(DXGI::Resource& x) {return reinterpret_cast<IDXGIResource*const*>(&x);}
    };
    template <>
    struct ecount<DXGI::Surface&>
    {
      static size_t size(DXGI::Surface& x) {return 1;}
      static IDXGISurface*const* data(DXGI::Surface& x) {return reinterpret_cast<IDXGISurface*const*>(&x);}
    };
    template <>
    struct ecount<DXGI::Surface1&>
    {
      static size_t size(DXGI::Surface1& x) {return 1;}
      static IDXGISurface1*const* data(DXGI::Surface1& x) {return reinterpret_cast<IDXGISurface1*const*>(&x);}
    };
    template <>
    struct ecount<DXGI::SwapChain&>
    {
      static size_t size(DXGI::SwapChain& x) {return 1;}
      static IDXGISwapChain*const* data(DXGI::SwapChain& x) {return reinterpret_cast<IDXGISwapChain*const*>(&x);}
    };
    template <>
    struct ecount<DXGI::Device&>
    {
      static size_t size(DXGI::Device& x) {return 1;}
      static IDXGIDevice*const* data(DXGI::Device& x) {return reinterpret_cast<IDXGIDevice*const*>(&x);}
    };
    template <>
    struct ecount<DXGI::Device1&>
    {
      static size_t size(DXGI::Device1& x) {return 1;}
      static IDXGIDevice1*const* data(DXGI::Device1& x) {return reinterpret_cast<IDXGIDevice1*const*>(&x);}
    };
    template <>
    struct ecount<DXGI::Factory&>
    {
      static size_t size(DXGI::Factory& x) {return 1;}
      static IDXGIFactory*const* data(DXGI::Factory& x) {return reinterpret_cast<IDXGIFactory*const*>(&x);}
    };
    template <>
    struct ecount<DXGI::Factory1&>
    {
      static size_t size(DXGI::Factory1& x) {return 1;}
      static IDXGIFactory1*const* data(DXGI::Factory1& x) {return reinterpret_cast<IDXGIFactory1*const*>(&x);}
    };
  }
}
namespace std {
  inline void swap(C6::DXGI::KeyedMutex& a, C6::DXGI::KeyedMutex& b) {a.swap(b);}
  inline void swap(C6::DXGI::Adapter1& a, C6::DXGI::Adapter1& b) {a.swap(b);}
  inline void swap(C6::DXGI::Output& a, C6::DXGI::Output& b) {a.swap(b);}
  inline void swap(C6::DXGI::DeviceSubObject& a, C6::DXGI::DeviceSubObject& b) {a.swap(b);}
  inline void swap(C6::DXGI::Surface1& a, C6::DXGI::Surface1& b) {a.swap(b);}
  inline void swap(C6::DXGI::Factory1& a, C6::DXGI::Factory1& b) {a.swap(b);}
  inline void swap(C6::DXGI::Device& a, C6::DXGI::Device& b) {a.swap(b);}
  inline void swap(C6::DXGI::Adapter& a, C6::DXGI::Adapter& b) {a.swap(b);}
  inline void swap(C6::DXGI::Device1& a, C6::DXGI::Device1& b) {a.swap(b);}
  inline void swap(C6::DXGI::Surface& a, C6::DXGI::Surface& b) {a.swap(b);}
  inline void swap(C6::DXGI::Object& a, C6::DXGI::Object& b) {a.swap(b);}
  inline void swap(C6::DXGI::Factory& a, C6::DXGI::Factory& b) {a.swap(b);}
  inline void swap(C6::DXGI::Resource& a, C6::DXGI::Resource& b) {a.swap(b);}
  inline void swap(C6::DXGI::SwapChain& a, C6::DXGI::SwapChain& b) {a.swap(b);}
}
