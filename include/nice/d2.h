#pragma once
// Autogenerated by nicify.lua -- do not edit by hand.
#pragma warning(push)
#pragma warning(disable: 4005) // Macro redefinition
#include <intsafe.h>
#pragma warning(pop)
#include "dw.h"
#include "dxgi.h"
#include "wic.h"
#include <d2d1.h>
#include "com.h"
namespace C6
{
  namespace D2
  {
    class Brush;
    class DCRenderTarget;
    class SolidColorBrush;
    class HwndRenderTarget;
    class TessellationSink;
    class BitmapBrush;
    class EllipseGeometry;
    class GeometrySink;
    class Mesh;
    class Layer;
    class RectangleGeometry;
    class LinearGradientBrush;
    class Bitmap;
    class PathGeometry;
    class TransformedGeometry;
    class Factory;
    class Resource;
    class GradientStopCollection;
    class GeometryGroup;
    class Geometry;
    class RenderTarget;
    class SimplifiedGeometrySink;
    class BitmapRenderTarget;
    class RoundedRectangleGeometry;
    class DrawingStateBlock;
    class StrokeStyle;
    class GdiInteropRenderTarget;
    class RadialGradientBrush;

    class Factory : public COMObject
    {
    public:
      // Constructors
      Factory() {}
      Factory(nullptr_t) {}
      explicit Factory(::ID2D1Factory* raw) : COMObject(raw) {}
      Factory(const Factory& copy_from) : COMObject(copy_from) {}
      Factory(Factory&& move_from) : COMObject(std::move(move_from)) {}

      // Operators
      inline Factory& operator= (const Factory& copy_from) {COMObject::operator=(copy_from); return *this;}
      inline Factory& operator= (Factory&& move_from) {COMObject::operator=(std::move(move_from)); return *this;}
      _OPERATOR_BOOL() const {return getRawInterface() ? _CONVERTIBLE_TO_TRUE : 0;}

      // Utilities
      inline ::ID2D1Factory* getRawInterface() {return static_cast<::ID2D1Factory*>(COMObject::getRawInterface());}
      inline const ::ID2D1Factory* getRawInterface() const {return static_cast<const ::ID2D1Factory*>(COMObject::getRawInterface());}
      inline void swap(Factory& other) {COMObject::swap(other);}
      typedef ::ID2D1Factory dumb_t;

      // Methods
      D2::RoundedRectangleGeometry createRoundedRectangleGeometry(const D2D1_ROUNDED_RECT& roundedRectangle);
      D2::PathGeometry createPathGeometry();
      std::tuple<float, float> getDesktopDpi();
      D2::StrokeStyle createStrokeStyle(const D2D1_STROKE_STYLE_PROPERTIES& strokeStyleProperties);

      template <typename const_float_Container>
      typename C6::internal::konst<D2::StrokeStyle, const_float_Container>::T createStrokeStyle(const D2D1_STROKE_STYLE_PROPERTIES& strokeStyleProperties, const_float_Container&& dashes)
      {
        ID2D1StrokeStyle* strokeStyle = nullptr;
        HRESULT hr = getRawInterface()->CreateStrokeStyle(&strokeStyleProperties, C6::internal::ecount<const_float_Container>::data(dashes), static_cast<unsigned int>(C6::internal::ecount<const_float_Container>::size(dashes)), &strokeStyle);
        if(FAILED(hr)) throw COMException(hr, "ID2D1Factory::CreateStrokeStyle");
        return D2::StrokeStyle(strokeStyle);
      }


      template <typename ID2D1Geometry__Container>
      typename C6::internal::konst<D2::GeometryGroup, ID2D1Geometry__Container>::T createGeometryGroup(D2D1_FILL_MODE fillMode, ID2D1Geometry__Container&& geometries)
      {
        ID2D1GeometryGroup* geometryGroup = nullptr;
        HRESULT hr = getRawInterface()->CreateGeometryGroup(fillMode, (ID2D1Geometry**)C6::internal::ecount<ID2D1Geometry__Container>::data(geometries), static_cast<unsigned int>(C6::internal::ecount<ID2D1Geometry__Container>::size(geometries)), &geometryGroup);
        if(FAILED(hr)) throw COMException(hr, "ID2D1Factory::CreateGeometryGroup");
        return D2::GeometryGroup(geometryGroup);
      }

      D2::DrawingStateBlock createDrawingStateBlock();
      D2::DrawingStateBlock createDrawingStateBlock(const D2D1_DRAWING_STATE_DESCRIPTION& drawingStateDescription);
      D2::DrawingStateBlock createDrawingStateBlock(const D2D1_DRAWING_STATE_DESCRIPTION& drawingStateDescription, DW::RenderingParams& textRenderingParams);
      D2::RenderTarget createDxgiSurfaceRenderTarget(DXGI::Surface& dxgiSurface, const D2D1_RENDER_TARGET_PROPERTIES& renderTargetProperties);
      D2::EllipseGeometry createEllipseGeometry(const D2D1_ELLIPSE& ellipse);
      D2::RectangleGeometry createRectangleGeometry(const D2D1_RECT_F& rectangle);
      void reloadSystemMetrics();
      D2::DCRenderTarget createDCRenderTarget(const D2D1_RENDER_TARGET_PROPERTIES& renderTargetProperties);
      D2::HwndRenderTarget createHwndRenderTarget(const D2D1_RENDER_TARGET_PROPERTIES& renderTargetProperties, const D2D1_HWND_RENDER_TARGET_PROPERTIES& hwndRenderTargetProperties);
      D2::RenderTarget createWicBitmapRenderTarget(WIC::Bitmap& target, const D2D1_RENDER_TARGET_PROPERTIES& renderTargetProperties);
      D2::TransformedGeometry createTransformedGeometry(D2::Geometry& sourceGeometry, const D2D1_MATRIX_3X2_F& transform);
    };

    class TessellationSink : public COMObject
    {
    public:
      // Constructors
      TessellationSink() {}
      TessellationSink(nullptr_t) {}
      explicit TessellationSink(::ID2D1TessellationSink* raw) : COMObject(raw) {}
      TessellationSink(const TessellationSink& copy_from) : COMObject(copy_from) {}
      TessellationSink(TessellationSink&& move_from) : COMObject(std::move(move_from)) {}

      // Operators
      inline TessellationSink& operator= (const TessellationSink& copy_from) {COMObject::operator=(copy_from); return *this;}
      inline TessellationSink& operator= (TessellationSink&& move_from) {COMObject::operator=(std::move(move_from)); return *this;}
      _OPERATOR_BOOL() const {return getRawInterface() ? _CONVERTIBLE_TO_TRUE : 0;}

      // Utilities
      inline ::ID2D1TessellationSink* getRawInterface() {return static_cast<::ID2D1TessellationSink*>(COMObject::getRawInterface());}
      inline const ::ID2D1TessellationSink* getRawInterface() const {return static_cast<const ::ID2D1TessellationSink*>(COMObject::getRawInterface());}
      inline void swap(TessellationSink& other) {COMObject::swap(other);}
      typedef ::ID2D1TessellationSink dumb_t;

      // Methods
      void close();

      template <typename const_D2D1_TRIANGLE_Container>
      void addTriangles(const_D2D1_TRIANGLE_Container&& triangles)
      {
        getRawInterface()->AddTriangles(C6::internal::ecount<const_D2D1_TRIANGLE_Container>::data(triangles), static_cast<unsigned int>(C6::internal::ecount<const_D2D1_TRIANGLE_Container>::size(triangles)));
      }

    };

    class Resource : public COMObject
    {
    public:
      // Constructors
      Resource() {}
      Resource(nullptr_t) {}
      explicit Resource(::ID2D1Resource* raw) : COMObject(raw) {}
      Resource(const Resource& copy_from) : COMObject(copy_from) {}
      Resource(Resource&& move_from) : COMObject(std::move(move_from)) {}

      // Operators
      inline Resource& operator= (const Resource& copy_from) {COMObject::operator=(copy_from); return *this;}
      inline Resource& operator= (Resource&& move_from) {COMObject::operator=(std::move(move_from)); return *this;}
      _OPERATOR_BOOL() const {return getRawInterface() ? _CONVERTIBLE_TO_TRUE : 0;}

      // Utilities
      inline ::ID2D1Resource* getRawInterface() {return static_cast<::ID2D1Resource*>(COMObject::getRawInterface());}
      inline const ::ID2D1Resource* getRawInterface() const {return static_cast<const ::ID2D1Resource*>(COMObject::getRawInterface());}
      inline void swap(Resource& other) {COMObject::swap(other);}
      typedef ::ID2D1Resource dumb_t;

      // Methods
      D2::Factory getFactory() const;
    };

    class RenderTarget : public D2::Resource
    {
    public:
      // Constructors
      RenderTarget() {}
      RenderTarget(nullptr_t) {}
      explicit RenderTarget(::ID2D1RenderTarget* raw) : D2::Resource(raw) {}
      RenderTarget(const RenderTarget& copy_from) : D2::Resource(copy_from) {}
      RenderTarget(RenderTarget&& move_from) : D2::Resource(std::move(move_from)) {}

      // Operators
      inline RenderTarget& operator= (const RenderTarget& copy_from) {D2::Resource::operator=(copy_from); return *this;}
      inline RenderTarget& operator= (RenderTarget&& move_from) {D2::Resource::operator=(std::move(move_from)); return *this;}
      _OPERATOR_BOOL() const {return getRawInterface() ? _CONVERTIBLE_TO_TRUE : 0;}

      // Utilities
      inline ::ID2D1RenderTarget* getRawInterface() {return static_cast<::ID2D1RenderTarget*>(D2::Resource::getRawInterface());}
      inline const ::ID2D1RenderTarget* getRawInterface() const {return static_cast<const ::ID2D1RenderTarget*>(D2::Resource::getRawInterface());}
      inline void swap(RenderTarget& other) {D2::Resource::swap(other);}
      typedef ::ID2D1RenderTarget dumb_t;

      // Methods
      D2::LinearGradientBrush createLinearGradientBrush(const D2D1_LINEAR_GRADIENT_BRUSH_PROPERTIES& linearGradientBrushProperties, D2::GradientStopCollection& gradientStopCollection);
      D2::LinearGradientBrush createLinearGradientBrush(const D2D1_LINEAR_GRADIENT_BRUSH_PROPERTIES& linearGradientBrushProperties, const D2D1_BRUSH_PROPERTIES& brushProperties, D2::GradientStopCollection& gradientStopCollection);
      void setTransform(const D2D1_MATRIX_3X2_F& transform);
      void setTags(D2D1_TAG tag1, D2D1_TAG tag2);
      void drawTextLayout(D2D1_POINT_2F origin, DW::TextLayout& textLayout, D2::Brush& defaultForegroundBrush);
      void drawTextLayout(D2D1_POINT_2F origin, DW::TextLayout& textLayout, D2::Brush& defaultForegroundBrush, D2D1_DRAW_TEXT_OPTIONS options);
      uint32_t getMaximumBitmapSize() const;
      D2::Mesh createMesh();
      void fillRoundedRectangle(const D2D1_ROUNDED_RECT& roundedRect, D2::Brush& brush);
      void pushLayer(const D2D1_LAYER_PARAMETERS& layerParameters, D2::Layer& layer);
      DW::RenderingParams getTextRenderingParams() const;
      void drawGeometry(D2::Geometry& geometry, D2::Brush& brush);
      void drawGeometry(D2::Geometry& geometry, D2::Brush& brush, float strokeWidth);
      void drawGeometry(D2::Geometry& geometry, D2::Brush& brush, float strokeWidth, D2::StrokeStyle& strokeStyle);
      std::tuple<D2D1_TAG, D2D1_TAG> getTags() const;
      std::tuple<float, float> getDpi() const;
      void drawLine(D2D1_POINT_2F point0, D2D1_POINT_2F point1, D2::Brush& brush);
      void drawLine(D2D1_POINT_2F point0, D2D1_POINT_2F point1, D2::Brush& brush, float strokeWidth);
      void drawLine(D2D1_POINT_2F point0, D2D1_POINT_2F point1, D2::Brush& brush, float strokeWidth, D2::StrokeStyle& strokeStyle);

      template <typename const_D2D1_GRADIENT_STOP_Container>
      typename C6::internal::konst<D2::GradientStopCollection, const_D2D1_GRADIENT_STOP_Container>::T createGradientStopCollection(const_D2D1_GRADIENT_STOP_Container&& gradientStops, D2D1_GAMMA colorInterpolationGamma, D2D1_EXTEND_MODE extendMode)
      {
        ID2D1GradientStopCollection* gradientStopCollection = nullptr;
        HRESULT hr = getRawInterface()->CreateGradientStopCollection(C6::internal::ecount<const_D2D1_GRADIENT_STOP_Container>::data(gradientStops), static_cast<unsigned int>(C6::internal::ecount<const_D2D1_GRADIENT_STOP_Container>::size(gradientStops)), colorInterpolationGamma, extendMode, &gradientStopCollection);
        if(FAILED(hr)) throw COMException(hr, "ID2D1RenderTarget::CreateGradientStopCollection");
        return D2::GradientStopCollection(gradientStopCollection);
      }

      std::tuple<D2D1_TAG, D2D1_TAG> flush();

      template <typename SmartPointer>
      typename C6::internal::konst<D2::Bitmap, SmartPointer>::T createSharedBitmap(SmartPointer&& data)
      {
        ID2D1Bitmap* bitmap = nullptr;
        HRESULT hr = getRawInterface()->CreateSharedBitmap(__uuidof(typename std::remove_reference<SmartPointer>::type::dumb_t), data.getRawInterface(), nullptr, &bitmap);
        if(FAILED(hr)) throw COMException(hr, "ID2D1RenderTarget::CreateSharedBitmap");
        return D2::Bitmap(bitmap);
      }


      template <typename SmartPointer>
      typename C6::internal::konst<D2::Bitmap, SmartPointer>::T createSharedBitmap(SmartPointer&& data, const D2D1_BITMAP_PROPERTIES& bitmapProperties)
      {
        ID2D1Bitmap* bitmap = nullptr;
        HRESULT hr = getRawInterface()->CreateSharedBitmap(__uuidof(typename std::remove_reference<SmartPointer>::type::dumb_t), data.getRawInterface(), &bitmapProperties, &bitmap);
        if(FAILED(hr)) throw COMException(hr, "ID2D1RenderTarget::CreateSharedBitmap");
        return D2::Bitmap(bitmap);
      }

      D2::Layer createLayer();
      D2::Layer createLayer(const D2D1_SIZE_F& size);
      void fillEllipse(const D2D1_ELLIPSE& ellipse, D2::Brush& brush);
      void drawRectangle(const D2D1_RECT_F& rect, D2::Brush& brush);
      void drawRectangle(const D2D1_RECT_F& rect, D2::Brush& brush, float strokeWidth);
      void drawRectangle(const D2D1_RECT_F& rect, D2::Brush& brush, float strokeWidth, D2::StrokeStyle& strokeStyle);
      void clear();
      void clear(const D2D1_COLOR_F& clearColor);
      D2::RadialGradientBrush createRadialGradientBrush(const D2D1_RADIAL_GRADIENT_BRUSH_PROPERTIES& radialGradientBrushProperties, D2::GradientStopCollection& gradientStopCollection);
      D2::RadialGradientBrush createRadialGradientBrush(const D2D1_RADIAL_GRADIENT_BRUSH_PROPERTIES& radialGradientBrushProperties, const D2D1_BRUSH_PROPERTIES& brushProperties, D2::GradientStopCollection& gradientStopCollection);
      void fillRectangle(const D2D1_RECT_F& rect, D2::Brush& brush);
      D2D1_SIZE_F getSize() const;
      D2::Bitmap createBitmapFromWicBitmap(WIC::BitmapSource& wicBitmapSource);
      D2::Bitmap createBitmapFromWicBitmap(WIC::BitmapSource& wicBitmapSource, const D2D1_BITMAP_PROPERTIES& bitmapProperties);
      void drawGlyphRun(D2D1_POINT_2F baselineOrigin, const DWRITE_GLYPH_RUN& glyphRun, D2::Brush& foregroundBrush);
      void drawGlyphRun(D2D1_POINT_2F baselineOrigin, const DWRITE_GLYPH_RUN& glyphRun, D2::Brush& foregroundBrush, DWRITE_MEASURING_MODE measuringMode);
      void setDpi(float dpiX, float dpiY);
      D2D1_PIXEL_FORMAT getPixelFormat() const;
      std::tuple<D2D1_TAG, D2D1_TAG> endDraw();
      void setAntialiasMode(D2D1_ANTIALIAS_MODE antialiasMode);
      D2::SolidColorBrush createSolidColorBrush(const D2D1_COLOR_F& color);
      D2::SolidColorBrush createSolidColorBrush(const D2D1_COLOR_F& color, const D2D1_BRUSH_PROPERTIES& brushProperties);
      void beginDraw();
      void popAxisAlignedClip();
      void drawBitmap(D2::Bitmap& bitmap);
      void drawBitmap(D2::Bitmap& bitmap, const D2D1_RECT_F& destinationRectangle);
      void drawBitmap(D2::Bitmap& bitmap, const D2D1_RECT_F& destinationRectangle, float opacity);
      void drawBitmap(D2::Bitmap& bitmap, const D2D1_RECT_F& destinationRectangle, float opacity, D2D1_BITMAP_INTERPOLATION_MODE interpolationMode);
      void drawBitmap(D2::Bitmap& bitmap, const D2D1_RECT_F& destinationRectangle, float opacity, D2D1_BITMAP_INTERPOLATION_MODE interpolationMode, const D2D1_RECT_F& sourceRectangle);
      BOOL isSupported(const D2D1_RENDER_TARGET_PROPERTIES& renderTargetProperties) const;
      void pushAxisAlignedClip(const D2D1_RECT_F& clipRect, D2D1_ANTIALIAS_MODE antialiasMode);
      void fillMesh(D2::Mesh& mesh, D2::Brush& brush);
      void restoreDrawingState(D2::DrawingStateBlock& drawingStateBlock);
      void fillOpacityMask(D2::Bitmap& opacityMask, D2::Brush& brush, D2D1_OPACITY_MASK_CONTENT content);
      void fillOpacityMask(D2::Bitmap& opacityMask, D2::Brush& brush, D2D1_OPACITY_MASK_CONTENT content, const D2D1_RECT_F& destinationRectangle);
      void fillOpacityMask(D2::Bitmap& opacityMask, D2::Brush& brush, D2D1_OPACITY_MASK_CONTENT content, const D2D1_RECT_F& destinationRectangle, const D2D1_RECT_F& sourceRectangle);
      void popLayer();
      void setTextRenderingParams();
      void setTextRenderingParams(DW::RenderingParams& textRenderingParams);
      D2D1_ANTIALIAS_MODE getAntialiasMode() const;
      D2D1_TEXT_ANTIALIAS_MODE getTextAntialiasMode() const;
      void setTextAntialiasMode(D2D1_TEXT_ANTIALIAS_MODE textAntialiasMode);
      D2::BitmapRenderTarget createCompatibleRenderTarget(D2D1_COMPATIBLE_RENDER_TARGET_OPTIONS options);
      D2::BitmapRenderTarget createCompatibleRenderTarget(const D2D1_SIZE_F& desiredSize, D2D1_COMPATIBLE_RENDER_TARGET_OPTIONS options);
      D2::BitmapRenderTarget createCompatibleRenderTarget(const D2D1_SIZE_F& desiredSize, const D2D1_SIZE_U& desiredPixelSize, D2D1_COMPATIBLE_RENDER_TARGET_OPTIONS options);
      D2::BitmapRenderTarget createCompatibleRenderTarget(const D2D1_SIZE_F& desiredSize, const D2D1_SIZE_U& desiredPixelSize, const D2D1_PIXEL_FORMAT& desiredFormat, D2D1_COMPATIBLE_RENDER_TARGET_OPTIONS options);
      void saveDrawingState(D2::DrawingStateBlock& drawingStateBlock) const;
      void fillGeometry(D2::Geometry& geometry, D2::Brush& brush);
      void fillGeometry(D2::Geometry& geometry, D2::Brush& brush, D2::Brush& opacityBrush);
      D2::Bitmap createBitmap(D2D1_SIZE_U size, uint32_t pitch, const D2D1_BITMAP_PROPERTIES& bitmapProperties);
      D2::Bitmap createBitmap(D2D1_SIZE_U size, const void* srcData, uint32_t pitch, const D2D1_BITMAP_PROPERTIES& bitmapProperties);
      void drawRoundedRectangle(const D2D1_ROUNDED_RECT& roundedRect, D2::Brush& brush);
      void drawRoundedRectangle(const D2D1_ROUNDED_RECT& roundedRect, D2::Brush& brush, float strokeWidth);
      void drawRoundedRectangle(const D2D1_ROUNDED_RECT& roundedRect, D2::Brush& brush, float strokeWidth, D2::StrokeStyle& strokeStyle);
      D2D1_MATRIX_3X2_F getTransform() const;
      D2::BitmapBrush createBitmapBrush(D2::Bitmap& bitmap);
      D2::BitmapBrush createBitmapBrush(D2::Bitmap& bitmap, const D2D1_BITMAP_BRUSH_PROPERTIES& bitmapBrushProperties);
      D2::BitmapBrush createBitmapBrush(D2::Bitmap& bitmap, const D2D1_BITMAP_BRUSH_PROPERTIES& bitmapBrushProperties, const D2D1_BRUSH_PROPERTIES& brushProperties);
      void drawEllipse(const D2D1_ELLIPSE& ellipse, D2::Brush& brush);
      void drawEllipse(const D2D1_ELLIPSE& ellipse, D2::Brush& brush, float strokeWidth);
      void drawEllipse(const D2D1_ELLIPSE& ellipse, D2::Brush& brush, float strokeWidth, D2::StrokeStyle& strokeStyle);

      template <typename const_wchar_t_Container>
      void drawText(const_wchar_t_Container&& string, DW::TextFormat& textFormat, const D2D1_RECT_F& layoutRect, D2::Brush& defaultForegroundBrush)
      {
        getRawInterface()->DrawText(C6::internal::ecount<const_wchar_t_Container>::data(string), static_cast<unsigned int>(C6::internal::ecount<const_wchar_t_Container>::size(string)), textFormat.getRawInterface(), &layoutRect, defaultForegroundBrush.getRawInterface(), D2D1_DRAW_TEXT_OPTIONS_NONE, DWRITE_MEASURING_MODE_NATURAL);
      }


      template <typename const_wchar_t_Container>
      void drawText(const_wchar_t_Container&& string, DW::TextFormat& textFormat, const D2D1_RECT_F& layoutRect, D2::Brush& defaultForegroundBrush, D2D1_DRAW_TEXT_OPTIONS options)
      {
        getRawInterface()->DrawText(C6::internal::ecount<const_wchar_t_Container>::data(string), static_cast<unsigned int>(C6::internal::ecount<const_wchar_t_Container>::size(string)), textFormat.getRawInterface(), &layoutRect, defaultForegroundBrush.getRawInterface(), options, DWRITE_MEASURING_MODE_NATURAL);
      }


      template <typename const_wchar_t_Container>
      void drawText(const_wchar_t_Container&& string, DW::TextFormat& textFormat, const D2D1_RECT_F& layoutRect, D2::Brush& defaultForegroundBrush, D2D1_DRAW_TEXT_OPTIONS options, DWRITE_MEASURING_MODE measuringMode)
      {
        getRawInterface()->DrawText(C6::internal::ecount<const_wchar_t_Container>::data(string), static_cast<unsigned int>(C6::internal::ecount<const_wchar_t_Container>::size(string)), textFormat.getRawInterface(), &layoutRect, defaultForegroundBrush.getRawInterface(), options, measuringMode);
      }

      D2D1_SIZE_U getPixelSize() const;
    };

    class DCRenderTarget : public D2::RenderTarget
    {
    public:
      // Constructors
      DCRenderTarget() {}
      DCRenderTarget(nullptr_t) {}
      explicit DCRenderTarget(::ID2D1DCRenderTarget* raw) : D2::RenderTarget(raw) {}
      DCRenderTarget(const DCRenderTarget& copy_from) : D2::RenderTarget(copy_from) {}
      DCRenderTarget(DCRenderTarget&& move_from) : D2::RenderTarget(std::move(move_from)) {}

      // Operators
      inline DCRenderTarget& operator= (const DCRenderTarget& copy_from) {D2::RenderTarget::operator=(copy_from); return *this;}
      inline DCRenderTarget& operator= (DCRenderTarget&& move_from) {D2::RenderTarget::operator=(std::move(move_from)); return *this;}
      _OPERATOR_BOOL() const {return getRawInterface() ? _CONVERTIBLE_TO_TRUE : 0;}

      // Utilities
      inline ::ID2D1DCRenderTarget* getRawInterface() {return static_cast<::ID2D1DCRenderTarget*>(D2::RenderTarget::getRawInterface());}
      inline const ::ID2D1DCRenderTarget* getRawInterface() const {return static_cast<const ::ID2D1DCRenderTarget*>(D2::RenderTarget::getRawInterface());}
      inline void swap(DCRenderTarget& other) {D2::RenderTarget::swap(other);}
      typedef ::ID2D1DCRenderTarget dumb_t;

      // Methods
      void bindDC(const HDC hDC, const RECT& pSubRect);
    };

    class HwndRenderTarget : public D2::RenderTarget
    {
    public:
      // Constructors
      HwndRenderTarget() {}
      HwndRenderTarget(nullptr_t) {}
      explicit HwndRenderTarget(::ID2D1HwndRenderTarget* raw) : D2::RenderTarget(raw) {}
      HwndRenderTarget(const HwndRenderTarget& copy_from) : D2::RenderTarget(copy_from) {}
      HwndRenderTarget(HwndRenderTarget&& move_from) : D2::RenderTarget(std::move(move_from)) {}

      // Operators
      inline HwndRenderTarget& operator= (const HwndRenderTarget& copy_from) {D2::RenderTarget::operator=(copy_from); return *this;}
      inline HwndRenderTarget& operator= (HwndRenderTarget&& move_from) {D2::RenderTarget::operator=(std::move(move_from)); return *this;}
      _OPERATOR_BOOL() const {return getRawInterface() ? _CONVERTIBLE_TO_TRUE : 0;}

      // Utilities
      inline ::ID2D1HwndRenderTarget* getRawInterface() {return static_cast<::ID2D1HwndRenderTarget*>(D2::RenderTarget::getRawInterface());}
      inline const ::ID2D1HwndRenderTarget* getRawInterface() const {return static_cast<const ::ID2D1HwndRenderTarget*>(D2::RenderTarget::getRawInterface());}
      inline void swap(HwndRenderTarget& other) {D2::RenderTarget::swap(other);}
      typedef ::ID2D1HwndRenderTarget dumb_t;

      // Methods
      HWND getHwnd() const;
      void resize(const D2D1_SIZE_U& pixelSize);
      D2D1_WINDOW_STATE checkWindowState();
    };

    class BitmapRenderTarget : public D2::RenderTarget
    {
    public:
      // Constructors
      BitmapRenderTarget() {}
      BitmapRenderTarget(nullptr_t) {}
      explicit BitmapRenderTarget(::ID2D1BitmapRenderTarget* raw) : D2::RenderTarget(raw) {}
      BitmapRenderTarget(const BitmapRenderTarget& copy_from) : D2::RenderTarget(copy_from) {}
      BitmapRenderTarget(BitmapRenderTarget&& move_from) : D2::RenderTarget(std::move(move_from)) {}

      // Operators
      inline BitmapRenderTarget& operator= (const BitmapRenderTarget& copy_from) {D2::RenderTarget::operator=(copy_from); return *this;}
      inline BitmapRenderTarget& operator= (BitmapRenderTarget&& move_from) {D2::RenderTarget::operator=(std::move(move_from)); return *this;}
      _OPERATOR_BOOL() const {return getRawInterface() ? _CONVERTIBLE_TO_TRUE : 0;}

      // Utilities
      inline ::ID2D1BitmapRenderTarget* getRawInterface() {return static_cast<::ID2D1BitmapRenderTarget*>(D2::RenderTarget::getRawInterface());}
      inline const ::ID2D1BitmapRenderTarget* getRawInterface() const {return static_cast<const ::ID2D1BitmapRenderTarget*>(D2::RenderTarget::getRawInterface());}
      inline void swap(BitmapRenderTarget& other) {D2::RenderTarget::swap(other);}
      typedef ::ID2D1BitmapRenderTarget dumb_t;

      // Methods
      D2::Bitmap getBitmap();
    };

    class GradientStopCollection : public D2::Resource
    {
    public:
      // Constructors
      GradientStopCollection() {}
      GradientStopCollection(nullptr_t) {}
      explicit GradientStopCollection(::ID2D1GradientStopCollection* raw) : D2::Resource(raw) {}
      GradientStopCollection(const GradientStopCollection& copy_from) : D2::Resource(copy_from) {}
      GradientStopCollection(GradientStopCollection&& move_from) : D2::Resource(std::move(move_from)) {}

      // Operators
      inline GradientStopCollection& operator= (const GradientStopCollection& copy_from) {D2::Resource::operator=(copy_from); return *this;}
      inline GradientStopCollection& operator= (GradientStopCollection&& move_from) {D2::Resource::operator=(std::move(move_from)); return *this;}
      _OPERATOR_BOOL() const {return getRawInterface() ? _CONVERTIBLE_TO_TRUE : 0;}

      // Utilities
      inline ::ID2D1GradientStopCollection* getRawInterface() {return static_cast<::ID2D1GradientStopCollection*>(D2::Resource::getRawInterface());}
      inline const ::ID2D1GradientStopCollection* getRawInterface() const {return static_cast<const ::ID2D1GradientStopCollection*>(D2::Resource::getRawInterface());}
      inline void swap(GradientStopCollection& other) {D2::Resource::swap(other);}
      typedef ::ID2D1GradientStopCollection dumb_t;

      // Methods
      D2D1_GAMMA getColorInterpolationGamma() const;
      D2D1_EXTEND_MODE getExtendMode() const;
      uint32_t getGradientStopCount() const;
      std::vector<D2D1_GRADIENT_STOP> getGradientStops(unsigned int gradientStopsCount) const;
    };

    class StrokeStyle : public D2::Resource
    {
    public:
      // Constructors
      StrokeStyle() {}
      StrokeStyle(nullptr_t) {}
      explicit StrokeStyle(::ID2D1StrokeStyle* raw) : D2::Resource(raw) {}
      StrokeStyle(const StrokeStyle& copy_from) : D2::Resource(copy_from) {}
      StrokeStyle(StrokeStyle&& move_from) : D2::Resource(std::move(move_from)) {}

      // Operators
      inline StrokeStyle& operator= (const StrokeStyle& copy_from) {D2::Resource::operator=(copy_from); return *this;}
      inline StrokeStyle& operator= (StrokeStyle&& move_from) {D2::Resource::operator=(std::move(move_from)); return *this;}
      _OPERATOR_BOOL() const {return getRawInterface() ? _CONVERTIBLE_TO_TRUE : 0;}

      // Utilities
      inline ::ID2D1StrokeStyle* getRawInterface() {return static_cast<::ID2D1StrokeStyle*>(D2::Resource::getRawInterface());}
      inline const ::ID2D1StrokeStyle* getRawInterface() const {return static_cast<const ::ID2D1StrokeStyle*>(D2::Resource::getRawInterface());}
      inline void swap(StrokeStyle& other) {D2::Resource::swap(other);}
      typedef ::ID2D1StrokeStyle dumb_t;

      // Methods
      D2D1_LINE_JOIN getLineJoin() const;
      float getDashOffset() const;
      D2D1_CAP_STYLE getDashCap() const;
      uint32_t getDashesCount() const;
      float getMiterLimit() const;
      D2D1_DASH_STYLE getDashStyle() const;
      std::vector<float> getDashes(unsigned int dashesCount) const;
      D2D1_CAP_STYLE getEndCap() const;
      D2D1_CAP_STYLE getStartCap() const;
    };

    class Brush : public D2::Resource
    {
    public:
      // Constructors
      Brush() {}
      Brush(nullptr_t) {}
      explicit Brush(::ID2D1Brush* raw) : D2::Resource(raw) {}
      Brush(const Brush& copy_from) : D2::Resource(copy_from) {}
      Brush(Brush&& move_from) : D2::Resource(std::move(move_from)) {}

      // Operators
      inline Brush& operator= (const Brush& copy_from) {D2::Resource::operator=(copy_from); return *this;}
      inline Brush& operator= (Brush&& move_from) {D2::Resource::operator=(std::move(move_from)); return *this;}
      _OPERATOR_BOOL() const {return getRawInterface() ? _CONVERTIBLE_TO_TRUE : 0;}

      // Utilities
      inline ::ID2D1Brush* getRawInterface() {return static_cast<::ID2D1Brush*>(D2::Resource::getRawInterface());}
      inline const ::ID2D1Brush* getRawInterface() const {return static_cast<const ::ID2D1Brush*>(D2::Resource::getRawInterface());}
      inline void swap(Brush& other) {D2::Resource::swap(other);}
      typedef ::ID2D1Brush dumb_t;

      // Methods
      D2D1_MATRIX_3X2_F getTransform() const;
      float getOpacity() const;
      void setTransform(const D2D1_MATRIX_3X2_F& transform);
      void setOpacity(float opacity);
    };

    class RadialGradientBrush : public D2::Brush
    {
    public:
      // Constructors
      RadialGradientBrush() {}
      RadialGradientBrush(nullptr_t) {}
      explicit RadialGradientBrush(::ID2D1RadialGradientBrush* raw) : D2::Brush(raw) {}
      RadialGradientBrush(const RadialGradientBrush& copy_from) : D2::Brush(copy_from) {}
      RadialGradientBrush(RadialGradientBrush&& move_from) : D2::Brush(std::move(move_from)) {}

      // Operators
      inline RadialGradientBrush& operator= (const RadialGradientBrush& copy_from) {D2::Brush::operator=(copy_from); return *this;}
      inline RadialGradientBrush& operator= (RadialGradientBrush&& move_from) {D2::Brush::operator=(std::move(move_from)); return *this;}
      _OPERATOR_BOOL() const {return getRawInterface() ? _CONVERTIBLE_TO_TRUE : 0;}

      // Utilities
      inline ::ID2D1RadialGradientBrush* getRawInterface() {return static_cast<::ID2D1RadialGradientBrush*>(D2::Brush::getRawInterface());}
      inline const ::ID2D1RadialGradientBrush* getRawInterface() const {return static_cast<const ::ID2D1RadialGradientBrush*>(D2::Brush::getRawInterface());}
      inline void swap(RadialGradientBrush& other) {D2::Brush::swap(other);}
      typedef ::ID2D1RadialGradientBrush dumb_t;

      // Methods
      void setRadiusX(float radiusX);
      D2D1_POINT_2F getGradientOriginOffset() const;
      float getRadiusY() const;
      D2::GradientStopCollection getGradientStopCollection() const;
      void setRadiusY(float radiusY);
      void setCenter(D2D1_POINT_2F center);
      float getRadiusX() const;
      D2D1_POINT_2F getCenter() const;
      void setGradientOriginOffset(D2D1_POINT_2F gradientOriginOffset);
    };

    class SolidColorBrush : public D2::Brush
    {
    public:
      // Constructors
      SolidColorBrush() {}
      SolidColorBrush(nullptr_t) {}
      explicit SolidColorBrush(::ID2D1SolidColorBrush* raw) : D2::Brush(raw) {}
      SolidColorBrush(const SolidColorBrush& copy_from) : D2::Brush(copy_from) {}
      SolidColorBrush(SolidColorBrush&& move_from) : D2::Brush(std::move(move_from)) {}

      // Operators
      inline SolidColorBrush& operator= (const SolidColorBrush& copy_from) {D2::Brush::operator=(copy_from); return *this;}
      inline SolidColorBrush& operator= (SolidColorBrush&& move_from) {D2::Brush::operator=(std::move(move_from)); return *this;}
      _OPERATOR_BOOL() const {return getRawInterface() ? _CONVERTIBLE_TO_TRUE : 0;}

      // Utilities
      inline ::ID2D1SolidColorBrush* getRawInterface() {return static_cast<::ID2D1SolidColorBrush*>(D2::Brush::getRawInterface());}
      inline const ::ID2D1SolidColorBrush* getRawInterface() const {return static_cast<const ::ID2D1SolidColorBrush*>(D2::Brush::getRawInterface());}
      inline void swap(SolidColorBrush& other) {D2::Brush::swap(other);}
      typedef ::ID2D1SolidColorBrush dumb_t;

      // Methods
      D2D1_COLOR_F getColor() const;
      void setColor(const D2D1_COLOR_F& color);
    };

    class BitmapBrush : public D2::Brush
    {
    public:
      // Constructors
      BitmapBrush() {}
      BitmapBrush(nullptr_t) {}
      explicit BitmapBrush(::ID2D1BitmapBrush* raw) : D2::Brush(raw) {}
      BitmapBrush(const BitmapBrush& copy_from) : D2::Brush(copy_from) {}
      BitmapBrush(BitmapBrush&& move_from) : D2::Brush(std::move(move_from)) {}

      // Operators
      inline BitmapBrush& operator= (const BitmapBrush& copy_from) {D2::Brush::operator=(copy_from); return *this;}
      inline BitmapBrush& operator= (BitmapBrush&& move_from) {D2::Brush::operator=(std::move(move_from)); return *this;}
      _OPERATOR_BOOL() const {return getRawInterface() ? _CONVERTIBLE_TO_TRUE : 0;}

      // Utilities
      inline ::ID2D1BitmapBrush* getRawInterface() {return static_cast<::ID2D1BitmapBrush*>(D2::Brush::getRawInterface());}
      inline const ::ID2D1BitmapBrush* getRawInterface() const {return static_cast<const ::ID2D1BitmapBrush*>(D2::Brush::getRawInterface());}
      inline void swap(BitmapBrush& other) {D2::Brush::swap(other);}
      typedef ::ID2D1BitmapBrush dumb_t;

      // Methods
      D2D1_EXTEND_MODE getExtendModeY() const;
      D2D1_BITMAP_INTERPOLATION_MODE getInterpolationMode() const;
      D2::Bitmap getBitmap() const;
      D2D1_EXTEND_MODE getExtendModeX() const;
      void setBitmap(D2::Bitmap& bitmap);
      void setInterpolationMode(D2D1_BITMAP_INTERPOLATION_MODE interpolationMode);
      void setExtendModeY(D2D1_EXTEND_MODE extendModeY);
      void setExtendModeX(D2D1_EXTEND_MODE extendModeX);
    };

    class LinearGradientBrush : public D2::Brush
    {
    public:
      // Constructors
      LinearGradientBrush() {}
      LinearGradientBrush(nullptr_t) {}
      explicit LinearGradientBrush(::ID2D1LinearGradientBrush* raw) : D2::Brush(raw) {}
      LinearGradientBrush(const LinearGradientBrush& copy_from) : D2::Brush(copy_from) {}
      LinearGradientBrush(LinearGradientBrush&& move_from) : D2::Brush(std::move(move_from)) {}

      // Operators
      inline LinearGradientBrush& operator= (const LinearGradientBrush& copy_from) {D2::Brush::operator=(copy_from); return *this;}
      inline LinearGradientBrush& operator= (LinearGradientBrush&& move_from) {D2::Brush::operator=(std::move(move_from)); return *this;}
      _OPERATOR_BOOL() const {return getRawInterface() ? _CONVERTIBLE_TO_TRUE : 0;}

      // Utilities
      inline ::ID2D1LinearGradientBrush* getRawInterface() {return static_cast<::ID2D1LinearGradientBrush*>(D2::Brush::getRawInterface());}
      inline const ::ID2D1LinearGradientBrush* getRawInterface() const {return static_cast<const ::ID2D1LinearGradientBrush*>(D2::Brush::getRawInterface());}
      inline void swap(LinearGradientBrush& other) {D2::Brush::swap(other);}
      typedef ::ID2D1LinearGradientBrush dumb_t;

      // Methods
      D2D1_POINT_2F getStartPoint() const;
      D2D1_POINT_2F getEndPoint() const;
      void setStartPoint(D2D1_POINT_2F startPoint);
      D2::GradientStopCollection getGradientStopCollection() const;
      void setEndPoint(D2D1_POINT_2F endPoint);
    };

    class DrawingStateBlock : public D2::Resource
    {
    public:
      // Constructors
      DrawingStateBlock() {}
      DrawingStateBlock(nullptr_t) {}
      explicit DrawingStateBlock(::ID2D1DrawingStateBlock* raw) : D2::Resource(raw) {}
      DrawingStateBlock(const DrawingStateBlock& copy_from) : D2::Resource(copy_from) {}
      DrawingStateBlock(DrawingStateBlock&& move_from) : D2::Resource(std::move(move_from)) {}

      // Operators
      inline DrawingStateBlock& operator= (const DrawingStateBlock& copy_from) {D2::Resource::operator=(copy_from); return *this;}
      inline DrawingStateBlock& operator= (DrawingStateBlock&& move_from) {D2::Resource::operator=(std::move(move_from)); return *this;}
      _OPERATOR_BOOL() const {return getRawInterface() ? _CONVERTIBLE_TO_TRUE : 0;}

      // Utilities
      inline ::ID2D1DrawingStateBlock* getRawInterface() {return static_cast<::ID2D1DrawingStateBlock*>(D2::Resource::getRawInterface());}
      inline const ::ID2D1DrawingStateBlock* getRawInterface() const {return static_cast<const ::ID2D1DrawingStateBlock*>(D2::Resource::getRawInterface());}
      inline void swap(DrawingStateBlock& other) {D2::Resource::swap(other);}
      typedef ::ID2D1DrawingStateBlock dumb_t;

      // Methods
      DW::RenderingParams getTextRenderingParams() const;
      void setDescription(const D2D1_DRAWING_STATE_DESCRIPTION& stateDescription);
      void setTextRenderingParams();
      void setTextRenderingParams(DW::RenderingParams& textRenderingParams);
      D2D1_DRAWING_STATE_DESCRIPTION getDescription() const;
    };

    class Mesh : public D2::Resource
    {
    public:
      // Constructors
      Mesh() {}
      Mesh(nullptr_t) {}
      explicit Mesh(::ID2D1Mesh* raw) : D2::Resource(raw) {}
      Mesh(const Mesh& copy_from) : D2::Resource(copy_from) {}
      Mesh(Mesh&& move_from) : D2::Resource(std::move(move_from)) {}

      // Operators
      inline Mesh& operator= (const Mesh& copy_from) {D2::Resource::operator=(copy_from); return *this;}
      inline Mesh& operator= (Mesh&& move_from) {D2::Resource::operator=(std::move(move_from)); return *this;}
      _OPERATOR_BOOL() const {return getRawInterface() ? _CONVERTIBLE_TO_TRUE : 0;}

      // Utilities
      inline ::ID2D1Mesh* getRawInterface() {return static_cast<::ID2D1Mesh*>(D2::Resource::getRawInterface());}
      inline const ::ID2D1Mesh* getRawInterface() const {return static_cast<const ::ID2D1Mesh*>(D2::Resource::getRawInterface());}
      inline void swap(Mesh& other) {D2::Resource::swap(other);}
      typedef ::ID2D1Mesh dumb_t;

      // Methods
      D2::TessellationSink open();
    };

    class Layer : public D2::Resource
    {
    public:
      // Constructors
      Layer() {}
      Layer(nullptr_t) {}
      explicit Layer(::ID2D1Layer* raw) : D2::Resource(raw) {}
      Layer(const Layer& copy_from) : D2::Resource(copy_from) {}
      Layer(Layer&& move_from) : D2::Resource(std::move(move_from)) {}

      // Operators
      inline Layer& operator= (const Layer& copy_from) {D2::Resource::operator=(copy_from); return *this;}
      inline Layer& operator= (Layer&& move_from) {D2::Resource::operator=(std::move(move_from)); return *this;}
      _OPERATOR_BOOL() const {return getRawInterface() ? _CONVERTIBLE_TO_TRUE : 0;}

      // Utilities
      inline ::ID2D1Layer* getRawInterface() {return static_cast<::ID2D1Layer*>(D2::Resource::getRawInterface());}
      inline const ::ID2D1Layer* getRawInterface() const {return static_cast<const ::ID2D1Layer*>(D2::Resource::getRawInterface());}
      inline void swap(Layer& other) {D2::Resource::swap(other);}
      typedef ::ID2D1Layer dumb_t;

      // Methods
      D2D1_SIZE_F getSize() const;
    };

    class Bitmap : public D2::Resource
    {
    public:
      // Constructors
      Bitmap() {}
      Bitmap(nullptr_t) {}
      explicit Bitmap(::ID2D1Bitmap* raw) : D2::Resource(raw) {}
      Bitmap(const Bitmap& copy_from) : D2::Resource(copy_from) {}
      Bitmap(Bitmap&& move_from) : D2::Resource(std::move(move_from)) {}

      // Operators
      inline Bitmap& operator= (const Bitmap& copy_from) {D2::Resource::operator=(copy_from); return *this;}
      inline Bitmap& operator= (Bitmap&& move_from) {D2::Resource::operator=(std::move(move_from)); return *this;}
      _OPERATOR_BOOL() const {return getRawInterface() ? _CONVERTIBLE_TO_TRUE : 0;}

      // Utilities
      inline ::ID2D1Bitmap* getRawInterface() {return static_cast<::ID2D1Bitmap*>(D2::Resource::getRawInterface());}
      inline const ::ID2D1Bitmap* getRawInterface() const {return static_cast<const ::ID2D1Bitmap*>(D2::Resource::getRawInterface());}
      inline void swap(Bitmap& other) {D2::Resource::swap(other);}
      typedef ::ID2D1Bitmap dumb_t;

      // Methods
      D2D1_SIZE_F getSize() const;
      std::tuple<float, float> getDpi() const;
      void copyFromBitmap(D2::Bitmap& bitmap);
      void copyFromBitmap(const D2D1_POINT_2U& destPoint, D2::Bitmap& bitmap);
      void copyFromBitmap(const D2D1_POINT_2U& destPoint, D2::Bitmap& bitmap, const D2D1_RECT_U& srcRect);
      void copyFromMemory(const void* srcData, uint32_t pitch);
      void copyFromMemory(const D2D1_RECT_U& dstRect, const void* srcData, uint32_t pitch);
      D2D1_PIXEL_FORMAT getPixelFormat() const;
      void copyFromRenderTarget(D2::RenderTarget& renderTarget);
      void copyFromRenderTarget(const D2D1_POINT_2U& destPoint, D2::RenderTarget& renderTarget);
      void copyFromRenderTarget(const D2D1_POINT_2U& destPoint, D2::RenderTarget& renderTarget, const D2D1_RECT_U& srcRect);
      D2D1_SIZE_U getPixelSize() const;
    };

    class Geometry : public D2::Resource
    {
    public:
      // Constructors
      Geometry() {}
      Geometry(nullptr_t) {}
      explicit Geometry(::ID2D1Geometry* raw) : D2::Resource(raw) {}
      Geometry(const Geometry& copy_from) : D2::Resource(copy_from) {}
      Geometry(Geometry&& move_from) : D2::Resource(std::move(move_from)) {}

      // Operators
      inline Geometry& operator= (const Geometry& copy_from) {D2::Resource::operator=(copy_from); return *this;}
      inline Geometry& operator= (Geometry&& move_from) {D2::Resource::operator=(std::move(move_from)); return *this;}
      _OPERATOR_BOOL() const {return getRawInterface() ? _CONVERTIBLE_TO_TRUE : 0;}

      // Utilities
      inline ::ID2D1Geometry* getRawInterface() {return static_cast<::ID2D1Geometry*>(D2::Resource::getRawInterface());}
      inline const ::ID2D1Geometry* getRawInterface() const {return static_cast<const ::ID2D1Geometry*>(D2::Resource::getRawInterface());}
      inline void swap(Geometry& other) {D2::Resource::swap(other);}
      typedef ::ID2D1Geometry dumb_t;

      // Methods
      D2D1_RECT_F getBounds() const;
      D2D1_RECT_F getBounds(const D2D1_MATRIX_3X2_F& worldTransform) const;
      void simplify(D2D1_GEOMETRY_SIMPLIFICATION_OPTION simplificationOption, float flatteningTolerance, D2::SimplifiedGeometrySink& geometrySink) const;
      void simplify(D2D1_GEOMETRY_SIMPLIFICATION_OPTION simplificationOption, const D2D1_MATRIX_3X2_F& worldTransform, float flatteningTolerance, D2::SimplifiedGeometrySink& geometrySink) const;
      D2D1_GEOMETRY_RELATION compareWithGeometry(D2::Geometry& inputGeometry, float flatteningTolerance) const;
      D2D1_GEOMETRY_RELATION compareWithGeometry(D2::Geometry& inputGeometry, const D2D1_MATRIX_3X2_F& inputGeometryTransform, float flatteningTolerance) const;
      void widen(float strokeWidth, float flatteningTolerance, D2::SimplifiedGeometrySink& geometrySink) const;
      void widen(float strokeWidth, D2::StrokeStyle& strokeStyle, float flatteningTolerance, D2::SimplifiedGeometrySink& geometrySink) const;
      void widen(float strokeWidth, D2::StrokeStyle& strokeStyle, const D2D1_MATRIX_3X2_F& worldTransform, float flatteningTolerance, D2::SimplifiedGeometrySink& geometrySink) const;
      void outline(float flatteningTolerance, D2::SimplifiedGeometrySink& geometrySink) const;
      void outline(const D2D1_MATRIX_3X2_F& worldTransform, float flatteningTolerance, D2::SimplifiedGeometrySink& geometrySink) const;
      bool fillContainsPoint(D2D1_POINT_2F point, float flatteningTolerance) const;
      bool fillContainsPoint(D2D1_POINT_2F point, const D2D1_MATRIX_3X2_F& worldTransform, float flatteningTolerance) const;
      void tessellate(float flatteningTolerance, D2::TessellationSink& tessellationSink) const;
      void tessellate(const D2D1_MATRIX_3X2_F& worldTransform, float flatteningTolerance, D2::TessellationSink& tessellationSink) const;
      bool strokeContainsPoint(D2D1_POINT_2F point, float strokeWidth, float flatteningTolerance) const;
      bool strokeContainsPoint(D2D1_POINT_2F point, float strokeWidth, D2::StrokeStyle& strokeStyle, float flatteningTolerance) const;
      bool strokeContainsPoint(D2D1_POINT_2F point, float strokeWidth, D2::StrokeStyle& strokeStyle, const D2D1_MATRIX_3X2_F& worldTransform, float flatteningTolerance) const;
      float computeLength(float flatteningTolerance) const;
      float computeLength(const D2D1_MATRIX_3X2_F& worldTransform, float flatteningTolerance) const;
      float computeArea(float flatteningTolerance) const;
      float computeArea(const D2D1_MATRIX_3X2_F& worldTransform, float flatteningTolerance) const;
      std::tuple<D2D1_POINT_2F, D2D1_POINT_2F> computePointAtLength(float length, float flatteningTolerance) const;
      std::tuple<D2D1_POINT_2F, D2D1_POINT_2F> computePointAtLength(float length, const D2D1_MATRIX_3X2_F& worldTransform, float flatteningTolerance) const;
      D2D1_RECT_F getWidenedBounds(float strokeWidth, float flatteningTolerance) const;
      D2D1_RECT_F getWidenedBounds(float strokeWidth, D2::StrokeStyle& strokeStyle, float flatteningTolerance) const;
      D2D1_RECT_F getWidenedBounds(float strokeWidth, D2::StrokeStyle& strokeStyle, const D2D1_MATRIX_3X2_F& worldTransform, float flatteningTolerance) const;
      void combineWithGeometry(D2::Geometry& inputGeometry, D2D1_COMBINE_MODE combineMode, float flatteningTolerance, D2::SimplifiedGeometrySink& geometrySink) const;
      void combineWithGeometry(D2::Geometry& inputGeometry, D2D1_COMBINE_MODE combineMode, const D2D1_MATRIX_3X2_F& inputGeometryTransform, float flatteningTolerance, D2::SimplifiedGeometrySink& geometrySink) const;
    };

    class GeometryGroup : public D2::Geometry
    {
    public:
      // Constructors
      GeometryGroup() {}
      GeometryGroup(nullptr_t) {}
      explicit GeometryGroup(::ID2D1GeometryGroup* raw) : D2::Geometry(raw) {}
      GeometryGroup(const GeometryGroup& copy_from) : D2::Geometry(copy_from) {}
      GeometryGroup(GeometryGroup&& move_from) : D2::Geometry(std::move(move_from)) {}

      // Operators
      inline GeometryGroup& operator= (const GeometryGroup& copy_from) {D2::Geometry::operator=(copy_from); return *this;}
      inline GeometryGroup& operator= (GeometryGroup&& move_from) {D2::Geometry::operator=(std::move(move_from)); return *this;}
      _OPERATOR_BOOL() const {return getRawInterface() ? _CONVERTIBLE_TO_TRUE : 0;}

      // Utilities
      inline ::ID2D1GeometryGroup* getRawInterface() {return static_cast<::ID2D1GeometryGroup*>(D2::Geometry::getRawInterface());}
      inline const ::ID2D1GeometryGroup* getRawInterface() const {return static_cast<const ::ID2D1GeometryGroup*>(D2::Geometry::getRawInterface());}
      inline void swap(GeometryGroup& other) {D2::Geometry::swap(other);}
      typedef ::ID2D1GeometryGroup dumb_t;

      // Methods
      std::vector<ID2D1Geometry*> getSourceGeometries(unsigned int geometriesCount) const;
      uint32_t getSourceGeometryCount() const;
      D2D1_FILL_MODE getFillMode() const;
    };

    class EllipseGeometry : public D2::Geometry
    {
    public:
      // Constructors
      EllipseGeometry() {}
      EllipseGeometry(nullptr_t) {}
      explicit EllipseGeometry(::ID2D1EllipseGeometry* raw) : D2::Geometry(raw) {}
      EllipseGeometry(const EllipseGeometry& copy_from) : D2::Geometry(copy_from) {}
      EllipseGeometry(EllipseGeometry&& move_from) : D2::Geometry(std::move(move_from)) {}

      // Operators
      inline EllipseGeometry& operator= (const EllipseGeometry& copy_from) {D2::Geometry::operator=(copy_from); return *this;}
      inline EllipseGeometry& operator= (EllipseGeometry&& move_from) {D2::Geometry::operator=(std::move(move_from)); return *this;}
      _OPERATOR_BOOL() const {return getRawInterface() ? _CONVERTIBLE_TO_TRUE : 0;}

      // Utilities
      inline ::ID2D1EllipseGeometry* getRawInterface() {return static_cast<::ID2D1EllipseGeometry*>(D2::Geometry::getRawInterface());}
      inline const ::ID2D1EllipseGeometry* getRawInterface() const {return static_cast<const ::ID2D1EllipseGeometry*>(D2::Geometry::getRawInterface());}
      inline void swap(EllipseGeometry& other) {D2::Geometry::swap(other);}
      typedef ::ID2D1EllipseGeometry dumb_t;

      // Methods
      D2D1_ELLIPSE getEllipse() const;
    };

    class RoundedRectangleGeometry : public D2::Geometry
    {
    public:
      // Constructors
      RoundedRectangleGeometry() {}
      RoundedRectangleGeometry(nullptr_t) {}
      explicit RoundedRectangleGeometry(::ID2D1RoundedRectangleGeometry* raw) : D2::Geometry(raw) {}
      RoundedRectangleGeometry(const RoundedRectangleGeometry& copy_from) : D2::Geometry(copy_from) {}
      RoundedRectangleGeometry(RoundedRectangleGeometry&& move_from) : D2::Geometry(std::move(move_from)) {}

      // Operators
      inline RoundedRectangleGeometry& operator= (const RoundedRectangleGeometry& copy_from) {D2::Geometry::operator=(copy_from); return *this;}
      inline RoundedRectangleGeometry& operator= (RoundedRectangleGeometry&& move_from) {D2::Geometry::operator=(std::move(move_from)); return *this;}
      _OPERATOR_BOOL() const {return getRawInterface() ? _CONVERTIBLE_TO_TRUE : 0;}

      // Utilities
      inline ::ID2D1RoundedRectangleGeometry* getRawInterface() {return static_cast<::ID2D1RoundedRectangleGeometry*>(D2::Geometry::getRawInterface());}
      inline const ::ID2D1RoundedRectangleGeometry* getRawInterface() const {return static_cast<const ::ID2D1RoundedRectangleGeometry*>(D2::Geometry::getRawInterface());}
      inline void swap(RoundedRectangleGeometry& other) {D2::Geometry::swap(other);}
      typedef ::ID2D1RoundedRectangleGeometry dumb_t;

      // Methods
      D2D1_ROUNDED_RECT getRoundedRect() const;
    };

    class TransformedGeometry : public D2::Geometry
    {
    public:
      // Constructors
      TransformedGeometry() {}
      TransformedGeometry(nullptr_t) {}
      explicit TransformedGeometry(::ID2D1TransformedGeometry* raw) : D2::Geometry(raw) {}
      TransformedGeometry(const TransformedGeometry& copy_from) : D2::Geometry(copy_from) {}
      TransformedGeometry(TransformedGeometry&& move_from) : D2::Geometry(std::move(move_from)) {}

      // Operators
      inline TransformedGeometry& operator= (const TransformedGeometry& copy_from) {D2::Geometry::operator=(copy_from); return *this;}
      inline TransformedGeometry& operator= (TransformedGeometry&& move_from) {D2::Geometry::operator=(std::move(move_from)); return *this;}
      _OPERATOR_BOOL() const {return getRawInterface() ? _CONVERTIBLE_TO_TRUE : 0;}

      // Utilities
      inline ::ID2D1TransformedGeometry* getRawInterface() {return static_cast<::ID2D1TransformedGeometry*>(D2::Geometry::getRawInterface());}
      inline const ::ID2D1TransformedGeometry* getRawInterface() const {return static_cast<const ::ID2D1TransformedGeometry*>(D2::Geometry::getRawInterface());}
      inline void swap(TransformedGeometry& other) {D2::Geometry::swap(other);}
      typedef ::ID2D1TransformedGeometry dumb_t;

      // Methods
      D2::Geometry getSourceGeometry() const;
      D2D1_MATRIX_3X2_F getTransform() const;
    };

    class PathGeometry : public D2::Geometry
    {
    public:
      // Constructors
      PathGeometry() {}
      PathGeometry(nullptr_t) {}
      explicit PathGeometry(::ID2D1PathGeometry* raw) : D2::Geometry(raw) {}
      PathGeometry(const PathGeometry& copy_from) : D2::Geometry(copy_from) {}
      PathGeometry(PathGeometry&& move_from) : D2::Geometry(std::move(move_from)) {}

      // Operators
      inline PathGeometry& operator= (const PathGeometry& copy_from) {D2::Geometry::operator=(copy_from); return *this;}
      inline PathGeometry& operator= (PathGeometry&& move_from) {D2::Geometry::operator=(std::move(move_from)); return *this;}
      _OPERATOR_BOOL() const {return getRawInterface() ? _CONVERTIBLE_TO_TRUE : 0;}

      // Utilities
      inline ::ID2D1PathGeometry* getRawInterface() {return static_cast<::ID2D1PathGeometry*>(D2::Geometry::getRawInterface());}
      inline const ::ID2D1PathGeometry* getRawInterface() const {return static_cast<const ::ID2D1PathGeometry*>(D2::Geometry::getRawInterface());}
      inline void swap(PathGeometry& other) {D2::Geometry::swap(other);}
      typedef ::ID2D1PathGeometry dumb_t;

      // Methods
      uint32_t getSegmentCount() const;
      void stream(D2::GeometrySink& geometrySink) const;
      D2::GeometrySink open();
      uint32_t getFigureCount() const;
    };

    class RectangleGeometry : public D2::Geometry
    {
    public:
      // Constructors
      RectangleGeometry() {}
      RectangleGeometry(nullptr_t) {}
      explicit RectangleGeometry(::ID2D1RectangleGeometry* raw) : D2::Geometry(raw) {}
      RectangleGeometry(const RectangleGeometry& copy_from) : D2::Geometry(copy_from) {}
      RectangleGeometry(RectangleGeometry&& move_from) : D2::Geometry(std::move(move_from)) {}

      // Operators
      inline RectangleGeometry& operator= (const RectangleGeometry& copy_from) {D2::Geometry::operator=(copy_from); return *this;}
      inline RectangleGeometry& operator= (RectangleGeometry&& move_from) {D2::Geometry::operator=(std::move(move_from)); return *this;}
      _OPERATOR_BOOL() const {return getRawInterface() ? _CONVERTIBLE_TO_TRUE : 0;}

      // Utilities
      inline ::ID2D1RectangleGeometry* getRawInterface() {return static_cast<::ID2D1RectangleGeometry*>(D2::Geometry::getRawInterface());}
      inline const ::ID2D1RectangleGeometry* getRawInterface() const {return static_cast<const ::ID2D1RectangleGeometry*>(D2::Geometry::getRawInterface());}
      inline void swap(RectangleGeometry& other) {D2::Geometry::swap(other);}
      typedef ::ID2D1RectangleGeometry dumb_t;

      // Methods
      D2D1_RECT_F getRect() const;
    };

    class SimplifiedGeometrySink : public COMObject
    {
    public:
      // Constructors
      SimplifiedGeometrySink() {}
      SimplifiedGeometrySink(nullptr_t) {}
      explicit SimplifiedGeometrySink(::ID2D1SimplifiedGeometrySink* raw) : COMObject(raw) {}
      SimplifiedGeometrySink(const SimplifiedGeometrySink& copy_from) : COMObject(copy_from) {}
      SimplifiedGeometrySink(SimplifiedGeometrySink&& move_from) : COMObject(std::move(move_from)) {}

      // Operators
      inline SimplifiedGeometrySink& operator= (const SimplifiedGeometrySink& copy_from) {COMObject::operator=(copy_from); return *this;}
      inline SimplifiedGeometrySink& operator= (SimplifiedGeometrySink&& move_from) {COMObject::operator=(std::move(move_from)); return *this;}
      _OPERATOR_BOOL() const {return getRawInterface() ? _CONVERTIBLE_TO_TRUE : 0;}

      // Utilities
      inline ::ID2D1SimplifiedGeometrySink* getRawInterface() {return static_cast<::ID2D1SimplifiedGeometrySink*>(COMObject::getRawInterface());}
      inline const ::ID2D1SimplifiedGeometrySink* getRawInterface() const {return static_cast<const ::ID2D1SimplifiedGeometrySink*>(COMObject::getRawInterface());}
      inline void swap(SimplifiedGeometrySink& other) {COMObject::swap(other);}
      typedef ::ID2D1SimplifiedGeometrySink dumb_t;

      // Methods
      void setSegmentFlags(D2D1_PATH_SEGMENT vertexFlags);
      void close();
      void setFillMode(D2D1_FILL_MODE fillMode);
      void endFigure(D2D1_FIGURE_END figureEnd);

      template <typename const_D2D1_BEZIER_SEGMENT_Container>
      void addBeziers(const_D2D1_BEZIER_SEGMENT_Container&& beziers)
      {
        getRawInterface()->AddBeziers(C6::internal::ecount<const_D2D1_BEZIER_SEGMENT_Container>::data(beziers), static_cast<unsigned int>(C6::internal::ecount<const_D2D1_BEZIER_SEGMENT_Container>::size(beziers)));
      }


      template <typename const_D2D1_POINT_2F_Container>
      void addLines(const_D2D1_POINT_2F_Container&& points)
      {
        getRawInterface()->AddLines(C6::internal::ecount<const_D2D1_POINT_2F_Container>::data(points), static_cast<unsigned int>(C6::internal::ecount<const_D2D1_POINT_2F_Container>::size(points)));
      }

      void beginFigure(D2D1_POINT_2F startPoint, D2D1_FIGURE_BEGIN figureBegin);
    };

    class GeometrySink : public D2::SimplifiedGeometrySink
    {
    public:
      // Constructors
      GeometrySink() {}
      GeometrySink(nullptr_t) {}
      explicit GeometrySink(::ID2D1GeometrySink* raw) : D2::SimplifiedGeometrySink(raw) {}
      GeometrySink(const GeometrySink& copy_from) : D2::SimplifiedGeometrySink(copy_from) {}
      GeometrySink(GeometrySink&& move_from) : D2::SimplifiedGeometrySink(std::move(move_from)) {}

      // Operators
      inline GeometrySink& operator= (const GeometrySink& copy_from) {D2::SimplifiedGeometrySink::operator=(copy_from); return *this;}
      inline GeometrySink& operator= (GeometrySink&& move_from) {D2::SimplifiedGeometrySink::operator=(std::move(move_from)); return *this;}
      _OPERATOR_BOOL() const {return getRawInterface() ? _CONVERTIBLE_TO_TRUE : 0;}

      // Utilities
      inline ::ID2D1GeometrySink* getRawInterface() {return static_cast<::ID2D1GeometrySink*>(D2::SimplifiedGeometrySink::getRawInterface());}
      inline const ::ID2D1GeometrySink* getRawInterface() const {return static_cast<const ::ID2D1GeometrySink*>(D2::SimplifiedGeometrySink::getRawInterface());}
      inline void swap(GeometrySink& other) {D2::SimplifiedGeometrySink::swap(other);}
      typedef ::ID2D1GeometrySink dumb_t;

      // Methods
      void addLine(D2D1_POINT_2F point);
      void addBezier(const D2D1_BEZIER_SEGMENT& bezier);
      void addArc(const D2D1_ARC_SEGMENT& arc);

      template <typename const_D2D1_QUADRATIC_BEZIER_SEGMENT_Container>
      void addQuadraticBeziers(const_D2D1_QUADRATIC_BEZIER_SEGMENT_Container&& beziers)
      {
        getRawInterface()->AddQuadraticBeziers(C6::internal::ecount<const_D2D1_QUADRATIC_BEZIER_SEGMENT_Container>::data(beziers), static_cast<unsigned int>(C6::internal::ecount<const_D2D1_QUADRATIC_BEZIER_SEGMENT_Container>::size(beziers)));
      }

      void addQuadraticBezier(const D2D1_QUADRATIC_BEZIER_SEGMENT& bezier);
    };

    class GdiInteropRenderTarget : public COMObject
    {
    public:
      // Constructors
      GdiInteropRenderTarget() {}
      GdiInteropRenderTarget(nullptr_t) {}
      explicit GdiInteropRenderTarget(::ID2D1GdiInteropRenderTarget* raw) : COMObject(raw) {}
      GdiInteropRenderTarget(const GdiInteropRenderTarget& copy_from) : COMObject(copy_from) {}
      GdiInteropRenderTarget(GdiInteropRenderTarget&& move_from) : COMObject(std::move(move_from)) {}

      // Operators
      inline GdiInteropRenderTarget& operator= (const GdiInteropRenderTarget& copy_from) {COMObject::operator=(copy_from); return *this;}
      inline GdiInteropRenderTarget& operator= (GdiInteropRenderTarget&& move_from) {COMObject::operator=(std::move(move_from)); return *this;}
      _OPERATOR_BOOL() const {return getRawInterface() ? _CONVERTIBLE_TO_TRUE : 0;}

      // Utilities
      inline ::ID2D1GdiInteropRenderTarget* getRawInterface() {return static_cast<::ID2D1GdiInteropRenderTarget*>(COMObject::getRawInterface());}
      inline const ::ID2D1GdiInteropRenderTarget* getRawInterface() const {return static_cast<const ::ID2D1GdiInteropRenderTarget*>(COMObject::getRawInterface());}
      inline void swap(GdiInteropRenderTarget& other) {COMObject::swap(other);}
      typedef ::ID2D1GdiInteropRenderTarget dumb_t;

      // Methods
      HDC getDC(D2D1_DC_INITIALIZE_MODE mode);
      void releaseDC();
      void releaseDC(const RECT& update);
    };
  }
  namespace internal
  {
    template <>
    struct ecount<D2::Factory&>
    {
      static size_t size(D2::Factory& x) {return 1;}
      static ID2D1Factory*const* data(D2::Factory& x) {return reinterpret_cast<ID2D1Factory*const*>(&x);}
    };
    template <>
    struct ecount<D2::TessellationSink&>
    {
      static size_t size(D2::TessellationSink& x) {return 1;}
      static ID2D1TessellationSink*const* data(D2::TessellationSink& x) {return reinterpret_cast<ID2D1TessellationSink*const*>(&x);}
    };
    template <>
    struct ecount<D2::Resource&>
    {
      static size_t size(D2::Resource& x) {return 1;}
      static ID2D1Resource*const* data(D2::Resource& x) {return reinterpret_cast<ID2D1Resource*const*>(&x);}
    };
    template <>
    struct ecount<D2::RenderTarget&>
    {
      static size_t size(D2::RenderTarget& x) {return 1;}
      static ID2D1RenderTarget*const* data(D2::RenderTarget& x) {return reinterpret_cast<ID2D1RenderTarget*const*>(&x);}
    };
    template <>
    struct ecount<D2::DCRenderTarget&>
    {
      static size_t size(D2::DCRenderTarget& x) {return 1;}
      static ID2D1DCRenderTarget*const* data(D2::DCRenderTarget& x) {return reinterpret_cast<ID2D1DCRenderTarget*const*>(&x);}
    };
    template <>
    struct ecount<D2::HwndRenderTarget&>
    {
      static size_t size(D2::HwndRenderTarget& x) {return 1;}
      static ID2D1HwndRenderTarget*const* data(D2::HwndRenderTarget& x) {return reinterpret_cast<ID2D1HwndRenderTarget*const*>(&x);}
    };
    template <>
    struct ecount<D2::BitmapRenderTarget&>
    {
      static size_t size(D2::BitmapRenderTarget& x) {return 1;}
      static ID2D1BitmapRenderTarget*const* data(D2::BitmapRenderTarget& x) {return reinterpret_cast<ID2D1BitmapRenderTarget*const*>(&x);}
    };
    template <>
    struct ecount<D2::GradientStopCollection&>
    {
      static size_t size(D2::GradientStopCollection& x) {return 1;}
      static ID2D1GradientStopCollection*const* data(D2::GradientStopCollection& x) {return reinterpret_cast<ID2D1GradientStopCollection*const*>(&x);}
    };
    template <>
    struct ecount<D2::StrokeStyle&>
    {
      static size_t size(D2::StrokeStyle& x) {return 1;}
      static ID2D1StrokeStyle*const* data(D2::StrokeStyle& x) {return reinterpret_cast<ID2D1StrokeStyle*const*>(&x);}
    };
    template <>
    struct ecount<D2::Brush&>
    {
      static size_t size(D2::Brush& x) {return 1;}
      static ID2D1Brush*const* data(D2::Brush& x) {return reinterpret_cast<ID2D1Brush*const*>(&x);}
    };
    template <>
    struct ecount<D2::RadialGradientBrush&>
    {
      static size_t size(D2::RadialGradientBrush& x) {return 1;}
      static ID2D1RadialGradientBrush*const* data(D2::RadialGradientBrush& x) {return reinterpret_cast<ID2D1RadialGradientBrush*const*>(&x);}
    };
    template <>
    struct ecount<D2::SolidColorBrush&>
    {
      static size_t size(D2::SolidColorBrush& x) {return 1;}
      static ID2D1SolidColorBrush*const* data(D2::SolidColorBrush& x) {return reinterpret_cast<ID2D1SolidColorBrush*const*>(&x);}
    };
    template <>
    struct ecount<D2::BitmapBrush&>
    {
      static size_t size(D2::BitmapBrush& x) {return 1;}
      static ID2D1BitmapBrush*const* data(D2::BitmapBrush& x) {return reinterpret_cast<ID2D1BitmapBrush*const*>(&x);}
    };
    template <>
    struct ecount<D2::LinearGradientBrush&>
    {
      static size_t size(D2::LinearGradientBrush& x) {return 1;}
      static ID2D1LinearGradientBrush*const* data(D2::LinearGradientBrush& x) {return reinterpret_cast<ID2D1LinearGradientBrush*const*>(&x);}
    };
    template <>
    struct ecount<D2::DrawingStateBlock&>
    {
      static size_t size(D2::DrawingStateBlock& x) {return 1;}
      static ID2D1DrawingStateBlock*const* data(D2::DrawingStateBlock& x) {return reinterpret_cast<ID2D1DrawingStateBlock*const*>(&x);}
    };
    template <>
    struct ecount<D2::Mesh&>
    {
      static size_t size(D2::Mesh& x) {return 1;}
      static ID2D1Mesh*const* data(D2::Mesh& x) {return reinterpret_cast<ID2D1Mesh*const*>(&x);}
    };
    template <>
    struct ecount<D2::Layer&>
    {
      static size_t size(D2::Layer& x) {return 1;}
      static ID2D1Layer*const* data(D2::Layer& x) {return reinterpret_cast<ID2D1Layer*const*>(&x);}
    };
    template <>
    struct ecount<D2::Bitmap&>
    {
      static size_t size(D2::Bitmap& x) {return 1;}
      static ID2D1Bitmap*const* data(D2::Bitmap& x) {return reinterpret_cast<ID2D1Bitmap*const*>(&x);}
    };
    template <>
    struct ecount<D2::Geometry&>
    {
      static size_t size(D2::Geometry& x) {return 1;}
      static ID2D1Geometry*const* data(D2::Geometry& x) {return reinterpret_cast<ID2D1Geometry*const*>(&x);}
    };
    template <>
    struct ecount<D2::GeometryGroup&>
    {
      static size_t size(D2::GeometryGroup& x) {return 1;}
      static ID2D1GeometryGroup*const* data(D2::GeometryGroup& x) {return reinterpret_cast<ID2D1GeometryGroup*const*>(&x);}
    };
    template <>
    struct ecount<D2::EllipseGeometry&>
    {
      static size_t size(D2::EllipseGeometry& x) {return 1;}
      static ID2D1EllipseGeometry*const* data(D2::EllipseGeometry& x) {return reinterpret_cast<ID2D1EllipseGeometry*const*>(&x);}
    };
    template <>
    struct ecount<D2::RoundedRectangleGeometry&>
    {
      static size_t size(D2::RoundedRectangleGeometry& x) {return 1;}
      static ID2D1RoundedRectangleGeometry*const* data(D2::RoundedRectangleGeometry& x) {return reinterpret_cast<ID2D1RoundedRectangleGeometry*const*>(&x);}
    };
    template <>
    struct ecount<D2::TransformedGeometry&>
    {
      static size_t size(D2::TransformedGeometry& x) {return 1;}
      static ID2D1TransformedGeometry*const* data(D2::TransformedGeometry& x) {return reinterpret_cast<ID2D1TransformedGeometry*const*>(&x);}
    };
    template <>
    struct ecount<D2::PathGeometry&>
    {
      static size_t size(D2::PathGeometry& x) {return 1;}
      static ID2D1PathGeometry*const* data(D2::PathGeometry& x) {return reinterpret_cast<ID2D1PathGeometry*const*>(&x);}
    };
    template <>
    struct ecount<D2::RectangleGeometry&>
    {
      static size_t size(D2::RectangleGeometry& x) {return 1;}
      static ID2D1RectangleGeometry*const* data(D2::RectangleGeometry& x) {return reinterpret_cast<ID2D1RectangleGeometry*const*>(&x);}
    };
    template <>
    struct ecount<D2::SimplifiedGeometrySink&>
    {
      static size_t size(D2::SimplifiedGeometrySink& x) {return 1;}
      static ID2D1SimplifiedGeometrySink*const* data(D2::SimplifiedGeometrySink& x) {return reinterpret_cast<ID2D1SimplifiedGeometrySink*const*>(&x);}
    };
    template <>
    struct ecount<D2::GeometrySink&>
    {
      static size_t size(D2::GeometrySink& x) {return 1;}
      static ID2D1GeometrySink*const* data(D2::GeometrySink& x) {return reinterpret_cast<ID2D1GeometrySink*const*>(&x);}
    };
    template <>
    struct ecount<D2::GdiInteropRenderTarget&>
    {
      static size_t size(D2::GdiInteropRenderTarget& x) {return 1;}
      static ID2D1GdiInteropRenderTarget*const* data(D2::GdiInteropRenderTarget& x) {return reinterpret_cast<ID2D1GdiInteropRenderTarget*const*>(&x);}
    };
  }
}
namespace std {
  inline void swap(C6::D2::Brush& a, C6::D2::Brush& b) {a.swap(b);}
  inline void swap(C6::D2::DCRenderTarget& a, C6::D2::DCRenderTarget& b) {a.swap(b);}
  inline void swap(C6::D2::SolidColorBrush& a, C6::D2::SolidColorBrush& b) {a.swap(b);}
  inline void swap(C6::D2::HwndRenderTarget& a, C6::D2::HwndRenderTarget& b) {a.swap(b);}
  inline void swap(C6::D2::TessellationSink& a, C6::D2::TessellationSink& b) {a.swap(b);}
  inline void swap(C6::D2::BitmapBrush& a, C6::D2::BitmapBrush& b) {a.swap(b);}
  inline void swap(C6::D2::EllipseGeometry& a, C6::D2::EllipseGeometry& b) {a.swap(b);}
  inline void swap(C6::D2::GeometrySink& a, C6::D2::GeometrySink& b) {a.swap(b);}
  inline void swap(C6::D2::Mesh& a, C6::D2::Mesh& b) {a.swap(b);}
  inline void swap(C6::D2::Layer& a, C6::D2::Layer& b) {a.swap(b);}
  inline void swap(C6::D2::RectangleGeometry& a, C6::D2::RectangleGeometry& b) {a.swap(b);}
  inline void swap(C6::D2::LinearGradientBrush& a, C6::D2::LinearGradientBrush& b) {a.swap(b);}
  inline void swap(C6::D2::Bitmap& a, C6::D2::Bitmap& b) {a.swap(b);}
  inline void swap(C6::D2::PathGeometry& a, C6::D2::PathGeometry& b) {a.swap(b);}
  inline void swap(C6::D2::TransformedGeometry& a, C6::D2::TransformedGeometry& b) {a.swap(b);}
  inline void swap(C6::D2::Factory& a, C6::D2::Factory& b) {a.swap(b);}
  inline void swap(C6::D2::Resource& a, C6::D2::Resource& b) {a.swap(b);}
  inline void swap(C6::D2::GradientStopCollection& a, C6::D2::GradientStopCollection& b) {a.swap(b);}
  inline void swap(C6::D2::GeometryGroup& a, C6::D2::GeometryGroup& b) {a.swap(b);}
  inline void swap(C6::D2::Geometry& a, C6::D2::Geometry& b) {a.swap(b);}
  inline void swap(C6::D2::RenderTarget& a, C6::D2::RenderTarget& b) {a.swap(b);}
  inline void swap(C6::D2::SimplifiedGeometrySink& a, C6::D2::SimplifiedGeometrySink& b) {a.swap(b);}
  inline void swap(C6::D2::BitmapRenderTarget& a, C6::D2::BitmapRenderTarget& b) {a.swap(b);}
  inline void swap(C6::D2::RoundedRectangleGeometry& a, C6::D2::RoundedRectangleGeometry& b) {a.swap(b);}
  inline void swap(C6::D2::DrawingStateBlock& a, C6::D2::DrawingStateBlock& b) {a.swap(b);}
  inline void swap(C6::D2::StrokeStyle& a, C6::D2::StrokeStyle& b) {a.swap(b);}
  inline void swap(C6::D2::GdiInteropRenderTarget& a, C6::D2::GdiInteropRenderTarget& b) {a.swap(b);}
  inline void swap(C6::D2::RadialGradientBrush& a, C6::D2::RadialGradientBrush& b) {a.swap(b);}
}
inline D2D1_POINT_2F operator + (D2D1_POINT_2F lhs, D2D1_POINT_2F rhs)
{
  return D2D1::Point2F(lhs.x + rhs.x, lhs.y + rhs.y);
}
inline D2D1_POINT_2F operator - (D2D1_POINT_2F lhs, D2D1_POINT_2F rhs)
{
  return D2D1::Point2F(lhs.x - rhs.x, lhs.y - rhs.y);
}
